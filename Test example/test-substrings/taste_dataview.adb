-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH TASTE_BasicTypes;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function MyInteger_Equal(val1, val2: in MyInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyInteger_Equal;

function MyInteger_Init return MyInteger
is
    val: MyInteger;
begin
    val := TASTE_BasicTypes.T_UInt8_Init;
    return val;
end MyInteger_Init;

FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_MYINTEGER);
    RETURN ret;
END MyInteger_IsConstraintValid;



function MySeq_b_Equal(val1, val2: in MySeq_b)
    return Boolean 
is
begin
	return val1 = val2;

end MySeq_b_Equal;

function MySeq_Equal(val1, val2: in MySeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.a = val2.a);

    if ret then
        ret := MySeq_b_Equal(val1.b, val2.b);

    end if;
	return ret;

end MySeq_Equal;

function MySeq_b_Init return MySeq_b
is
    val: MySeq_b;
begin
    val := taste;
    return val;
end MySeq_b_Init;
function MySeq_Init return MySeq
is
    val: MySeq;
begin

    --set a 
    val.a := MyInteger_Init;
    --set b 
    val.b := MySeq_b_Init;
    return val;
end MySeq_Init;

FUNCTION MySeq_IsConstraintValid(val : in MySeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.a <= 255), ErrorCode => ERR_MYSEQ_A);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b = taste)) OR ((val.b = welcomes)))) OR ((val.b = you))), ErrorCode => ERR_MYSEQ_B);
    end if;

    RETURN ret;
END MySeq_IsConstraintValid;



function MyChoice_Equal(val1, val2: in MyChoice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when a_PRESENT =>
                ret := (val1.a = val2.a);
            when b_PRESENT =>
                ret := MySeq_Equal(val1.b, val2.b);
        end case;
    end if;
	return ret;

end MyChoice_Equal;

function MyChoice_Init return MyChoice
is
    val: MyChoice;
begin
    --set a 
    declare
        a_tmp:adaasn1rtl.Asn1Boolean;
    begin
        a_tmp := FALSE;
        val := MyChoice'(kind => a_PRESENT, a => a_tmp);
    end;
    return val;
end MyChoice_Init;

FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A);
        WHEN b_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.b.a <= 255), ErrorCode => ERR_MYCHOICE_B_A);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b.b = taste)) OR ((val.b.b = welcomes)))) OR ((val.b.b = you))), ErrorCode => ERR_MYCHOICE_B_B);
            end if;

    end case;
    RETURN ret;
END MyChoice_IsConstraintValid;



function SeqInt_Equal(val1, val2: in SeqInt)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqInt_Equal;

function SeqInt_Init return SeqInt
is
    val: SeqInt;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := TASTE_BasicTypes.T_UInt8_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqInt_Init;

FUNCTION SeqInt_IsConstraintValid(val : in SeqInt) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 2)), ErrorCode => ERR_SEQINT);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_SEQINT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqInt_IsConstraintValid;



function IntSeq_Equal(val1, val2: in IntSeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end IntSeq_Equal;

function IntSeq_Init return IntSeq
is
    val: IntSeq;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := TASTE_BasicTypes.T_UInt8_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end IntSeq_Init;

FUNCTION IntSeq_IsConstraintValid(val : in IntSeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_INTSEQ);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_INTSEQ_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END IntSeq_IsConstraintValid;



function FixedIntSeq_Equal(val1, val2: in FixedIntSeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 5 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end FixedIntSeq_Equal;

function FixedIntSeq_Init return FixedIntSeq
is
    val: FixedIntSeq;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := TASTE_BasicTypes.T_UInt8_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end FixedIntSeq_Init;

FUNCTION FixedIntSeq_IsConstraintValid(val : in FixedIntSeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 5 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 5);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_FIXEDINTSEQ_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END FixedIntSeq_IsConstraintValid;



function MyReal_Equal(val1, val2: in MyReal)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end MyReal_Equal;

function MyReal_Init return MyReal
is
    val: MyReal;
begin
    val := 0.00000000000000000000E+000;
    return val;
end MyReal_Init;

FUNCTION MyReal_IsConstraintValid(val : in MyReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+003)), ErrorCode => ERR_MYREAL);
    RETURN ret;
END MyReal_IsConstraintValid;



function LargerReal_Equal(val1, val2: in LargerReal)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end LargerReal_Equal;

function LargerReal_Init return LargerReal
is
    val: LargerReal;
begin
    val := 0.00000000000000000000E+000;
    return val;
end LargerReal_Init;

FUNCTION LargerReal_IsConstraintValid(val : in LargerReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+009)), ErrorCode => ERR_LARGERREAL);
    RETURN ret;
END LargerReal_IsConstraintValid;



function MyEnum_Equal(val1, val2: in MyEnum)
    return Boolean 
is
begin
	return val1 = val2;

end MyEnum_Equal;

function MyEnum_Init return MyEnum
is
    val: MyEnum;
begin
    val := hello;
    return val;
end MyEnum_Init;

FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = hello)) OR ((val = world)))) OR ((val = howareyou))), ErrorCode => ERR_MYENUM);
    RETURN ret;
END MyEnum_IsConstraintValid;



function MySeqOf_Equal(val1, val2: in MySeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MySeqOf_Equal;

function MySeqOf_Init return MySeqOf
is
    val: MySeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := MyEnum_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end MySeqOf_Init;

FUNCTION MySeqOf_IsConstraintValid(val : in MySeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.Data(i1) = hello)) OR ((val.Data(i1) = world)))) OR ((val.Data(i1) = howareyou))), ErrorCode => ERR_MYSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MySeqOf_IsConstraintValid;



function SeqBool_Equal(val1, val2: in SeqBool)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end SeqBool_Equal;

function SeqBool_Init return SeqBool
is
    val: SeqBool;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end SeqBool_Init;

FUNCTION SeqBool_IsConstraintValid(val : in SeqBool) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBOOL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBool_IsConstraintValid;



function SeqBool2_Equal(val1, val2: in SeqBool2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqBool2_Equal;

function SeqBool2_Init return SeqBool2
is
    val: SeqBool2;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqBool2_Init;

FUNCTION SeqBool2_IsConstraintValid(val : in SeqBool2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 2)), ErrorCode => ERR_SEQBOOL2);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBOOL2_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBool2_IsConstraintValid;



function MyOctStr_Equal(val1, val2: in MyOctStr)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end MyOctStr_Equal;

function MyOctStr_Init return MyOctStr
is
    val: MyOctStr;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

    return val;
end MyOctStr_Init;



function String_Equal(val1, val2: in String)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end String_Equal;

function String_Init return String
is
    val: String;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 100;
    return val;
end String_Init;

FUNCTION String_IsConstraintValid(val : in String) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_STRING);
    RETURN ret;
END String_IsConstraintValid;


 

END TASTE_Dataview;