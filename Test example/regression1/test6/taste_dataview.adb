-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH TASTE_BasicTypes;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function MyInteger_Equal(val1, val2: in MyInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyInteger_Equal;

function MyInteger_Init return MyInteger
is
    val: MyInteger;
begin
    val := TASTE_BasicTypes.T_UInt8_Init;
    return val;
end MyInteger_Init;

FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_MYINTEGER);
    RETURN ret;
END MyInteger_IsConstraintValid;



function MySeq_b_Equal(val1, val2: in MySeq_b)
    return Boolean 
is
begin
	return val1 = val2;

end MySeq_b_Equal;

function MySeq_Equal(val1, val2: in MySeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.a = val2.a);

    if ret then
        ret := MySeq_b_Equal(val1.b, val2.b);

    end if;
	return ret;

end MySeq_Equal;

function MySeq_b_Init return MySeq_b
is
    val: MySeq_b;
begin
    val := taste;
    return val;
end MySeq_b_Init;
function MySeq_Init return MySeq
is
    val: MySeq;
begin

    --set a 
    val.a := MyInteger_Init;
    --set b 
    val.b := MySeq_b_Init;
    return val;
end MySeq_Init;

FUNCTION MySeq_IsConstraintValid(val : in MySeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.a <= 255), ErrorCode => ERR_MYSEQ_A);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b = taste)) OR ((val.b = welcomes)))) OR ((val.b = you))), ErrorCode => ERR_MYSEQ_B);
    end if;

    RETURN ret;
END MySeq_IsConstraintValid;



function MyChoice_Equal(val1, val2: in MyChoice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when a_b_PRESENT =>
                ret := (val1.a_b = val2.a_b);
            when b_PRESENT =>
                ret := MySeq_Equal(val1.b, val2.b);
        end case;
    end if;
	return ret;

end MyChoice_Equal;

function MyChoice_Init return MyChoice
is
    val: MyChoice;
begin
    --set a_b 
    declare
        a_b_tmp:adaasn1rtl.Asn1Boolean;
    begin
        a_b_tmp := FALSE;
        val := MyChoice'(kind => a_b_PRESENT, a_b => a_b_tmp);
    end;
    return val;
end MyChoice_Init;

FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN a_b_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A_B);
        WHEN b_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.b.a <= 255), ErrorCode => ERR_MYCHOICE_B_A);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b.b = taste)) OR ((val.b.b = welcomes)))) OR ((val.b.b = you))), ErrorCode => ERR_MYCHOICE_B_B);
            end if;

    end case;
    RETURN ret;
END MyChoice_IsConstraintValid;



function SeqInt_Equal(val1, val2: in SeqInt)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqInt_Equal;

function SeqInt_Init return SeqInt
is
    val: SeqInt;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := TASTE_BasicTypes.T_UInt8_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqInt_Init;

FUNCTION SeqInt_IsConstraintValid(val : in SeqInt) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 2)), ErrorCode => ERR_SEQINT);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_SEQINT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqInt_IsConstraintValid;



function MyReal_Equal(val1, val2: in MyReal)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end MyReal_Equal;

function MyReal_Init return MyReal
is
    val: MyReal;
begin
    val := 0.00000000000000000000E+000;
    return val;
end MyReal_Init;

FUNCTION MyReal_IsConstraintValid(val : in MyReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+003)), ErrorCode => ERR_MYREAL);
    RETURN ret;
END MyReal_IsConstraintValid;



function LargerReal_Equal(val1, val2: in LargerReal)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end LargerReal_Equal;

function LargerReal_Init return LargerReal
is
    val: LargerReal;
begin
    val := 0.00000000000000000000E+000;
    return val;
end LargerReal_Init;

FUNCTION LargerReal_IsConstraintValid(val : in LargerReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+009)), ErrorCode => ERR_LARGERREAL);
    RETURN ret;
END LargerReal_IsConstraintValid;



function MyEnum_Equal(val1, val2: in MyEnum)
    return Boolean 
is
begin
	return val1 = val2;

end MyEnum_Equal;

function MyEnum_Init return MyEnum
is
    val: MyEnum;
begin
    val := hello;
    return val;
end MyEnum_Init;

FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = hello)) OR ((val = world)))) OR ((val = howareyou))), ErrorCode => ERR_MYENUM);
    RETURN ret;
END MyEnum_IsConstraintValid;



function MySeqOf_Equal(val1, val2: in MySeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MySeqOf_Equal;

function MySeqOf_Init return MySeqOf
is
    val: MySeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := MyEnum_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end MySeqOf_Init;

FUNCTION MySeqOf_IsConstraintValid(val : in MySeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.Data(i1) = hello)) OR ((val.Data(i1) = world)))) OR ((val.Data(i1) = howareyou))), ErrorCode => ERR_MYSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MySeqOf_IsConstraintValid;



function MyOctStr_Equal(val1, val2: in MyOctStr)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end MyOctStr_Equal;

function MyOctStr_Init return MyOctStr
is
    val: MyOctStr;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

    return val;
end MyOctStr_Init;



function String_Equal(val1, val2: in String)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end String_Equal;

function String_Init return String
is
    val: String;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 100;
    return val;
end String_Init;

FUNCTION String_IsConstraintValid(val : in String) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_STRING);
    RETURN ret;
END String_IsConstraintValid;



function Autocompletion_secondField_Equal(val1, val2: in Autocompletion_secondField)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.third = val2.third);

    if ret then
        ret := (val1.fourth = val2.fourth);

    end if;
	return ret;

end Autocompletion_secondField_Equal;

function Autocompletion_Equal(val1, val2: in Autocompletion)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.first_field = val2.first_field);

    if ret then
        ret := Autocompletion_secondField_Equal(val1.secondField, val2.secondField);

    end if;
	return ret;

end Autocompletion_Equal;

function Autocompletion_secondField_Init return Autocompletion_secondField
is
    val: Autocompletion_secondField;
begin

    --set third 
    val.third := FALSE;
    --set fourth 
    val.fourth := FALSE;
    return val;
end Autocompletion_secondField_Init;
function Autocompletion_Init return Autocompletion
is
    val: Autocompletion;
begin

    --set first_field 
    val.first_field := FALSE;
    --set secondField 
    val.secondField := Autocompletion_secondField_Init;
    return val;
end Autocompletion_Init;

FUNCTION Autocompletion_IsConstraintValid(val : in Autocompletion) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_AUTOCOMPLETION_FIRST_FIELD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_AUTOCOMPLETION_SECONDFIELD_THIRD);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_AUTOCOMPLETION_SECONDFIELD_FOURTH);
        end if;

    end if;

    RETURN ret;
END Autocompletion_IsConstraintValid;


 

END TASTE_Dataview;