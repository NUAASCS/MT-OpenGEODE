-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function Boolean_Equal(val1, val2: in Boolean)
    return Boolean 
is
begin
	return val1 = val2;

end Boolean_Equal;

function Boolean_Init return Boolean
is
    val: Boolean;
begin
    val := FALSE;
    return val;
end Boolean_Init;

FUNCTION Boolean_IsConstraintValid(val : in Boolean) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_BOOLEAN);
    RETURN ret;
END Boolean_IsConstraintValid;



function Integer_Equal(val1, val2: in Integer)
    return Boolean 
is
begin
	return val1 = val2;

end Integer_Equal;

function Integer_Init return Integer
is
    val: Integer;
begin
    val := 0;
    return val;
end Integer_Init;

FUNCTION Integer_IsConstraintValid(val : in Integer) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_INTEGER);
    RETURN ret;
END Integer_IsConstraintValid;



function IntegerSeqOf_Equal(val1, val2: in IntegerSeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end IntegerSeqOf_Equal;

function IntegerSeqOf_Init return IntegerSeqOf
is
    val: IntegerSeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 32 loop
        pragma Loop_Invariant (i1 >=1 and i1<=32);
        val.Data(i1) := Integer_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end IntegerSeqOf_Init;

FUNCTION IntegerSeqOf_IsConstraintValid(val : in IntegerSeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 32)), ErrorCode => ERR_INTEGERSEQOF);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_INTEGERSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END IntegerSeqOf_IsConstraintValid;



function Real_Equal(val1, val2: in Real)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end Real_Equal;

function Real_Init return Real
is
    val: Real;
begin
    val := 0.00000000000000000000E+000;
    return val;
end Real_Init;

FUNCTION Real_IsConstraintValid(val : in Real) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val) AND (val <= 1.00000000000000000000E+308)), ErrorCode => ERR_REAL);
    RETURN ret;
END Real_IsConstraintValid;



function CharString_Equal(val1, val2: in CharString)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end CharString_Equal;

function CharString_Init return CharString
is
    val: CharString;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 100;
    return val;
end CharString_Init;

FUNCTION CharString_IsConstraintValid(val : in CharString) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_CHARSTRING);
    RETURN ret;
END CharString_IsConstraintValid;


 

END TASTE_Dataview;