-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function Seq_b_Equal(val1, val2: in Seq_b)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.Exist.b_C = val2.Exist.b_C;
    if ret and then val1.Exist.b_C = 1 then
        ret := (val1.b_C = val2.b_C);
    end if;

	return ret;

end Seq_b_Equal;

function Seq_Equal(val1, val2: in Seq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.Exist.a = val2.Exist.a;
    if ret and then val1.Exist.a = 1 then
        ret := (val1.a = val2.a);
    end if;

    if ret then
        ret := val1.Exist.b = val2.Exist.b;
        if ret and then val1.Exist.b = 1 then
            ret := Seq_b_Equal(val1.b, val2.b);
        end if;

    end if;
	return ret;

end Seq_Equal;

function Seq_b_Init return Seq_b
is
    val: Seq_b;
begin

    --set b_C 
    val.exist.b_C := 1;
    val.b_C := FALSE;
    return val;
end Seq_b_Init;
function Seq_Init return Seq
is
    val: Seq;
begin

    --set a 
    val.exist.a := 1;
    val.a := FALSE;
    --set b 
    val.exist.b := 1;
    val.b := Seq_b_Init;
    return val;
end Seq_Init;

FUNCTION Seq_IsConstraintValid(val : in Seq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    if val.Exist.a = 1 then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQ_A);
    end if;
    if ret.Success then
        if val.Exist.b = 1 then
            if val.b.Exist.b_C = 1 then
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQ_B_B_C);
            end if;
        end if;
    end if;

    RETURN ret;
END Seq_IsConstraintValid;



function ChoiceWithInnerSeq_ch2_Equal(val1, val2: in ChoiceWithInnerSeq_ch2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.Exist.opt_field = val2.Exist.opt_field;
    if ret and then val1.Exist.opt_field = 1 then
        ret := (val1.opt_field = val2.opt_field);
    end if;

	return ret;

end ChoiceWithInnerSeq_ch2_Equal;

function ChoiceWithInnerSeq_Equal(val1, val2: in ChoiceWithInnerSeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when ch1_PRESENT =>
                ret := Seq_Equal(val1.ch1, val2.ch1);
            when ch2_PRESENT =>
                ret := val1.ch2.Exist.opt_field = val2.ch2.Exist.opt_field;
                if ret and then val1.ch2.Exist.opt_field = 1 then
                    ret := (val1.ch2.opt_field = val2.ch2.opt_field);
                end if;

        end case;
    end if;
	return ret;

end ChoiceWithInnerSeq_Equal;

function ChoiceWithInnerSeq_ch2_Init return ChoiceWithInnerSeq_ch2
is
    val: ChoiceWithInnerSeq_ch2;
begin

    --set opt_field 
    val.exist.opt_field := 1;
    val.opt_field := FALSE;
    return val;
end ChoiceWithInnerSeq_ch2_Init;
function ChoiceWithInnerSeq_Init return ChoiceWithInnerSeq
is
    val: ChoiceWithInnerSeq;
begin
    --set ch1 
    declare
        ch1_tmp:Seq;
    begin
        ch1_tmp := Seq_Init;
        val := ChoiceWithInnerSeq'(kind => ch1_PRESENT, ch1 => ch1_tmp);
    end;
    return val;
end ChoiceWithInnerSeq_Init;

FUNCTION ChoiceWithInnerSeq_IsConstraintValid(val : in ChoiceWithInnerSeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN ch1_PRESENT =>
            if val.ch1.Exist.a = 1 then
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_CHOICEWITHINNERSEQ_CH1_A);
            end if;
            if ret.Success then
                if val.ch1.Exist.b = 1 then
                    if val.ch1.b.Exist.b_C = 1 then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_CHOICEWITHINNERSEQ_CH1_B_B_C);
                    end if;
                end if;
            end if;

        WHEN ch2_PRESENT =>
            if val.ch2.Exist.opt_field = 1 then
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_CHOICEWITHINNERSEQ_CH2_OPT_FIELD);
            end if;
    end case;
    RETURN ret;
END ChoiceWithInnerSeq_IsConstraintValid;



function SeqPresent_Equal(val1, val2: in SeqPresent) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Seq_Equal(val1, val2);
    return ret;
end SeqPresent_Equal;

function SeqPresent_Init return SeqPresent
is
    val: SeqPresent;
begin

    --set a 
    val.exist.a := 1;
    val.a := FALSE;
    --set b 
    val.exist.b := 1;
    val.b := Seq_b_Init;
    return val;
end SeqPresent_Init;

FUNCTION SeqPresent_IsConstraintValid(val : in SeqPresent) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret:= adaasn1rtl.ASN1_RESULT'(Success => val.Exist.a=1, ErrorCode => ERR_SEQPRESENT_A_IS_ABSENT);
    if val.Exist.a = 1 then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQPRESENT_A);
    end if;
    if ret.Success then
        if val.Exist.b = 1 then
            if val.b.Exist.b_C = 1 then
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQPRESENT_B_B_C);
            end if;
        end if;
    end if;

    RETURN ret;
END SeqPresent_IsConstraintValid;



function SeqAbsent_Equal(val1, val2: in SeqAbsent) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Seq_Equal(val1, val2);
    return ret;
end SeqAbsent_Equal;

function SeqAbsent_Init return SeqAbsent
is
    val: SeqAbsent;
begin

    val.exist.a := 0;
    --set b 
    val.exist.b := 1;
    val.b := Seq_b_Init;
    return val;
end SeqAbsent_Init;

FUNCTION SeqAbsent_IsConstraintValid(val : in SeqAbsent) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret:= adaasn1rtl.ASN1_RESULT'(Success => val.Exist.a=0, ErrorCode => ERR_SEQABSENT_A_IS_PRESENT);
    if val.Exist.a = 1 then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQABSENT_A);
    end if;
    if ret.Success then
        if val.Exist.b = 1 then
            if val.b.Exist.b_C = 1 then
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQABSENT_B_B_C);
            end if;
        end if;
    end if;

    RETURN ret;
END SeqAbsent_IsConstraintValid;



function SeqDef_b_Equal(val1, val2: in SeqDef_b)
    return Boolean 
is
begin
	return val1 = val2;

end SeqDef_b_Equal;

function SeqDef_c_Equal(val1, val2: in SeqDef_c)
    return Boolean 
is
begin
	return val1 = val2;

end SeqDef_c_Equal;

function SeqDef_d_Equal(val1, val2: in SeqDef_d)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.thanassis = val2.thanassis);

	return ret;

end SeqDef_d_Equal;

function SeqDef_Equal(val1, val2: in SeqDef)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.Exist.a = val2.Exist.a;
    if ret and then val1.Exist.a = 1 then
        ret := (val1.a = val2.a);
    end if;

    if ret then
        ret := val1.Exist.b = val2.Exist.b;
        if ret and then val1.Exist.b = 1 then
            ret := SeqDef_b_Equal(val1.b, val2.b);
        end if;

        if ret then
            ret := SeqDef_c_Equal(val1.c, val2.c);

            if ret then
                ret := val1.Exist.d = val2.Exist.d;
                if ret and then val1.Exist.d = 1 then
                    ret := SeqDef_d_Equal(val1.d, val2.d);
                end if;

            end if;
        end if;
    end if;
	return ret;

end SeqDef_Equal;

function SeqDef_b_Init return SeqDef_b
is
    val: SeqDef_b;
begin
    val := 10;
    return val;
end SeqDef_b_Init;
function SeqDef_c_Init return SeqDef_c
is
    val: SeqDef_c;
begin
    val := 8;
    return val;
end SeqDef_c_Init;
function SeqDef_d_Init return SeqDef_d
is
    val: SeqDef_d;
begin

    --set thanassis 
    val.thanassis := FALSE;
    return val;
end SeqDef_d_Init;
function SeqDef_Init return SeqDef
is
    val: SeqDef;
begin

    --set a 
    val.exist.a := 1;
    val.a := FALSE;
    --set b 
    val.exist.b := 1;
    val.b := SeqDef_b_Init;
    --set c 
    val.c := SeqDef_c_Init;
    --set d 
    val.exist.d := 1;
    val.d := SeqDef_d_Init;
    return val;
end SeqDef_Init;

FUNCTION SeqDef_IsConstraintValid(val : in SeqDef) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    if val.Exist.a = 1 then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQDEF_A);
    end if;
    if ret.Success then
        if val.Exist.b = 1 then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((10 <= val.b) AND (val.b <= 20)), ErrorCode => ERR_SEQDEF_B);
        end if;
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((8 <= val.c) AND (val.c <= 255)), ErrorCode => ERR_SEQDEF_C);
            if ret.Success then
                if val.Exist.d = 1 then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQDEF_D_THANASSIS);
                end if;
            end if;

        end if;

    end if;

    RETURN ret;
END SeqDef_IsConstraintValid;



function SomeSeq_Equal(val1, val2: in SomeSeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.thanassis = val2.thanassis);

	return ret;

end SomeSeq_Equal;

function SomeSeq_Init return SomeSeq
is
    val: SomeSeq;
begin

    --set thanassis 
    val.thanassis := FALSE;
    return val;
end SomeSeq_Init;

FUNCTION SomeSeq_IsConstraintValid(val : in SomeSeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SOMESEQ_THANASSIS);
    RETURN ret;
END SomeSeq_IsConstraintValid;


 

END TASTE_Dataview;