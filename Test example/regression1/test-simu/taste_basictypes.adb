-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_BasicTypes with SPARK_Mode IS




function T_UInt32_Equal(val1, val2: in T_UInt32)
    return Boolean 
is
begin
	return val1 = val2;

end T_UInt32_Equal;

function T_UInt32_Init return T_UInt32
is
    val: T_UInt32;
begin
    val := 0;
    return val;
end T_UInt32_Init;

FUNCTION T_UInt32_IsConstraintValid(val : in T_UInt32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_T_UINT32);
    RETURN ret;
END T_UInt32_IsConstraintValid;



function TASTE_Peek_id_Equal(val1, val2: in TASTE_Peek_id)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_id_Equal;

function TASTE_Peek_id_Init return TASTE_Peek_id
is
    val: TASTE_Peek_id;
begin
    val := 0;
    return val;
end TASTE_Peek_id_Init;

FUNCTION TASTE_Peek_id_IsConstraintValid(val : in TASTE_Peek_id) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_TASTE_PEEK_ID);
    RETURN ret;
END TASTE_Peek_id_IsConstraintValid;



function TASTE_Peek_id_list_Equal(val1, val2: in TASTE_Peek_id_list)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TASTE_Peek_id_list_Equal;

function TASTE_Peek_id_list_Init return TASTE_Peek_id_list
is
    val: TASTE_Peek_id_list;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := TASTE_Peek_id_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end TASTE_Peek_id_list_Init;

FUNCTION TASTE_Peek_id_list_IsConstraintValid(val : in TASTE_Peek_id_list) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 10)), ErrorCode => ERR_TASTE_PEEK_ID_LIST);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 4294967295), ErrorCode => ERR_TASTE_PEEK_ID_LIST_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END TASTE_Peek_id_list_IsConstraintValid;



function FixedIntList_Equal(val1, val2: in FixedIntList)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end FixedIntList_Equal;

function FixedIntList_Init return FixedIntList
is
    val: FixedIntList;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := TASTE_Peek_id_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end FixedIntList_Init;

FUNCTION FixedIntList_IsConstraintValid(val : in FixedIntList) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 3);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 4294967295), ErrorCode => ERR_FIXEDINTLIST_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END FixedIntList_IsConstraintValid;



function MyEnum_Equal(val1, val2: in MyEnum)
    return Boolean 
is
begin
	return val1 = val2;

end MyEnum_Equal;

function MyEnum_Init return MyEnum
is
    val: MyEnum;
begin
    val := one;
    return val;
end MyEnum_Init;

FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val = one)) OR ((val = two)))) OR ((val = three)))) OR ((val = four)))) OR ((val = five))), ErrorCode => ERR_MYENUM);
    RETURN ret;
END MyEnum_IsConstraintValid;



function MySimpleSeq_a_Equal(val1, val2: in MySimpleSeq_a)
    return Boolean 
is
begin
	return val1 = val2;

end MySimpleSeq_a_Equal;

function MySimpleSeq_Equal(val1, val2: in MySimpleSeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MySimpleSeq_a_Equal(val1.a, val2.a);

    if ret then
        ret := (val1.b = val2.b);

        if ret then
            ret := (val1.c = val2.c);

        end if;
    end if;
	return ret;

end MySimpleSeq_Equal;

function MySimpleSeq_a_Init return MySimpleSeq_a
is
    val: MySimpleSeq_a;
begin
    val := 0;
    return val;
end MySimpleSeq_a_Init;
function MySimpleSeq_Init return MySimpleSeq
is
    val: MySimpleSeq;
begin

    --set a 
    val.a := MySimpleSeq_a_Init;
    --set b 
    val.b := FALSE;
    --set c 
    val.c := MyEnum_Init;
    return val;
end MySimpleSeq_Init;

FUNCTION MySimpleSeq_IsConstraintValid(val : in MySimpleSeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.a <= 255), ErrorCode => ERR_MYSIMPLESEQ_A);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYSIMPLESEQ_B);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.c = one)) OR ((val.c = two)))) OR ((val.c = three)))) OR ((val.c = four)))) OR ((val.c = five))), ErrorCode => ERR_MYSIMPLESEQ_C);
        end if;

    end if;

    RETURN ret;
END MySimpleSeq_IsConstraintValid;



function MyChoice_b_Equal(val1, val2: in MyChoice_b)
    return Boolean 
is
begin
	return val1 = val2;

end MyChoice_b_Equal;

function MyChoice_Equal(val1, val2: in MyChoice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when a_PRESENT =>
                ret := (val1.a = val2.a);
            when b_PRESENT =>
                ret := (val1.b = val2.b);
        end case;
    end if;
	return ret;

end MyChoice_Equal;

function MyChoice_b_Init return MyChoice_b
is
    val: MyChoice_b;
begin
    val := aa;
    return val;
end MyChoice_b_Init;
function MyChoice_Init return MyChoice
is
    val: MyChoice;
begin
    --set a 
    declare
        a_tmp:adaasn1rtl.Asn1Boolean;
    begin
        a_tmp := FALSE;
        val := MyChoice'(kind => a_PRESENT, a => a_tmp);
    end;
    return val;
end MyChoice_Init;

FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A);
        WHEN b_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.b = aa)) OR ((val.b = bb))), ErrorCode => ERR_MYCHOICE_B);
    end case;
    RETURN ret;
END MyChoice_IsConstraintValid;



function MySeq_Equal(val1, val2: in MySeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.a = val2.a);

    if ret then
        ret := MyChoice_Equal(val1.b, val2.b);

    end if;
	return ret;

end MySeq_Equal;

function MySeq_Init return MySeq
is
    val: MySeq;
begin

    --set a 
    val.a := FALSE;
    --set b 
    val.b := MyChoice_Init;
    return val;
end MySeq_Init;

FUNCTION MySeq_IsConstraintValid(val : in MySeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYSEQ_A);
    if ret.Success then
        case val.b.kind is
            WHEN a_PRESENT =>
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYSEQ_B_A);
            WHEN b_PRESENT =>
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.b.b = aa)) OR ((val.b.b = bb))), ErrorCode => ERR_MYSEQ_B_B);
        end case;
    end if;

    RETURN ret;
END MySeq_IsConstraintValid;



function MySetOf_elem_Equal(val1, val2: in MySetOf_elem)
    return Boolean 
is
begin
	return val1 = val2;

end MySetOf_elem_Equal;

function MySetOf_Equal(val1, val2: in MySetOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MySetOf_Equal;

function MySetOf_elem_Init return MySetOf_elem
is
    val: MySetOf_elem;
begin
    val := 0;
    return val;
end MySetOf_elem_Init;
function MySetOf_Init return MySetOf
is
    val: MySetOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := MySetOf_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end MySetOf_Init;

FUNCTION MySetOf_IsConstraintValid(val : in MySetOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 3)), ErrorCode => ERR_MYSETOF);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 10), ErrorCode => ERR_MYSETOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MySetOf_IsConstraintValid;



function MySeqOf_elem_Equal(val1, val2: in MySeqOf_elem)
    return Boolean 
is
begin
	return val1 = val2;

end MySeqOf_elem_Equal;

function MySeqOf_Equal(val1, val2: in MySeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MySeqOf_Equal;

function MySeqOf_elem_Init return MySeqOf_elem
is
    val: MySeqOf_elem;
begin
    val := 0;
    return val;
end MySeqOf_elem_Init;
function MySeqOf_Init return MySeqOf
is
    val: MySeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := MySeqOf_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end MySeqOf_Init;

FUNCTION MySeqOf_IsConstraintValid(val : in MySeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 3)), ErrorCode => ERR_MYSEQOF);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 10), ErrorCode => ERR_MYSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MySeqOf_IsConstraintValid;


 

END TASTE_BasicTypes;