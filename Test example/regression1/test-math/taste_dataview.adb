-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function Boolean_Equal(val1, val2: in Boolean)
    return Boolean 
is
begin
	return val1 = val2;

end Boolean_Equal;

function Boolean_Init return Boolean
is
    val: Boolean;
begin
    val := FALSE;
    return val;
end Boolean_Init;

FUNCTION Boolean_IsConstraintValid(val : in Boolean) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_BOOLEAN);
    RETURN ret;
END Boolean_IsConstraintValid;



function BoolSeqOf_Equal(val1, val2: in BoolSeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end BoolSeqOf_Equal;

function BoolSeqOf_Init return BoolSeqOf
is
    val: BoolSeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4);
        val.Data(i1) := Boolean_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end BoolSeqOf_Init;

FUNCTION BoolSeqOf_IsConstraintValid(val : in BoolSeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_BOOLSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END BoolSeqOf_IsConstraintValid;



function Integer_Equal(val1, val2: in Integer)
    return Boolean 
is
begin
	return val1 = val2;

end Integer_Equal;

function Integer_Init return Integer
is
    val: Integer;
begin
    val := 0;
    return val;
end Integer_Init;

FUNCTION Integer_IsConstraintValid(val : in Integer) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_INTEGER);
    RETURN ret;
END Integer_IsConstraintValid;



function FixSeqof_Equal(val1, val2: in FixSeqof)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end FixSeqof_Equal;

function FixSeqof_Init return FixSeqof
is
    val: FixSeqof;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := Integer_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end FixSeqof_Init;

FUNCTION FixSeqof_IsConstraintValid(val : in FixSeqof) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 3);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_FIXSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END FixSeqof_IsConstraintValid;



function VarSeqof_Equal(val1, val2: in VarSeqof)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end VarSeqof_Equal;

function VarSeqof_Init return VarSeqof
is
    val: VarSeqof;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := Integer_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end VarSeqof_Init;

FUNCTION VarSeqof_IsConstraintValid(val : in VarSeqof) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_VARSEQOF);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_VARSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END VarSeqof_IsConstraintValid;



function NestedSeq_a_b_c_Equal(val1, val2: in NestedSeq_a_b_c)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.d = val2.d);

	return ret;

end NestedSeq_a_b_c_Equal;

function NestedSeq_a_b_Equal(val1, val2: in NestedSeq_a_b)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := NestedSeq_a_b_c_Equal(val1.c, val2.c);

	return ret;

end NestedSeq_a_b_Equal;

function NestedSeq_a_Equal(val1, val2: in NestedSeq_a)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := NestedSeq_a_b_Equal(val1.b, val2.b);

	return ret;

end NestedSeq_a_Equal;

function NestedSeq_Equal(val1, val2: in NestedSeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := NestedSeq_a_Equal(val1.a, val2.a);

	return ret;

end NestedSeq_Equal;

function NestedSeq_a_b_c_Init return NestedSeq_a_b_c
is
    val: NestedSeq_a_b_c;
begin

    --set d 
    val.d := Integer_Init;
    return val;
end NestedSeq_a_b_c_Init;
function NestedSeq_a_b_Init return NestedSeq_a_b
is
    val: NestedSeq_a_b;
begin

    --set c 
    val.c := NestedSeq_a_b_c_Init;
    return val;
end NestedSeq_a_b_Init;
function NestedSeq_a_Init return NestedSeq_a
is
    val: NestedSeq_a;
begin

    --set b 
    val.b := NestedSeq_a_b_Init;
    return val;
end NestedSeq_a_Init;
function NestedSeq_Init return NestedSeq
is
    val: NestedSeq;
begin

    --set a 
    val.a := NestedSeq_a_Init;
    return val;
end NestedSeq_Init;

FUNCTION NestedSeq_IsConstraintValid(val : in NestedSeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_NESTEDSEQ_A_B_C_D);
    RETURN ret;
END NestedSeq_IsConstraintValid;



function Real_Equal(val1, val2: in Real)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end Real_Equal;

function Real_Init return Real
is
    val: Real;
begin
    val := 0.00000000000000000000E+000;
    return val;
end Real_Init;

FUNCTION Real_IsConstraintValid(val : in Real) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val) AND (val <= 1.00000000000000000000E+308)), ErrorCode => ERR_REAL);
    RETURN ret;
END Real_IsConstraintValid;



function CharString_Equal(val1, val2: in CharString)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end CharString_Equal;

function CharString_Init return CharString
is
    val: CharString;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 100;
    return val;
end CharString_Init;

FUNCTION CharString_IsConstraintValid(val : in CharString) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_CHARSTRING);
    RETURN ret;
END CharString_IsConstraintValid;



function Seq_Equal(val1, val2: in Seq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.i = val2.i);

    if ret then
        ret := (val1.b = val2.b);

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.f, val2.f));

            if ret then
                ret := CharString_Equal(val1.s, val2.s);

            end if;
        end if;
    end if;
	return ret;

end Seq_Equal;

function Seq_Init return Seq
is
    val: Seq;
begin

    --set i 
    val.i := Integer_Init;
    --set b 
    val.b := Boolean_Init;
    --set f 
    val.f := Real_Init;
    --set s 
    val.s := CharString_Init;
    return val;
end Seq_Init;

FUNCTION Seq_IsConstraintValid(val : in Seq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQ_I);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQ_B);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val.f) AND (val.f <= 1.00000000000000000000E+308)), ErrorCode => ERR_SEQ_F);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.s.Length) AND (val.s.Length <= 100)), ErrorCode => ERR_SEQ_S);
            end if;

        end if;

    end if;

    RETURN ret;
END Seq_IsConstraintValid;


 

END TASTE_Dataview;