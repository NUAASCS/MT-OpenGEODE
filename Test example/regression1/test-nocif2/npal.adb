-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH Seds;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsBoolean;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint8;
use type Seds.SedsUint32;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint32;
use type Seds.SedsValidityFlag;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint8;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsBoolean;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint8;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint32;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsBoolean;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint16;
use type Seds.SedsUint8;
use type Seds.SedsUint8;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY Npal with SPARK_Mode IS




function NpalTenBitPixel_Equal(val1, val2: in NpalTenBitPixel)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPixel = val2.fldPixel);

	return ret;

end NpalTenBitPixel_Equal;

function NpalTenBitPixel_Init return NpalTenBitPixel
is
    val: NpalTenBitPixel;
begin

    --set fldPixel 
    val.fldPixel := Seds.SedsUint16_Init;
    return val;
end NpalTenBitPixel_Init;

FUNCTION NpalTenBitPixel_IsConstraintValid(val : in NpalTenBitPixel) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixel <= 65535), ErrorCode => ERR_NPALTENBITPIXEL_FLDPIXEL);
    RETURN ret;
END NpalTenBitPixel_IsConstraintValid;



function NpalTmImage10_fldPixelData_Equal(val1, val2: in NpalTmImage10_fldPixelData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 512 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := NpalTenBitPixel_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end NpalTmImage10_fldPixelData_Equal;

function NpalTmImage10_Equal(val1, val2: in NpalTmImage10)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPacketNumber = val2.fldPacketNumber);

    if ret then
        ret := (val1.fldPixelNumber = val2.fldPixelNumber);

        if ret then
            ret := NpalTmImage10_fldPixelData_Equal(val1.fldPixelData, val2.fldPixelData);

        end if;
    end if;
	return ret;

end NpalTmImage10_Equal;

function NpalTmImage10_fldPixelData_Init return NpalTmImage10_fldPixelData
is
    val: NpalTmImage10_fldPixelData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 512 loop
        pragma Loop_Invariant (i1 >=1 and i1<=512);
        val.Data(i1) := NpalTenBitPixel_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end NpalTmImage10_fldPixelData_Init;
function NpalTmImage10_Init return NpalTmImage10
is
    val: NpalTmImage10;
begin

    --set fldPacketNumber 
    val.fldPacketNumber := Seds.SedsUint16_Init;
    --set fldPixelNumber 
    val.fldPixelNumber := Seds.SedsUint16_Init;
    --set fldPixelData 
    val.fldPixelData := NpalTmImage10_fldPixelData_Init;
    return val;
end NpalTmImage10_Init;

FUNCTION NpalTmImage10_IsConstraintValid(val : in NpalTmImage10) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE10_FLDPACKETNUMBER);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE10_FLDPIXELNUMBER);
        if ret.Success then
            i1 := val.fldPixelData.Data'First;
            while ret.Success and i1 <= 512 loop
                pragma Loop_Invariant (i1 >= val.fldPixelData.Data'First and i1 <= 512);
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelData.Data(i1).fldPixel <= 65535), ErrorCode => ERR_NPALTMIMAGE10_FLDPIXELDATA_ELM_FLDPIXEL);
                i1 := i1+1;
            end loop;

        end if;

    end if;

    RETURN ret;
END NpalTmImage10_IsConstraintValid;



function NpalTmHorizon_Equal(val1, val2: in NpalTmHorizon)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldBorderPolarAngle = val2.fldBorderPolarAngle);

    if ret then
        ret := (val1.fldBorderDistance = val2.fldBorderDistance);

        if ret then
            ret := (val1.fldRadius = val2.fldRadius);

        end if;
    end if;
	return ret;

end NpalTmHorizon_Equal;

function NpalTmHorizon_Init return NpalTmHorizon
is
    val: NpalTmHorizon;
begin

    --set fldBorderPolarAngle 
    val.fldBorderPolarAngle := Seds.SedsUint16_Init;
    --set fldBorderDistance 
    val.fldBorderDistance := Seds.SedsUint16_Init;
    --set fldRadius 
    val.fldRadius := Seds.SedsUint16_Init;
    return val;
end NpalTmHorizon_Init;

FUNCTION NpalTmHorizon_IsConstraintValid(val : in NpalTmHorizon) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldBorderPolarAngle <= 65535), ErrorCode => ERR_NPALTMHORIZON_FLDBORDERPOLARANGLE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldBorderDistance <= 65535), ErrorCode => ERR_NPALTMHORIZON_FLDBORDERDISTANCE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldRadius <= 65535), ErrorCode => ERR_NPALTMHORIZON_FLDRADIUS);
        end if;

    end if;

    RETURN ret;
END NpalTmHorizon_IsConstraintValid;



function NpalTmImage1_fldPixelData_Equal(val1, val2: in NpalTmImage1_fldPixelData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 4096 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end NpalTmImage1_fldPixelData_Equal;

function NpalTmImage1_Equal(val1, val2: in NpalTmImage1)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPacketNumber = val2.fldPacketNumber);

    if ret then
        ret := (val1.fldPixelNumber = val2.fldPixelNumber);

        if ret then
            ret := NpalTmImage1_fldPixelData_Equal(val1.fldPixelData, val2.fldPixelData);

        end if;
    end if;
	return ret;

end NpalTmImage1_Equal;

function NpalTmImage1_fldPixelData_Init return NpalTmImage1_fldPixelData
is
    val: NpalTmImage1_fldPixelData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4096 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4096);
        val.Data(i1) := Seds.SedsBoolean_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end NpalTmImage1_fldPixelData_Init;
function NpalTmImage1_Init return NpalTmImage1
is
    val: NpalTmImage1;
begin

    --set fldPacketNumber 
    val.fldPacketNumber := Seds.SedsUint16_Init;
    --set fldPixelNumber 
    val.fldPixelNumber := Seds.SedsUint16_Init;
    --set fldPixelData 
    val.fldPixelData := NpalTmImage1_fldPixelData_Init;
    return val;
end NpalTmImage1_Init;

FUNCTION NpalTmImage1_IsConstraintValid(val : in NpalTmImage1) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE1_FLDPACKETNUMBER);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE1_FLDPIXELNUMBER);
        if ret.Success then
            i1 := val.fldPixelData.Data'First;
            while ret.Success and i1 <= 4096 loop
                pragma Loop_Invariant (i1 >= val.fldPixelData.Data'First and i1 <= 4096);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_NPALTMIMAGE1_FLDPIXELDATA_ELM);
                i1 := i1+1;
            end loop;

        end if;

    end if;

    RETURN ret;
END NpalTmImage1_IsConstraintValid;



function NpalTmChecksum_Equal(val1, val2: in NpalTmChecksum)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldStartAddress = val2.fldStartAddress);

    if ret then
        ret := (val1.fldEndAddress = val2.fldEndAddress);

        if ret then
            ret := (val1.fldChecksumResult = val2.fldChecksumResult);

        end if;
    end if;
	return ret;

end NpalTmChecksum_Equal;

function NpalTmChecksum_Init return NpalTmChecksum
is
    val: NpalTmChecksum;
begin

    --set fldStartAddress 
    val.fldStartAddress := Seds.SedsUint32_Init;
    --set fldEndAddress 
    val.fldEndAddress := Seds.SedsUint32_Init;
    --set fldChecksumResult 
    val.fldChecksumResult := Seds.SedsUint32_Init;
    return val;
end NpalTmChecksum_Init;

FUNCTION NpalTmChecksum_IsConstraintValid(val : in NpalTmChecksum) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldStartAddress <= 4294967295), ErrorCode => ERR_NPALTMCHECKSUM_FLDSTARTADDRESS);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldEndAddress <= 4294967295), ErrorCode => ERR_NPALTMCHECKSUM_FLDENDADDRESS);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldChecksumResult <= 4294967295), ErrorCode => ERR_NPALTMCHECKSUM_FLDCHECKSUMRESULT);
        end if;

    end if;

    RETURN ret;
END NpalTmChecksum_IsConstraintValid;



function NpalTmDwndata_Equal(val1, val2: in NpalTmDwndata)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldStartAddress = val2.fldStartAddress);

    if ret then
        ret := (val1.fldEndAddress = val2.fldEndAddress);

        if ret then
            ret := (val1.fldWords = val2.fldWords);

        end if;
    end if;
	return ret;

end NpalTmDwndata_Equal;

function NpalTmDwndata_Init return NpalTmDwndata
is
    val: NpalTmDwndata;
begin

    --set fldStartAddress 
    val.fldStartAddress := Seds.SedsUint32_Init;
    --set fldEndAddress 
    val.fldEndAddress := Seds.SedsUint32_Init;
    --set fldWords 
    val.fldWords := Seds.SedsUint32_Init;
    return val;
end NpalTmDwndata_Init;

FUNCTION NpalTmDwndata_IsConstraintValid(val : in NpalTmDwndata) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldStartAddress <= 4294967295), ErrorCode => ERR_NPALTMDWNDATA_FLDSTARTADDRESS);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldEndAddress <= 4294967295), ErrorCode => ERR_NPALTMDWNDATA_FLDENDADDRESS);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldWords <= 4294967295), ErrorCode => ERR_NPALTMDWNDATA_FLDWORDS);
        end if;

    end if;

    RETURN ret;
END NpalTmDwndata_IsConstraintValid;



function NpalTmDeflist_Equal(val1, val2: in NpalTmDeflist)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPixelNumber = val2.fldPixelNumber);

    if ret then
        ret := (val1.fldPixelData = val2.fldPixelData);

    end if;
	return ret;

end NpalTmDeflist_Equal;

function NpalTmDeflist_Init return NpalTmDeflist
is
    val: NpalTmDeflist;
begin

    --set fldPixelNumber 
    val.fldPixelNumber := Seds.SedsUint8_Init;
    --set fldPixelData 
    val.fldPixelData := Seds.SedsUint32_Init;
    return val;
end NpalTmDeflist_Init;

FUNCTION NpalTmDeflist_IsConstraintValid(val : in NpalTmDeflist) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelNumber <= 255), ErrorCode => ERR_NPALTMDEFLIST_FLDPIXELNUMBER);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelData <= 4294967295), ErrorCode => ERR_NPALTMDEFLIST_FLDPIXELDATA);
    end if;

    RETURN ret;
END NpalTmDeflist_IsConstraintValid;



function NpalTmImage4_Equal(val1, val2: in NpalTmImage4)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPacketNumber = val2.fldPacketNumber);

    if ret then
        ret := (val1.fldPixelNumber = val2.fldPixelNumber);

        if ret then
            ret := (val1.fldPixelData = val2.fldPixelData);

        end if;
    end if;
	return ret;

end NpalTmImage4_Equal;

function NpalTmImage4_Init return NpalTmImage4
is
    val: NpalTmImage4;
begin

    --set fldPacketNumber 
    val.fldPacketNumber := Seds.SedsUint16_Init;
    --set fldPixelNumber 
    val.fldPixelNumber := Seds.SedsUint16_Init;
    --set fldPixelData 
    val.fldPixelData := Seds.SedsUint8_Init;
    return val;
end NpalTmImage4_Init;

FUNCTION NpalTmImage4_IsConstraintValid(val : in NpalTmImage4) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE4_FLDPACKETNUMBER);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE4_FLDPIXELNUMBER);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelData <= 255), ErrorCode => ERR_NPALTMIMAGE4_FLDPIXELDATA);
        end if;

    end if;

    RETURN ret;
END NpalTmImage4_IsConstraintValid;



function NpalStarData_Equal(val1, val2: in NpalStarData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldXCoordinate = val2.fldXCoordinate);

    if ret then
        ret := (val1.fldYCoordinate = val2.fldYCoordinate);

        if ret then
            ret := (val1.fldDimension = val2.fldDimension);

        end if;
    end if;
	return ret;

end NpalStarData_Equal;

function NpalStarData_Init return NpalStarData
is
    val: NpalStarData;
begin

    --set fldXCoordinate 
    val.fldXCoordinate := Seds.SedsUint16_Init;
    --set fldYCoordinate 
    val.fldYCoordinate := Seds.SedsUint16_Init;
    --set fldDimension 
    val.fldDimension := Seds.SedsUint8_Init;
    return val;
end NpalStarData_Init;

FUNCTION NpalStarData_IsConstraintValid(val : in NpalStarData) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldXCoordinate <= 65535), ErrorCode => ERR_NPALSTARDATA_FLDXCOORDINATE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldYCoordinate <= 65535), ErrorCode => ERR_NPALSTARDATA_FLDYCOORDINATE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldDimension <= 255), ErrorCode => ERR_NPALSTARDATA_FLDDIMENSION);
        end if;

    end if;

    RETURN ret;
END NpalStarData_IsConstraintValid;



function NpalTmStars_fldStars_Equal(val1, val2: in NpalTmStars_fldStars)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := NpalStarData_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end NpalTmStars_fldStars_Equal;

function NpalTmStars_Equal(val1, val2: in NpalTmStars)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldNumberOfStars = val2.fldNumberOfStars);

    if ret then
        ret := NpalTmStars_fldStars_Equal(val1.fldStars, val2.fldStars);

    end if;
	return ret;

end NpalTmStars_Equal;

function NpalTmStars_fldStars_Init return NpalTmStars_fldStars
is
    val: NpalTmStars_fldStars;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 16 loop
        pragma Loop_Invariant (i1 >=1 and i1<=16);
        val.Data(i1) := NpalStarData_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end NpalTmStars_fldStars_Init;
function NpalTmStars_Init return NpalTmStars
is
    val: NpalTmStars;
begin

    --set fldNumberOfStars 
    val.fldNumberOfStars := Seds.SedsUint8_Init;
    --set fldStars 
    val.fldStars := NpalTmStars_fldStars_Init;
    return val;
end NpalTmStars_Init;

FUNCTION NpalTmStars_IsConstraintValid(val : in NpalTmStars) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldNumberOfStars <= 255), ErrorCode => ERR_NPALTMSTARS_FLDNUMBEROFSTARS);
    if ret.Success then
        i1 := val.fldStars.Data'First;
        while ret.Success and i1 <= 16 loop
            pragma Loop_Invariant (i1 >= val.fldStars.Data'First and i1 <= 16);
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldStars.Data(i1).fldXCoordinate <= 65535), ErrorCode => ERR_NPALTMSTARS_FLDSTARS_ELM_FLDXCOORDINATE);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldStars.Data(i1).fldYCoordinate <= 65535), ErrorCode => ERR_NPALTMSTARS_FLDSTARS_ELM_FLDYCOORDINATE);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldStars.Data(i1).fldDimension <= 255), ErrorCode => ERR_NPALTMSTARS_FLDSTARS_ELM_FLDDIMENSION);
                end if;

            end if;

            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END NpalTmStars_IsConstraintValid;



function NpalTmImage2_Equal(val1, val2: in NpalTmImage2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPacketNumber = val2.fldPacketNumber);

    if ret then
        ret := (val1.fldPixelNumber = val2.fldPixelNumber);

        if ret then
            ret := (val1.fldPixelData = val2.fldPixelData);

        end if;
    end if;
	return ret;

end NpalTmImage2_Equal;

function NpalTmImage2_Init return NpalTmImage2
is
    val: NpalTmImage2;
begin

    --set fldPacketNumber 
    val.fldPacketNumber := Seds.SedsUint16_Init;
    --set fldPixelNumber 
    val.fldPixelNumber := Seds.SedsUint16_Init;
    --set fldPixelData 
    val.fldPixelData := Seds.SedsUint8_Init;
    return val;
end NpalTmImage2_Init;

FUNCTION NpalTmImage2_IsConstraintValid(val : in NpalTmImage2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE2_FLDPACKETNUMBER);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE2_FLDPIXELNUMBER);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelData <= 255), ErrorCode => ERR_NPALTMIMAGE2_FLDPIXELDATA);
        end if;

    end if;

    RETURN ret;
END NpalTmImage2_IsConstraintValid;



function NpalTmChkdata_Equal(val1, val2: in NpalTmChkdata)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldLastReset = val2.fldLastReset);

    if ret then
        ret := (val1.fldPromSwRelease = val2.fldPromSwRelease);

        if ret then
            ret := (val1.fldRamFaults = val2.fldRamFaults);

            if ret then
                ret := (val1.fldFirstErrorAddress = val2.fldFirstErrorAddress);

                if ret then
                    ret := (val1.fldPromChecksum = val2.fldPromChecksum);

                    if ret then
                        ret := (val1.fldEepromChecksum = val2.fldEepromChecksum);

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end NpalTmChkdata_Equal;

function NpalTmChkdata_Init return NpalTmChkdata
is
    val: NpalTmChkdata;
begin

    --set fldLastReset 
    val.fldLastReset := Seds.SedsUint8_Init;
    --set fldPromSwRelease 
    val.fldPromSwRelease := Seds.SedsUint16_Init;
    --set fldRamFaults 
    val.fldRamFaults := Seds.SedsUint16_Init;
    --set fldFirstErrorAddress 
    val.fldFirstErrorAddress := Seds.SedsUint32_Init;
    --set fldPromChecksum 
    val.fldPromChecksum := Seds.SedsUint32_Init;
    --set fldEepromChecksum 
    val.fldEepromChecksum := Seds.SedsUint32_Init;
    return val;
end NpalTmChkdata_Init;

FUNCTION NpalTmChkdata_IsConstraintValid(val : in NpalTmChkdata) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldLastReset <= 255), ErrorCode => ERR_NPALTMCHKDATA_FLDLASTRESET);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPromSwRelease <= 65535), ErrorCode => ERR_NPALTMCHKDATA_FLDPROMSWRELEASE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldRamFaults <= 65535), ErrorCode => ERR_NPALTMCHKDATA_FLDRAMFAULTS);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldFirstErrorAddress <= 4294967295), ErrorCode => ERR_NPALTMCHKDATA_FLDFIRSTERRORADDRESS);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPromChecksum <= 4294967295), ErrorCode => ERR_NPALTMCHKDATA_FLDPROMCHECKSUM);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldEepromChecksum <= 4294967295), ErrorCode => ERR_NPALTMCHKDATA_FLDEEPROMCHECKSUM);
                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END NpalTmChkdata_IsConstraintValid;



function NpalTmImage8_fldPixelData_Equal(val1, val2: in NpalTmImage8_fldPixelData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 512 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end NpalTmImage8_fldPixelData_Equal;

function NpalTmImage8_Equal(val1, val2: in NpalTmImage8)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPacketNumber = val2.fldPacketNumber);

    if ret then
        ret := (val1.fldPixelNumber = val2.fldPixelNumber);

        if ret then
            ret := NpalTmImage8_fldPixelData_Equal(val1.fldPixelData, val2.fldPixelData);

        end if;
    end if;
	return ret;

end NpalTmImage8_Equal;

function NpalTmImage8_fldPixelData_Init return NpalTmImage8_fldPixelData
is
    val: NpalTmImage8_fldPixelData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 512 loop
        pragma Loop_Invariant (i1 >=1 and i1<=512);
        val.Data(i1) := Seds.SedsUint8_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end NpalTmImage8_fldPixelData_Init;
function NpalTmImage8_Init return NpalTmImage8
is
    val: NpalTmImage8;
begin

    --set fldPacketNumber 
    val.fldPacketNumber := Seds.SedsUint16_Init;
    --set fldPixelNumber 
    val.fldPixelNumber := Seds.SedsUint16_Init;
    --set fldPixelData 
    val.fldPixelData := NpalTmImage8_fldPixelData_Init;
    return val;
end NpalTmImage8_Init;

FUNCTION NpalTmImage8_IsConstraintValid(val : in NpalTmImage8) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE8_FLDPACKETNUMBER);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMIMAGE8_FLDPIXELNUMBER);
        if ret.Success then
            i1 := val.fldPixelData.Data'First;
            while ret.Success and i1 <= 512 loop
                pragma Loop_Invariant (i1 >= val.fldPixelData.Data'First and i1 <= 512);
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixelData.Data(i1) <= 255), ErrorCode => ERR_NPALTMIMAGE8_FLDPIXELDATA_ELM);
                i1 := i1+1;
            end loop;

        end if;

    end if;

    RETURN ret;
END NpalTmImage8_IsConstraintValid;



function NpalPixel_Equal(val1, val2: in NpalPixel)
    return Boolean 
is
begin
	return val1 = val2;

end NpalPixel_Equal;

function NpalPixel_Init return NpalPixel
is
    val: NpalPixel;
begin
    val := 0;
    return val;
end NpalPixel_Init;

FUNCTION NpalPixel_IsConstraintValid(val : in NpalPixel) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_NPALPIXEL);
    RETURN ret;
END NpalPixel_IsConstraintValid;



function NpalCameraImage_fldNumberOfRows_Equal(val1, val2: in NpalCameraImage_fldNumberOfRows)
    return Boolean 
is
begin
	return val1 = val2;

end NpalCameraImage_fldNumberOfRows_Equal;

function NpalCameraImage_fldNumberOfPixels_Equal(val1, val2: in NpalCameraImage_fldNumberOfPixels)
    return Boolean 
is
begin
	return val1 = val2;

end NpalCameraImage_fldNumberOfPixels_Equal;

function NpalCameraImage_fldPixels_Equal(val1, val2: in NpalCameraImage_fldPixels)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end NpalCameraImage_fldPixels_Equal;

function NpalCameraImage_Equal(val1, val2: in NpalCameraImage)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := NpalCameraImage_fldNumberOfRows_Equal(val1.fldNumberOfRows, val2.fldNumberOfRows);

    if ret then
        ret := NpalCameraImage_fldNumberOfPixels_Equal(val1.fldNumberOfPixels, val2.fldNumberOfPixels);

        if ret then
            ret := NpalCameraImage_fldPixels_Equal(val1.fldPixels, val2.fldPixels);

            if ret then
                ret := (val1.fldImageValid = val2.fldImageValid);

            end if;
        end if;
    end if;
	return ret;

end NpalCameraImage_Equal;

function NpalCameraImage_fldNumberOfRows_Init return NpalCameraImage_fldNumberOfRows
is
    val: NpalCameraImage_fldNumberOfRows;
begin
    val := 256;
    return val;
end NpalCameraImage_fldNumberOfRows_Init;
function NpalCameraImage_fldNumberOfPixels_Init return NpalCameraImage_fldNumberOfPixels
is
    val: NpalCameraImage_fldNumberOfPixels;
begin
    val := 65536;
    return val;
end NpalCameraImage_fldNumberOfPixels_Init;
function NpalCameraImage_fldPixels_Init return NpalCameraImage_fldPixels
is
    val: NpalCameraImage_fldPixels;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 1048576 loop
        pragma Loop_Invariant (i1 >=1 and i1<=1048576);
        val.Data(i1) := NpalPixel_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end NpalCameraImage_fldPixels_Init;
function NpalCameraImage_Init return NpalCameraImage
is
    val: NpalCameraImage;
begin

    --set fldNumberOfRows 
    val.fldNumberOfRows := NpalCameraImage_fldNumberOfRows_Init;
    --set fldNumberOfPixels 
    val.fldNumberOfPixels := NpalCameraImage_fldNumberOfPixels_Init;
    --set fldPixels 
    val.fldPixels := NpalCameraImage_fldPixels_Init;
    --set fldImageValid 
    val.fldImageValid := Seds.SedsValidityFlag_Init;
    return val;
end NpalCameraImage_Init;

FUNCTION NpalCameraImage_IsConstraintValid(val : in NpalCameraImage) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldNumberOfRows <= 65535) AND ((256 <= val.fldNumberOfRows) AND (val.fldNumberOfRows <= 1024)), ErrorCode => ERR_NPALCAMERAIMAGE_FLDNUMBEROFROWS);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldNumberOfPixels <= 4294967295) AND ((65536 <= val.fldNumberOfPixels) AND (val.fldNumberOfPixels <= 1048576)), ErrorCode => ERR_NPALCAMERAIMAGE_FLDNUMBEROFPIXELS);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.fldPixels.Length) AND (val.fldPixels.Length <= 1048576)), ErrorCode => ERR_NPALCAMERAIMAGE_FLDPIXELS);
            i1 := val.fldPixels.Data'First;
            while ret.Success and i1 <= val.fldPixels.Length loop
                pragma Loop_Invariant (i1 >= val.fldPixels.Data'First and i1 <= val.fldPixels.Length);
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPixels.Data(i1) <= 255), ErrorCode => ERR_NPALCAMERAIMAGE_FLDPIXELS_ELM);
                i1 := i1+1;
            end loop;

            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_NPALCAMERAIMAGE_FLDIMAGEVALID);
            end if;

        end if;

    end if;

    RETURN ret;
END NpalCameraImage_IsConstraintValid;



function NpalEventCode_Equal(val1, val2: in NpalEventCode)
    return Boolean 
is
begin
	return val1 = val2;

end NpalEventCode_Equal;

function NpalEventCode_Init return NpalEventCode
is
    val: NpalEventCode;
begin
    val := mode_transition;
    return val;
end NpalEventCode_Init;

FUNCTION NpalEventCode_IsConstraintValid(val : in NpalEventCode) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val = mode_transition)) OR ((val = error_occurrence)))) OR ((val = tc_received)))) OR ((val = download_event)))) OR ((val = deleted)))) OR ((val = calibration_event))), ErrorCode => ERR_NPALEVENTCODE);
    RETURN ret;
END NpalEventCode_IsConstraintValid;



function NpalFrameSize_Equal(val1, val2: in NpalFrameSize)
    return Boolean 
is
begin
	return val1 = val2;

end NpalFrameSize_Equal;

function NpalFrameSize_Init return NpalFrameSize
is
    val: NpalFrameSize;
begin
    val := half_frame;
    return val;
end NpalFrameSize_Init;

FUNCTION NpalFrameSize_IsConstraintValid(val : in NpalFrameSize) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = half_frame)) OR ((val = full_frame))), ErrorCode => ERR_NPALFRAMESIZE);
    RETURN ret;
END NpalFrameSize_IsConstraintValid;



function NpalResetLevel_Equal(val1, val2: in NpalResetLevel)
    return Boolean 
is
begin
	return val1 = val2;

end NpalResetLevel_Equal;

function NpalResetLevel_Init return NpalResetLevel
is
    val: NpalResetLevel;
begin
    val := level_0;
    return val;
end NpalResetLevel_Init;

FUNCTION NpalResetLevel_IsConstraintValid(val : in NpalResetLevel) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = level_0)) OR ((val = level_1))), ErrorCode => ERR_NPALRESETLEVEL);
    RETURN ret;
END NpalResetLevel_IsConstraintValid;



function NpalProgressStatus_Equal(val1, val2: in NpalProgressStatus)
    return Boolean 
is
begin
	return val1 = val2;

end NpalProgressStatus_Equal;

function NpalProgressStatus_Init return NpalProgressStatus
is
    val: NpalProgressStatus;
begin
    val := started;
    return val;
end NpalProgressStatus_Init;

FUNCTION NpalProgressStatus_IsConstraintValid(val : in NpalProgressStatus) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = started)) OR ((val = completed)))) OR ((val = aborted))), ErrorCode => ERR_NPALPROGRESSSTATUS);
    RETURN ret;
END NpalProgressStatus_IsConstraintValid;



function NpalTcReceived_Equal(val1, val2: in NpalTcReceived)
    return Boolean 
is
begin
	return val1 = val2;

end NpalTcReceived_Equal;

function NpalTcReceived_Init return NpalTcReceived
is
    val: NpalTcReceived;
begin
    val := accepted;
    return val;
end NpalTcReceived_Init;

FUNCTION NpalTcReceived_IsConstraintValid(val : in NpalTcReceived) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = accepted)) OR ((val = not_accepted))), ErrorCode => ERR_NPALTCRECEIVED);
    RETURN ret;
END NpalTcReceived_IsConstraintValid;



function NpalCalibrationType_Equal(val1, val2: in NpalCalibrationType)
    return Boolean 
is
begin
	return val1 = val2;

end NpalCalibrationType_Equal;

function NpalCalibrationType_Init return NpalCalibrationType
is
    val: NpalCalibrationType;
begin
    val := cold_pixel_calibration;
    return val;
end NpalCalibrationType_Init;

FUNCTION NpalCalibrationType_IsConstraintValid(val : in NpalCalibrationType) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = cold_pixel_calibration)) OR ((val = hot_pixel_calibration)))) OR ((val = save_calibration_data))), ErrorCode => ERR_NPALCALIBRATIONTYPE);
    RETURN ret;
END NpalCalibrationType_IsConstraintValid;



function NpalWindowSize_Equal(val1, val2: in NpalWindowSize)
    return Boolean 
is
begin
	return val1 = val2;

end NpalWindowSize_Equal;

function NpalWindowSize_Init return NpalWindowSize
is
    val: NpalWindowSize;
begin
    val := two_five_six_pixels;
    return val;
end NpalWindowSize_Init;

FUNCTION NpalWindowSize_IsConstraintValid(val : in NpalWindowSize) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((val = two_five_six_pixels)) OR ((val = five_one_two_pixels)))) OR ((val = seven_six_eight_pixels)))) OR ((val = one_zero_two_four_pixels))), ErrorCode => ERR_NPALWINDOWSIZE);
    RETURN ret;
END NpalWindowSize_IsConstraintValid;



function NpalOperatingMode_Equal(val1, val2: in NpalOperatingMode)
    return Boolean 
is
begin
	return val1 = val2;

end NpalOperatingMode_Equal;

function NpalOperatingMode_Init return NpalOperatingMode
is
    val: NpalOperatingMode;
begin
    val := ini;
    return val;
end NpalOperatingMode_Init;

FUNCTION NpalOperatingMode_IsConstraintValid(val : in NpalOperatingMode) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val = ini)) OR ((val = swm)))) OR ((val = stb)))) OR ((val = trk)))) OR ((val = img)))) OR ((val = trk_hibernated))), ErrorCode => ERR_NPALOPERATINGMODE);
    RETURN ret;
END NpalOperatingMode_IsConstraintValid;



function NpalSettableParameterCode_Equal(val1, val2: in NpalSettableParameterCode)
    return Boolean 
is
begin
	return val1 = val2;

end NpalSettableParameterCode_Equal;

function NpalSettableParameterCode_Init return NpalSettableParameterCode
is
    val: NpalSettableParameterCode;
begin
    val := restore_default_values;
    return val;
end NpalSettableParameterCode_Init;

FUNCTION NpalSettableParameterCode_IsConstraintValid(val : in NpalSettableParameterCode) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val = restore_default_values)) OR ((val = defective_pixels_low_threshold)))) OR ((val = defective_pixels_high_threshold)))) OR ((val = number_of_cycles_for_defective_pixels_update)))) OR ((val = camera_status_tm_update_rate))), ErrorCode => ERR_NPALSETTABLEPARAMETERCODE);
    RETURN ret;
END NpalSettableParameterCode_IsConstraintValid;



function NpalCyclePrescalar_Equal(val1, val2: in NpalCyclePrescalar)
    return Boolean 
is
begin
	return val1 = val2;

end NpalCyclePrescalar_Equal;

function NpalCyclePrescalar_Init return NpalCyclePrescalar
is
    val: NpalCyclePrescalar;
begin
    val := base_cycle_duration_1x;
    return val;
end NpalCyclePrescalar_Init;

FUNCTION NpalCyclePrescalar_IsConstraintValid(val : in NpalCyclePrescalar) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val = base_cycle_duration_1x)) OR ((val = base_cycle_duration_2x)))) OR ((val = base_cycle_duration_4x)))) OR ((val = base_cycle_duration_8x)))) OR ((val = base_cycle_duration_16x)))) OR ((val = base_cycle_duration_32x))), ErrorCode => ERR_NPALCYCLEPRESCALAR);
    RETURN ret;
END NpalCyclePrescalar_IsConstraintValid;



function NpalTmStatus_Equal(val1, val2: in NpalTmStatus)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldOperatingMode = val2.fldOperatingMode);

    if ret then
        ret := (val1.fldExposureTime = val2.fldExposureTime);

        if ret then
            ret := (val1.fldApsTemperature = val2.fldApsTemperature);

            if ret then
                ret := (val1.fldOpticsTemperature = val2.fldOpticsTemperature);

                if ret then
                    ret := (val1.fldInputVoltage = val2.fldInputVoltage);

                    if ret then
                        ret := (val1.fldHealthCheck = val2.fldHealthCheck);

                        if ret then
                            ret := (val1.fldLinkSpeed = val2.fldLinkSpeed);

                            if ret then
                                ret := (val1.fldCycleOptionFrameSize = val2.fldCycleOptionFrameSize);

                                if ret then
                                    ret := (val1.fldCycleOptionPrescalar = val2.fldCycleOptionPrescalar);

                                    if ret then
                                        ret := (val1.fldDefectivePixelLowThreshold = val2.fldDefectivePixelLowThreshold);

                                        if ret then
                                            ret := (val1.fldDefectivePixelHighThreshold = val2.fldDefectivePixelHighThreshold);

                                            if ret then
                                                ret := (val1.fldNumCyclesForDefectDetection = val2.fldNumCyclesForDefectDetection);

                                                if ret then
                                                    ret := (val1.fldCameraStatusRate = val2.fldCameraStatusRate);

                                                    if ret then
                                                        ret := (val1.fldSwRevisionNumber = val2.fldSwRevisionNumber);

                                                        if ret then
                                                            ret := (val1.fldSwIssueNumber = val2.fldSwIssueNumber);

                                                        end if;
                                                    end if;
                                                end if;
                                            end if;
                                        end if;
                                    end if;
                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end NpalTmStatus_Equal;

function NpalTmStatus_Init return NpalTmStatus
is
    val: NpalTmStatus;
begin

    --set fldOperatingMode 
    val.fldOperatingMode := NpalOperatingMode_Init;
    --set fldExposureTime 
    val.fldExposureTime := Seds.SedsUint16_Init;
    --set fldApsTemperature 
    val.fldApsTemperature := Seds.SedsUint8_Init;
    --set fldOpticsTemperature 
    val.fldOpticsTemperature := Seds.SedsUint8_Init;
    --set fldInputVoltage 
    val.fldInputVoltage := Seds.SedsUint8_Init;
    --set fldHealthCheck 
    val.fldHealthCheck := Seds.SedsUint8_Init;
    --set fldLinkSpeed 
    val.fldLinkSpeed := Seds.SedsUint8_Init;
    --set fldCycleOptionFrameSize 
    val.fldCycleOptionFrameSize := NpalFrameSize_Init;
    --set fldCycleOptionPrescalar 
    val.fldCycleOptionPrescalar := NpalCyclePrescalar_Init;
    --set fldDefectivePixelLowThreshold 
    val.fldDefectivePixelLowThreshold := Seds.SedsUint16_Init;
    --set fldDefectivePixelHighThreshold 
    val.fldDefectivePixelHighThreshold := Seds.SedsUint16_Init;
    --set fldNumCyclesForDefectDetection 
    val.fldNumCyclesForDefectDetection := Seds.SedsUint16_Init;
    --set fldCameraStatusRate 
    val.fldCameraStatusRate := Seds.SedsUint16_Init;
    --set fldSwRevisionNumber 
    val.fldSwRevisionNumber := Seds.SedsUint8_Init;
    --set fldSwIssueNumber 
    val.fldSwIssueNumber := Seds.SedsUint8_Init;
    return val;
end NpalTmStatus_Init;

FUNCTION NpalTmStatus_IsConstraintValid(val : in NpalTmStatus) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldOperatingMode = ini)) OR ((val.fldOperatingMode = swm)))) OR ((val.fldOperatingMode = stb)))) OR ((val.fldOperatingMode = trk)))) OR ((val.fldOperatingMode = img)))) OR ((val.fldOperatingMode = trk_hibernated))), ErrorCode => ERR_NPALTMSTATUS_FLDOPERATINGMODE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldExposureTime <= 65535), ErrorCode => ERR_NPALTMSTATUS_FLDEXPOSURETIME);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldApsTemperature <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDAPSTEMPERATURE);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldOpticsTemperature <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDOPTICSTEMPERATURE);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldInputVoltage <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDINPUTVOLTAGE);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldHealthCheck <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDHEALTHCHECK);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldLinkSpeed <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDLINKSPEED);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.fldCycleOptionFrameSize = half_frame)) OR ((val.fldCycleOptionFrameSize = full_frame))), ErrorCode => ERR_NPALTMSTATUS_FLDCYCLEOPTIONFRAMESIZE);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldCycleOptionPrescalar = base_cycle_duration_1x)) OR ((val.fldCycleOptionPrescalar = base_cycle_duration_2x)))) OR ((val.fldCycleOptionPrescalar = base_cycle_duration_4x)))) OR ((val.fldCycleOptionPrescalar = base_cycle_duration_8x)))) OR ((val.fldCycleOptionPrescalar = base_cycle_duration_16x)))) OR ((val.fldCycleOptionPrescalar = base_cycle_duration_32x))), ErrorCode => ERR_NPALTMSTATUS_FLDCYCLEOPTIONPRESCALAR);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldDefectivePixelLowThreshold <= 65535), ErrorCode => ERR_NPALTMSTATUS_FLDDEFECTIVEPIXELLOWTHRESHOLD);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldDefectivePixelHighThreshold <= 65535), ErrorCode => ERR_NPALTMSTATUS_FLDDEFECTIVEPIXELHIGHTHRESHOLD);
                                            if ret.Success then
                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldNumCyclesForDefectDetection <= 65535), ErrorCode => ERR_NPALTMSTATUS_FLDNUMCYCLESFORDEFECTDETECTION);
                                                if ret.Success then
                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldCameraStatusRate <= 65535), ErrorCode => ERR_NPALTMSTATUS_FLDCAMERASTATUSRATE);
                                                    if ret.Success then
                                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldSwRevisionNumber <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDSWREVISIONNUMBER);
                                                        if ret.Success then
                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldSwIssueNumber <= 255), ErrorCode => ERR_NPALTMSTATUS_FLDSWISSUENUMBER);
                                                        end if;

                                                    end if;

                                                end if;

                                            end if;

                                        end if;

                                    end if;

                                end if;

                            end if;

                        end if;

                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END NpalTmStatus_IsConstraintValid;



function NpalSwLoading_Equal(val1, val2: in NpalSwLoading)
    return Boolean 
is
begin
	return val1 = val2;

end NpalSwLoading_Equal;

function NpalSwLoading_Init return NpalSwLoading
is
    val: NpalSwLoading;
begin
    val := ram_loaded;
    return val;
end NpalSwLoading_Init;

FUNCTION NpalSwLoading_IsConstraintValid(val : in NpalSwLoading) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = ram_loaded)) OR ((val = no_ram_loading))), ErrorCode => ERR_NPALSWLOADING);
    RETURN ret;
END NpalSwLoading_IsConstraintValid;



function NpalTrackingOption_Equal(val1, val2: in NpalTrackingOption)
    return Boolean 
is
begin
	return val1 = val2;

end NpalTrackingOption_Equal;

function NpalTrackingOption_Init return NpalTrackingOption
is
    val: NpalTrackingOption;
begin
    val := normal_tracking_mode;
    return val;
end NpalTrackingOption_Init;

FUNCTION NpalTrackingOption_IsConstraintValid(val : in NpalTrackingOption) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = normal_tracking_mode)) OR ((val = hibernated_tracking_mode))), ErrorCode => ERR_NPALTRACKINGOPTION);
    RETURN ret;
END NpalTrackingOption_IsConstraintValid;



function NpalImageDynamicRange_Equal(val1, val2: in NpalImageDynamicRange)
    return Boolean 
is
begin
	return val1 = val2;

end NpalImageDynamicRange_Equal;

function NpalImageDynamicRange_Init return NpalImageDynamicRange
is
    val: NpalImageDynamicRange;
begin
    val := one_bit;
    return val;
end NpalImageDynamicRange_Init;

FUNCTION NpalImageDynamicRange_IsConstraintValid(val : in NpalImageDynamicRange) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val = one_bit)) OR ((val = two_bits)))) OR ((val = four_bits)))) OR ((val = eight_bits)))) OR ((val = ten_bits))), ErrorCode => ERR_NPALIMAGEDYNAMICRANGE);
    RETURN ret;
END NpalImageDynamicRange_IsConstraintValid;



function NpalErrorCode_Equal(val1, val2: in NpalErrorCode)
    return Boolean 
is
begin
	return val1 = val2;

end NpalErrorCode_Equal;

function NpalErrorCode_Init return NpalErrorCode
is
    val: NpalErrorCode;
begin
    val := tm_buffer_full;
    return val;
end NpalErrorCode_Init;

FUNCTION NpalErrorCode_IsConstraintValid(val : in NpalErrorCode) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val = tm_buffer_full), ErrorCode => ERR_NPALERRORCODE);
    RETURN ret;
END NpalErrorCode_IsConstraintValid;



function NpalModeTransitionCause_Equal(val1, val2: in NpalModeTransitionCause)
    return Boolean 
is
begin
	return val1 = val2;

end NpalModeTransitionCause_Equal;

function NpalModeTransitionCause_Init return NpalModeTransitionCause
is
    val: NpalModeTransitionCause;
begin
    val := transition_after_error_condition;
    return val;
end NpalModeTransitionCause_Init;

FUNCTION NpalModeTransitionCause_IsConstraintValid(val : in NpalModeTransitionCause) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = transition_after_error_condition)) OR ((val = automatic_transition_at_end_of_mode)))) OR ((val = transition_after_tc))), ErrorCode => ERR_NPALMODETRANSITIONCAUSE);
    RETURN ret;
END NpalModeTransitionCause_IsConstraintValid;



function NpalModeTransition_Equal(val1, val2: in NpalModeTransition)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldCause = val2.fldCause);

    if ret then
        ret := (val1.fldCurrentMode = val2.fldCurrentMode);

        if ret then
            ret := (val1.fldPreviousMode = val2.fldPreviousMode);

        end if;
    end if;
	return ret;

end NpalModeTransition_Equal;

function NpalModeTransition_Init return NpalModeTransition
is
    val: NpalModeTransition;
begin

    --set fldCause 
    val.fldCause := NpalModeTransitionCause_Init;
    --set fldCurrentMode 
    val.fldCurrentMode := NpalOperatingMode_Init;
    --set fldPreviousMode 
    val.fldPreviousMode := NpalOperatingMode_Init;
    return val;
end NpalModeTransition_Init;

FUNCTION NpalModeTransition_IsConstraintValid(val : in NpalModeTransition) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldCause = transition_after_error_condition)) OR ((val.fldCause = automatic_transition_at_end_of_mode)))) OR ((val.fldCause = transition_after_tc))), ErrorCode => ERR_NPALMODETRANSITION_FLDCAUSE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldCurrentMode = ini)) OR ((val.fldCurrentMode = swm)))) OR ((val.fldCurrentMode = stb)))) OR ((val.fldCurrentMode = trk)))) OR ((val.fldCurrentMode = img)))) OR ((val.fldCurrentMode = trk_hibernated))), ErrorCode => ERR_NPALMODETRANSITION_FLDCURRENTMODE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldPreviousMode = ini)) OR ((val.fldPreviousMode = swm)))) OR ((val.fldPreviousMode = stb)))) OR ((val.fldPreviousMode = trk)))) OR ((val.fldPreviousMode = img)))) OR ((val.fldPreviousMode = trk_hibernated))), ErrorCode => ERR_NPALMODETRANSITION_FLDPREVIOUSMODE);
        end if;

    end if;

    RETURN ret;
END NpalModeTransition_IsConstraintValid;



function NpalUpOrDown_Equal(val1, val2: in NpalUpOrDown)
    return Boolean 
is
begin
	return val1 = val2;

end NpalUpOrDown_Equal;

function NpalUpOrDown_Init return NpalUpOrDown
is
    val: NpalUpOrDown;
begin
    val := up;
    return val;
end NpalUpOrDown_Init;

FUNCTION NpalUpOrDown_IsConstraintValid(val : in NpalUpOrDown) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = up)) OR ((val = down))), ErrorCode => ERR_NPALUPORDOWN);
    RETURN ret;
END NpalUpOrDown_IsConstraintValid;



function NpalTmReportAckOk_Equal(val1, val2: in NpalTmReportAckOk)
    return Boolean 
is
begin
	return val1 = val2;

end NpalTmReportAckOk_Equal;

function NpalTmReportAckOk_Init return NpalTmReportAckOk
is
    val: NpalTmReportAckOk;
begin
    val := 0;
    return val;
end NpalTmReportAckOk_Init;

FUNCTION NpalTmReportAckOk_IsConstraintValid(val : in NpalTmReportAckOk) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val = 0), ErrorCode => ERR_NPALTMREPORTACKOK);
    RETURN ret;
END NpalTmReportAckOk_IsConstraintValid;



function NpalTmReportAckFail_Equal(val1, val2: in NpalTmReportAckFail)
    return Boolean 
is
begin
	return val1 = val2;

end NpalTmReportAckFail_Equal;

function NpalTmReportAckFail_Init return NpalTmReportAckFail
is
    val: NpalTmReportAckFail;
begin
    val := 0;
    return val;
end NpalTmReportAckFail_Init;

FUNCTION NpalTmReportAckFail_IsConstraintValid(val : in NpalTmReportAckFail) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val = 0), ErrorCode => ERR_NPALTMREPORTACKFAIL);
    RETURN ret;
END NpalTmReportAckFail_IsConstraintValid;



function NpalTmReportModeTrans_Equal(val1, val2: in NpalTmReportModeTrans)
    return Boolean 
is
begin
	return val1 = val2;

end NpalTmReportModeTrans_Equal;

function NpalTmReportModeTrans_Init return NpalTmReportModeTrans
is
    val: NpalTmReportModeTrans;
begin
    val := 0;
    return val;
end NpalTmReportModeTrans_Init;

FUNCTION NpalTmReportModeTrans_IsConstraintValid(val : in NpalTmReportModeTrans) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val = 0), ErrorCode => ERR_NPALTMREPORTMODETRANS);
    RETURN ret;
END NpalTmReportModeTrans_IsConstraintValid;



function NpalTmReport_BODY_CHOICE_Equal(val1, val2: in NpalTmReport_BODY_CHOICE)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when fldTmReportAckFail_PRESENT =>
                ret := (val1.fldTmReportAckFail = val2.fldTmReportAckFail);
            when fldTmReportAckOk_PRESENT =>
                ret := (val1.fldTmReportAckOk = val2.fldTmReportAckOk);
            when fldTmReportModeTrans_PRESENT =>
                ret := (val1.fldTmReportModeTrans = val2.fldTmReportModeTrans);
        end case;
    end if;
	return ret;

end NpalTmReport_BODY_CHOICE_Equal;

function NpalTmReport_BODY_CHOICE_Init return NpalTmReport_BODY_CHOICE
is
    val: NpalTmReport_BODY_CHOICE;
begin
    --set fldTmReportAckFail 
    declare
        fldTmReportAckFail_tmp:NpalTmReportAckFail;
    begin
        fldTmReportAckFail_tmp := NpalTmReportAckFail_Init;
        val := NpalTmReport_BODY_CHOICE'(kind => fldTmReportAckFail_PRESENT, fldTmReportAckFail => fldTmReportAckFail_tmp);
    end;
    return val;
end NpalTmReport_BODY_CHOICE_Init;

FUNCTION NpalTmReport_BODY_CHOICE_IsConstraintValid(val : in NpalTmReport_BODY_CHOICE) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN fldTmReportAckFail_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReportAckFail = 0), ErrorCode => ERR_NPALTMREPORT_BODY_CHOICE_FLDTMREPORTACKFAIL_2);
        WHEN fldTmReportAckOk_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReportAckOk = 0), ErrorCode => ERR_NPALTMREPORT_BODY_CHOICE_FLDTMREPORTACKOK_2);
        WHEN fldTmReportModeTrans_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReportModeTrans = 0), ErrorCode => ERR_NPALTMREPORT_BODY_CHOICE_FLDTMREPORTMODETRANS_2);
    end case;
    RETURN ret;
END NpalTmReport_BODY_CHOICE_IsConstraintValid;



function NpalTmReport_Equal(val1, val2: in NpalTmReport)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldEventCode = val2.fldEventCode);

    if ret then
        ret := (val1.fldTcAcceptance = val2.fldTcAcceptance);

        if ret then
            ret := NpalModeTransition_Equal(val1.fldModeTransitition, val2.fldModeTransitition);

            if ret then
                ret := (val1.fldDownloadStatus = val2.fldDownloadStatus);

                if ret then
                    ret := (val1.fldCalibration = val2.fldCalibration);

                    if ret then
                        ret := (val1.fldErrorCode = val2.fldErrorCode);

                        if ret then
                            ret := NpalTmReport_BODY_CHOICE_Equal(val1.body_choice, val2.body_choice);

                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end NpalTmReport_Equal;

function NpalTmReport_Init return NpalTmReport
is
    val: NpalTmReport;
begin

    --set fldEventCode 
    val.fldEventCode := NpalEventCode_Init;
    --set fldTcAcceptance 
    val.fldTcAcceptance := NpalTcReceived_Init;
    --set fldModeTransitition 
    val.fldModeTransitition := NpalModeTransition_Init;
    --set fldDownloadStatus 
    val.fldDownloadStatus := NpalProgressStatus_Init;
    --set fldCalibration 
    val.fldCalibration := NpalProgressStatus_Init;
    --set fldErrorCode 
    val.fldErrorCode := NpalErrorCode_Init;
    --set body_choice 
    val.body_choice := NpalTmReport_BODY_CHOICE_Init;
    return val;
end NpalTmReport_Init;

FUNCTION NpalTmReport_IsConstraintValid(val : in NpalTmReport) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldEventCode = mode_transition)) OR ((val.fldEventCode = error_occurrence)))) OR ((val.fldEventCode = tc_received)))) OR ((val.fldEventCode = download_event)))) OR ((val.fldEventCode = deleted)))) OR ((val.fldEventCode = calibration_event))), ErrorCode => ERR_NPALTMREPORT_FLDEVENTCODE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.fldTcAcceptance = accepted)) OR ((val.fldTcAcceptance = not_accepted))), ErrorCode => ERR_NPALTMREPORT_FLDTCACCEPTANCE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldModeTransitition.fldCause = transition_after_error_condition)) OR ((val.fldModeTransitition.fldCause = automatic_transition_at_end_of_mode)))) OR ((val.fldModeTransitition.fldCause = transition_after_tc))), ErrorCode => ERR_NPALTMREPORT_FLDMODETRANSITITION_FLDCAUSE);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldModeTransitition.fldCurrentMode = ini)) OR ((val.fldModeTransitition.fldCurrentMode = swm)))) OR ((val.fldModeTransitition.fldCurrentMode = stb)))) OR ((val.fldModeTransitition.fldCurrentMode = trk)))) OR ((val.fldModeTransitition.fldCurrentMode = img)))) OR ((val.fldModeTransitition.fldCurrentMode = trk_hibernated))), ErrorCode => ERR_NPALTMREPORT_FLDMODETRANSITITION_FLDCURRENTMODE);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldModeTransitition.fldPreviousMode = ini)) OR ((val.fldModeTransitition.fldPreviousMode = swm)))) OR ((val.fldModeTransitition.fldPreviousMode = stb)))) OR ((val.fldModeTransitition.fldPreviousMode = trk)))) OR ((val.fldModeTransitition.fldPreviousMode = img)))) OR ((val.fldModeTransitition.fldPreviousMode = trk_hibernated))), ErrorCode => ERR_NPALTMREPORT_FLDMODETRANSITITION_FLDPREVIOUSMODE);
                end if;

            end if;

            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldDownloadStatus = started)) OR ((val.fldDownloadStatus = completed)))) OR ((val.fldDownloadStatus = aborted))), ErrorCode => ERR_NPALTMREPORT_FLDDOWNLOADSTATUS);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldCalibration = started)) OR ((val.fldCalibration = completed)))) OR ((val.fldCalibration = aborted))), ErrorCode => ERR_NPALTMREPORT_FLDCALIBRATION);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldErrorCode = tm_buffer_full), ErrorCode => ERR_NPALTMREPORT_FLDERRORCODE);
                        if ret.Success then
                            case val.body_choice.kind is
                                WHEN fldTmReportAckFail_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReportAckFail = 0), ErrorCode => ERR_NPALTMREPORT_BODY_CHOICE_FLDTMREPORTACKFAIL);
                                WHEN fldTmReportAckOk_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReportAckOk = 0), ErrorCode => ERR_NPALTMREPORT_BODY_CHOICE_FLDTMREPORTACKOK);
                                WHEN fldTmReportModeTrans_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReportModeTrans = 0), ErrorCode => ERR_NPALTMREPORT_BODY_CHOICE_FLDTMREPORTMODETRANS);
                            end case;
                        end if;

                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END NpalTmReport_IsConstraintValid;



function NpalTmHeader_BODY_CHOICE_Equal(val1, val2: in NpalTmHeader_BODY_CHOICE)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when fldTmChecksum_PRESENT =>
                ret := NpalTmChecksum_Equal(val1.fldTmChecksum, val2.fldTmChecksum);
            when fldTmChkdata_PRESENT =>
                ret := NpalTmChkdata_Equal(val1.fldTmChkdata, val2.fldTmChkdata);
            when fldTmDeflist_PRESENT =>
                ret := NpalTmDeflist_Equal(val1.fldTmDeflist, val2.fldTmDeflist);
            when fldTmDwndata_PRESENT =>
                ret := NpalTmDwndata_Equal(val1.fldTmDwndata, val2.fldTmDwndata);
            when fldTmHorizon_PRESENT =>
                ret := NpalTmHorizon_Equal(val1.fldTmHorizon, val2.fldTmHorizon);
            when fldTmImage1_PRESENT =>
                ret := NpalTmImage1_Equal(val1.fldTmImage1, val2.fldTmImage1);
            when fldTmImage10_PRESENT =>
                ret := NpalTmImage10_Equal(val1.fldTmImage10, val2.fldTmImage10);
            when fldTmImage2_PRESENT =>
                ret := NpalTmImage2_Equal(val1.fldTmImage2, val2.fldTmImage2);
            when fldTmImage4_PRESENT =>
                ret := NpalTmImage4_Equal(val1.fldTmImage4, val2.fldTmImage4);
            when fldTmImage8_PRESENT =>
                ret := NpalTmImage8_Equal(val1.fldTmImage8, val2.fldTmImage8);
            when fldTmReport_PRESENT =>
                ret := NpalTmReport_Equal(val1.fldTmReport, val2.fldTmReport);
            when fldTmStars_PRESENT =>
                ret := NpalTmStars_Equal(val1.fldTmStars, val2.fldTmStars);
            when fldTmStatus_PRESENT =>
                ret := NpalTmStatus_Equal(val1.fldTmStatus, val2.fldTmStatus);
        end case;
    end if;
	return ret;

end NpalTmHeader_BODY_CHOICE_Equal;

function NpalTmHeader_BODY_CHOICE_Init return NpalTmHeader_BODY_CHOICE
is
    val: NpalTmHeader_BODY_CHOICE;
begin
    --set fldTmChecksum 
    declare
        fldTmChecksum_tmp:NpalTmChecksum;
    begin
        fldTmChecksum_tmp := NpalTmChecksum_Init;
        val := NpalTmHeader_BODY_CHOICE'(kind => fldTmChecksum_PRESENT, fldTmChecksum => fldTmChecksum_tmp);
    end;
    return val;
end NpalTmHeader_BODY_CHOICE_Init;

FUNCTION NpalTmHeader_BODY_CHOICE_IsConstraintValid(val : in NpalTmHeader_BODY_CHOICE) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    case val.kind is
        WHEN fldTmChecksum_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChecksum.fldStartAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHECKSUM_FLDSTARTADDRESS_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChecksum.fldEndAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHECKSUM_FLDENDADDRESS_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChecksum.fldChecksumResult <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHECKSUM_FLDCHECKSUMRESULT_2);
                end if;

            end if;

        WHEN fldTmChkdata_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChkdata.fldLastReset <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDLASTRESET_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChkdata.fldPromSwRelease <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDPROMSWRELEASE_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChkdata.fldRamFaults <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDRAMFAULTS_2);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChkdata.fldFirstErrorAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDFIRSTERRORADDRESS_2);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChkdata.fldPromChecksum <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDPROMCHECKSUM_2);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmChkdata.fldEepromChecksum <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDEEPROMCHECKSUM_2);
                            end if;

                        end if;

                    end if;

                end if;

            end if;

        WHEN fldTmDeflist_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmDeflist.fldPixelNumber <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDEFLIST_FLDPIXELNUMBER_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmDeflist.fldPixelData <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDEFLIST_FLDPIXELDATA_2);
            end if;

        WHEN fldTmDwndata_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmDwndata.fldStartAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDWNDATA_FLDSTARTADDRESS_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmDwndata.fldEndAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDWNDATA_FLDENDADDRESS_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmDwndata.fldWords <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDWNDATA_FLDWORDS_2);
                end if;

            end if;

        WHEN fldTmHorizon_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmHorizon.fldBorderPolarAngle <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMHORIZON_FLDBORDERPOLARANGLE_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmHorizon.fldBorderDistance <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMHORIZON_FLDBORDERDISTANCE_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmHorizon.fldRadius <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMHORIZON_FLDRADIUS_2);
                end if;

            end if;

        WHEN fldTmImage1_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage1.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE1_FLDPACKETNUMBER_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage1.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE1_FLDPIXELNUMBER_2);
                if ret.Success then
                    i1 := val.fldTmImage1.fldPixelData.Data'First;
                    while ret.Success and i1 <= 4096 loop
                        pragma Loop_Invariant (i1 >= val.fldTmImage1.fldPixelData.Data'First and i1 <= 4096);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE1_FLDPIXELDATA_ELM_2);
                        i1 := i1+1;
                    end loop;

                end if;

            end if;

        WHEN fldTmImage10_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage10.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE10_FLDPACKETNUMBER_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage10.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE10_FLDPIXELNUMBER_2);
                if ret.Success then
                    i1 := val.fldTmImage10.fldPixelData.Data'First;
                    while ret.Success and i1 <= 512 loop
                        pragma Loop_Invariant (i1 >= val.fldTmImage10.fldPixelData.Data'First and i1 <= 512);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage10.fldPixelData.Data(i1).fldPixel <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE10_FLDPIXELDATA_ELM_FLDPIXEL_2);
                        i1 := i1+1;
                    end loop;

                end if;

            end if;

        WHEN fldTmImage2_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage2.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE2_FLDPACKETNUMBER_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage2.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE2_FLDPIXELNUMBER_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage2.fldPixelData <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE2_FLDPIXELDATA_2);
                end if;

            end if;

        WHEN fldTmImage4_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage4.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE4_FLDPACKETNUMBER_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage4.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE4_FLDPIXELNUMBER_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage4.fldPixelData <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE4_FLDPIXELDATA_2);
                end if;

            end if;

        WHEN fldTmImage8_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage8.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE8_FLDPACKETNUMBER_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage8.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE8_FLDPIXELNUMBER_2);
                if ret.Success then
                    i1 := val.fldTmImage8.fldPixelData.Data'First;
                    while ret.Success and i1 <= 512 loop
                        pragma Loop_Invariant (i1 >= val.fldTmImage8.fldPixelData.Data'First and i1 <= 512);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmImage8.fldPixelData.Data(i1) <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE8_FLDPIXELDATA_ELM_2);
                        i1 := i1+1;
                    end loop;

                end if;

            end if;

        WHEN fldTmReport_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldTmReport.fldEventCode = mode_transition)) OR ((val.fldTmReport.fldEventCode = error_occurrence)))) OR ((val.fldTmReport.fldEventCode = tc_received)))) OR ((val.fldTmReport.fldEventCode = download_event)))) OR ((val.fldTmReport.fldEventCode = deleted)))) OR ((val.fldTmReport.fldEventCode = calibration_event))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDEVENTCODE_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.fldTmReport.fldTcAcceptance = accepted)) OR ((val.fldTmReport.fldTcAcceptance = not_accepted))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDTCACCEPTANCE_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldTmReport.fldModeTransitition.fldCause = transition_after_error_condition)) OR ((val.fldTmReport.fldModeTransitition.fldCause = automatic_transition_at_end_of_mode)))) OR ((val.fldTmReport.fldModeTransitition.fldCause = transition_after_tc))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDMODETRANSITITION_FLDCAUSE_2);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldTmReport.fldModeTransitition.fldCurrentMode = ini)) OR ((val.fldTmReport.fldModeTransitition.fldCurrentMode = swm)))) OR ((val.fldTmReport.fldModeTransitition.fldCurrentMode = stb)))) OR ((val.fldTmReport.fldModeTransitition.fldCurrentMode = trk)))) OR ((val.fldTmReport.fldModeTransitition.fldCurrentMode = img)))) OR ((val.fldTmReport.fldModeTransitition.fldCurrentMode = trk_hibernated))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDMODETRANSITITION_FLDCURRENTMODE_2);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldTmReport.fldModeTransitition.fldPreviousMode = ini)) OR ((val.fldTmReport.fldModeTransitition.fldPreviousMode = swm)))) OR ((val.fldTmReport.fldModeTransitition.fldPreviousMode = stb)))) OR ((val.fldTmReport.fldModeTransitition.fldPreviousMode = trk)))) OR ((val.fldTmReport.fldModeTransitition.fldPreviousMode = img)))) OR ((val.fldTmReport.fldModeTransitition.fldPreviousMode = trk_hibernated))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDMODETRANSITITION_FLDPREVIOUSMODE_2);
                        end if;

                    end if;

                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldTmReport.fldDownloadStatus = started)) OR ((val.fldTmReport.fldDownloadStatus = completed)))) OR ((val.fldTmReport.fldDownloadStatus = aborted))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDDOWNLOADSTATUS_2);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.fldTmReport.fldCalibration = started)) OR ((val.fldTmReport.fldCalibration = completed)))) OR ((val.fldTmReport.fldCalibration = aborted))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDCALIBRATION_2);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReport.fldErrorCode = tm_buffer_full), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDERRORCODE_2);
                                if ret.Success then
                                    case val.fldTmReport.body_choice.kind is
                                        WHEN fldTmReportAckFail_PRESENT =>
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReport.body_choice.fldTmReportAckFail = 0), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_BODY_CHOICE_FLDTMREPORTACKFAIL_2);
                                        WHEN fldTmReportAckOk_PRESENT =>
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReport.body_choice.fldTmReportAckOk = 0), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_BODY_CHOICE_FLDTMREPORTACKOK_2);
                                        WHEN fldTmReportModeTrans_PRESENT =>
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmReport.body_choice.fldTmReportModeTrans = 0), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_BODY_CHOICE_FLDTMREPORTMODETRANS_2);
                                    end case;
                                end if;

                            end if;

                        end if;

                    end if;

                end if;

            end if;

        WHEN fldTmStars_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStars.fldNumberOfStars <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDNUMBEROFSTARS_2);
            if ret.Success then
                i1 := val.fldTmStars.fldStars.Data'First;
                while ret.Success and i1 <= 16 loop
                    pragma Loop_Invariant (i1 >= val.fldTmStars.fldStars.Data'First and i1 <= 16);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStars.fldStars.Data(i1).fldXCoordinate <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDSTARS_ELM_FLDXCOORDINATE_2);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStars.fldStars.Data(i1).fldYCoordinate <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDSTARS_ELM_FLDYCOORDINATE_2);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStars.fldStars.Data(i1).fldDimension <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDSTARS_ELM_FLDDIMENSION_2);
                        end if;

                    end if;

                    i1 := i1+1;
                end loop;

            end if;

        WHEN fldTmStatus_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldTmStatus.fldOperatingMode = ini)) OR ((val.fldTmStatus.fldOperatingMode = swm)))) OR ((val.fldTmStatus.fldOperatingMode = stb)))) OR ((val.fldTmStatus.fldOperatingMode = trk)))) OR ((val.fldTmStatus.fldOperatingMode = img)))) OR ((val.fldTmStatus.fldOperatingMode = trk_hibernated))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDOPERATINGMODE_2);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldExposureTime <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDEXPOSURETIME_2);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldApsTemperature <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDAPSTEMPERATURE_2);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldOpticsTemperature <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDOPTICSTEMPERATURE_2);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldInputVoltage <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDINPUTVOLTAGE_2);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldHealthCheck <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDHEALTHCHECK_2);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldLinkSpeed <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDLINKSPEED_2);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.fldTmStatus.fldCycleOptionFrameSize = half_frame)) OR ((val.fldTmStatus.fldCycleOptionFrameSize = full_frame))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDCYCLEOPTIONFRAMESIZE_2);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_1x)) OR ((val.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_2x)))) OR ((val.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_4x)))) OR ((val.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_8x)))) OR ((val.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_16x)))) OR ((val.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_32x))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDCYCLEOPTIONPRESCALAR_2);
                                            if ret.Success then
                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldDefectivePixelLowThreshold <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDDEFECTIVEPIXELLOWTHRESHOLD_2);
                                                if ret.Success then
                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldDefectivePixelHighThreshold <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDDEFECTIVEPIXELHIGHTHRESHOLD_2);
                                                    if ret.Success then
                                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldNumCyclesForDefectDetection <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDNUMCYCLESFORDEFECTDETECTION_2);
                                                        if ret.Success then
                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldCameraStatusRate <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDCAMERASTATUSRATE_2);
                                                            if ret.Success then
                                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldSwRevisionNumber <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDSWREVISIONNUMBER_2);
                                                                if ret.Success then
                                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmStatus.fldSwIssueNumber <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDSWISSUENUMBER_2);
                                                                end if;

                                                            end if;

                                                        end if;

                                                    end if;

                                                end if;

                                            end if;

                                        end if;

                                    end if;

                                end if;

                            end if;

                        end if;

                    end if;

                end if;

            end if;

    end case;
    RETURN ret;
END NpalTmHeader_BODY_CHOICE_IsConstraintValid;



function NpalTmHeader_Equal(val1, val2: in NpalTmHeader)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldPktLength = val2.fldPktLength);

    if ret then
        ret := (val1.fldTmType = val2.fldTmType);

        if ret then
            ret := (val1.fldTmDays = val2.fldTmDays);

            if ret then
                ret := (val1.fldTmMillis = val2.fldTmMillis);

                if ret then
                    ret := NpalTmHeader_BODY_CHOICE_Equal(val1.body_choice, val2.body_choice);

                end if;
            end if;
        end if;
    end if;
	return ret;

end NpalTmHeader_Equal;

function NpalTmHeader_Init return NpalTmHeader
is
    val: NpalTmHeader;
begin

    --set fldPktLength 
    val.fldPktLength := Seds.SedsUint16_Init;
    --set fldTmType 
    val.fldTmType := Seds.SedsUint8_Init;
    --set fldTmDays 
    val.fldTmDays := Seds.SedsUint16_Init;
    --set fldTmMillis 
    val.fldTmMillis := Seds.SedsUint32_Init;
    --set body_choice 
    val.body_choice := NpalTmHeader_BODY_CHOICE_Init;
    return val;
end NpalTmHeader_Init;

FUNCTION NpalTmHeader_IsConstraintValid(val : in NpalTmHeader) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldPktLength <= 65535), ErrorCode => ERR_NPALTMHEADER_FLDPKTLENGTH);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmType <= 255), ErrorCode => ERR_NPALTMHEADER_FLDTMTYPE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmDays <= 65535), ErrorCode => ERR_NPALTMHEADER_FLDTMDAYS);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldTmMillis <= 4294967295), ErrorCode => ERR_NPALTMHEADER_FLDTMMILLIS);
                if ret.Success then
                    case val.body_choice.kind is
                        WHEN fldTmChecksum_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChecksum.fldStartAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHECKSUM_FLDSTARTADDRESS);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChecksum.fldEndAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHECKSUM_FLDENDADDRESS);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChecksum.fldChecksumResult <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHECKSUM_FLDCHECKSUMRESULT);
                                end if;

                            end if;

                        WHEN fldTmChkdata_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChkdata.fldLastReset <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDLASTRESET);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChkdata.fldPromSwRelease <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDPROMSWRELEASE);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChkdata.fldRamFaults <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDRAMFAULTS);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChkdata.fldFirstErrorAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDFIRSTERRORADDRESS);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChkdata.fldPromChecksum <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDPROMCHECKSUM);
                                            if ret.Success then
                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmChkdata.fldEepromChecksum <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMCHKDATA_FLDEEPROMCHECKSUM);
                                            end if;

                                        end if;

                                    end if;

                                end if;

                            end if;

                        WHEN fldTmDeflist_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmDeflist.fldPixelNumber <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDEFLIST_FLDPIXELNUMBER);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmDeflist.fldPixelData <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDEFLIST_FLDPIXELDATA);
                            end if;

                        WHEN fldTmDwndata_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmDwndata.fldStartAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDWNDATA_FLDSTARTADDRESS);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmDwndata.fldEndAddress <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDWNDATA_FLDENDADDRESS);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmDwndata.fldWords <= 4294967295), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMDWNDATA_FLDWORDS);
                                end if;

                            end if;

                        WHEN fldTmHorizon_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmHorizon.fldBorderPolarAngle <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMHORIZON_FLDBORDERPOLARANGLE);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmHorizon.fldBorderDistance <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMHORIZON_FLDBORDERDISTANCE);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmHorizon.fldRadius <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMHORIZON_FLDRADIUS);
                                end if;

                            end if;

                        WHEN fldTmImage1_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage1.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE1_FLDPACKETNUMBER);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage1.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE1_FLDPIXELNUMBER);
                                if ret.Success then
                                    i1 := val.body_choice.fldTmImage1.fldPixelData.Data'First;
                                    while ret.Success and i1 <= 4096 loop
                                        pragma Loop_Invariant (i1 >= val.body_choice.fldTmImage1.fldPixelData.Data'First and i1 <= 4096);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE1_FLDPIXELDATA_ELM);
                                        i1 := i1+1;
                                    end loop;

                                end if;

                            end if;

                        WHEN fldTmImage10_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage10.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE10_FLDPACKETNUMBER);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage10.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE10_FLDPIXELNUMBER);
                                if ret.Success then
                                    i1 := val.body_choice.fldTmImage10.fldPixelData.Data'First;
                                    while ret.Success and i1 <= 512 loop
                                        pragma Loop_Invariant (i1 >= val.body_choice.fldTmImage10.fldPixelData.Data'First and i1 <= 512);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage10.fldPixelData.Data(i1).fldPixel <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE10_FLDPIXELDATA_ELM_FLDPIXEL);
                                        i1 := i1+1;
                                    end loop;

                                end if;

                            end if;

                        WHEN fldTmImage2_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage2.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE2_FLDPACKETNUMBER);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage2.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE2_FLDPIXELNUMBER);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage2.fldPixelData <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE2_FLDPIXELDATA);
                                end if;

                            end if;

                        WHEN fldTmImage4_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage4.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE4_FLDPACKETNUMBER);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage4.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE4_FLDPIXELNUMBER);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage4.fldPixelData <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE4_FLDPIXELDATA);
                                end if;

                            end if;

                        WHEN fldTmImage8_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage8.fldPacketNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE8_FLDPACKETNUMBER);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage8.fldPixelNumber <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE8_FLDPIXELNUMBER);
                                if ret.Success then
                                    i1 := val.body_choice.fldTmImage8.fldPixelData.Data'First;
                                    while ret.Success and i1 <= 512 loop
                                        pragma Loop_Invariant (i1 >= val.body_choice.fldTmImage8.fldPixelData.Data'First and i1 <= 512);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmImage8.fldPixelData.Data(i1) <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMIMAGE8_FLDPIXELDATA_ELM);
                                        i1 := i1+1;
                                    end loop;

                                end if;

                            end if;

                        WHEN fldTmReport_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.body_choice.fldTmReport.fldEventCode = mode_transition)) OR ((val.body_choice.fldTmReport.fldEventCode = error_occurrence)))) OR ((val.body_choice.fldTmReport.fldEventCode = tc_received)))) OR ((val.body_choice.fldTmReport.fldEventCode = download_event)))) OR ((val.body_choice.fldTmReport.fldEventCode = deleted)))) OR ((val.body_choice.fldTmReport.fldEventCode = calibration_event))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDEVENTCODE);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.body_choice.fldTmReport.fldTcAcceptance = accepted)) OR ((val.body_choice.fldTmReport.fldTcAcceptance = not_accepted))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDTCACCEPTANCE);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.body_choice.fldTmReport.fldModeTransitition.fldCause = transition_after_error_condition)) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCause = automatic_transition_at_end_of_mode)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCause = transition_after_tc))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDMODETRANSITITION_FLDCAUSE);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.body_choice.fldTmReport.fldModeTransitition.fldCurrentMode = ini)) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCurrentMode = swm)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCurrentMode = stb)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCurrentMode = trk)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCurrentMode = img)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldCurrentMode = trk_hibernated))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDMODETRANSITITION_FLDCURRENTMODE);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.body_choice.fldTmReport.fldModeTransitition.fldPreviousMode = ini)) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldPreviousMode = swm)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldPreviousMode = stb)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldPreviousMode = trk)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldPreviousMode = img)))) OR ((val.body_choice.fldTmReport.fldModeTransitition.fldPreviousMode = trk_hibernated))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDMODETRANSITITION_FLDPREVIOUSMODE);
                                        end if;

                                    end if;

                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.body_choice.fldTmReport.fldDownloadStatus = started)) OR ((val.body_choice.fldTmReport.fldDownloadStatus = completed)))) OR ((val.body_choice.fldTmReport.fldDownloadStatus = aborted))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDDOWNLOADSTATUS);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.body_choice.fldTmReport.fldCalibration = started)) OR ((val.body_choice.fldTmReport.fldCalibration = completed)))) OR ((val.body_choice.fldTmReport.fldCalibration = aborted))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDCALIBRATION);
                                            if ret.Success then
                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReport.fldErrorCode = tm_buffer_full), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_FLDERRORCODE);
                                                if ret.Success then
                                                    case val.body_choice.fldTmReport.body_choice.kind is
                                                        WHEN fldTmReportAckFail_PRESENT =>
                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReport.body_choice.fldTmReportAckFail = 0), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_BODY_CHOICE_FLDTMREPORTACKFAIL);
                                                        WHEN fldTmReportAckOk_PRESENT =>
                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReport.body_choice.fldTmReportAckOk = 0), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_BODY_CHOICE_FLDTMREPORTACKOK);
                                                        WHEN fldTmReportModeTrans_PRESENT =>
                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmReport.body_choice.fldTmReportModeTrans = 0), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMREPORT_BODY_CHOICE_FLDTMREPORTMODETRANS);
                                                    end case;
                                                end if;

                                            end if;

                                        end if;

                                    end if;

                                end if;

                            end if;

                        WHEN fldTmStars_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStars.fldNumberOfStars <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDNUMBEROFSTARS);
                            if ret.Success then
                                i1 := val.body_choice.fldTmStars.fldStars.Data'First;
                                while ret.Success and i1 <= 16 loop
                                    pragma Loop_Invariant (i1 >= val.body_choice.fldTmStars.fldStars.Data'First and i1 <= 16);
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStars.fldStars.Data(i1).fldXCoordinate <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDSTARS_ELM_FLDXCOORDINATE);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStars.fldStars.Data(i1).fldYCoordinate <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDSTARS_ELM_FLDYCOORDINATE);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStars.fldStars.Data(i1).fldDimension <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTARS_FLDSTARS_ELM_FLDDIMENSION);
                                        end if;

                                    end if;

                                    i1 := i1+1;
                                end loop;

                            end if;

                        WHEN fldTmStatus_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.body_choice.fldTmStatus.fldOperatingMode = ini)) OR ((val.body_choice.fldTmStatus.fldOperatingMode = swm)))) OR ((val.body_choice.fldTmStatus.fldOperatingMode = stb)))) OR ((val.body_choice.fldTmStatus.fldOperatingMode = trk)))) OR ((val.body_choice.fldTmStatus.fldOperatingMode = img)))) OR ((val.body_choice.fldTmStatus.fldOperatingMode = trk_hibernated))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDOPERATINGMODE);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldExposureTime <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDEXPOSURETIME);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldApsTemperature <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDAPSTEMPERATURE);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldOpticsTemperature <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDOPTICSTEMPERATURE);
                                        if ret.Success then
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldInputVoltage <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDINPUTVOLTAGE);
                                            if ret.Success then
                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldHealthCheck <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDHEALTHCHECK);
                                                if ret.Success then
                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldLinkSpeed <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDLINKSPEED);
                                                    if ret.Success then
                                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.body_choice.fldTmStatus.fldCycleOptionFrameSize = half_frame)) OR ((val.body_choice.fldTmStatus.fldCycleOptionFrameSize = full_frame))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDCYCLEOPTIONFRAMESIZE);
                                                        if ret.Success then
                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((val.body_choice.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_1x)) OR ((val.body_choice.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_2x)))) OR ((val.body_choice.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_4x)))) OR ((val.body_choice.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_8x)))) OR ((val.body_choice.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_16x)))) OR ((val.body_choice.fldTmStatus.fldCycleOptionPrescalar = base_cycle_duration_32x))), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDCYCLEOPTIONPRESCALAR);
                                                            if ret.Success then
                                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldDefectivePixelLowThreshold <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDDEFECTIVEPIXELLOWTHRESHOLD);
                                                                if ret.Success then
                                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldDefectivePixelHighThreshold <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDDEFECTIVEPIXELHIGHTHRESHOLD);
                                                                    if ret.Success then
                                                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldNumCyclesForDefectDetection <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDNUMCYCLESFORDEFECTDETECTION);
                                                                        if ret.Success then
                                                                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldCameraStatusRate <= 65535), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDCAMERASTATUSRATE);
                                                                            if ret.Success then
                                                                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldSwRevisionNumber <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDSWREVISIONNUMBER);
                                                                                if ret.Success then
                                                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.fldTmStatus.fldSwIssueNumber <= 255), ErrorCode => ERR_NPALTMHEADER_BODY_CHOICE_FLDTMSTATUS_FLDSWISSUENUMBER);
                                                                                end if;

                                                                            end if;

                                                                        end if;

                                                                    end if;

                                                                end if;

                                                            end if;

                                                        end if;

                                                    end if;

                                                end if;

                                            end if;

                                        end if;

                                    end if;

                                end if;

                            end if;

                    end case;
                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END NpalTmHeader_IsConstraintValid;


 

END Npal;