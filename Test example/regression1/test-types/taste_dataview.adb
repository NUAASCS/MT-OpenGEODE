-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH TASTE_BasicTypes;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type TASTE_BasicTypes.T_UInt8;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function MyInteger_Equal(val1, val2: in MyInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyInteger_Equal;

function MyInteger_Init return MyInteger
is
    val: MyInteger;
begin
    val := TASTE_BasicTypes.T_UInt8_Init;
    return val;
end MyInteger_Init;

FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_MYINTEGER);
    RETURN ret;
END MyInteger_IsConstraintValid;



function MySeq_b_Equal(val1, val2: in MySeq_b)
    return Boolean 
is
begin
	return val1 = val2;

end MySeq_b_Equal;

function MySeq_Equal(val1, val2: in MySeq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.a = val2.a);

    if ret then
        ret := MySeq_b_Equal(val1.b, val2.b);

    end if;
	return ret;

end MySeq_Equal;

function MySeq_b_Init return MySeq_b
is
    val: MySeq_b;
begin
    val := taste;
    return val;
end MySeq_b_Init;
function MySeq_Init return MySeq
is
    val: MySeq;
begin

    --set a 
    val.a := MyInteger_Init;
    --set b 
    val.b := MySeq_b_Init;
    return val;
end MySeq_Init;

FUNCTION MySeq_IsConstraintValid(val : in MySeq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.a <= 255), ErrorCode => ERR_MYSEQ_A);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b = taste)) OR ((val.b = welcomes)))) OR ((val.b = you))), ErrorCode => ERR_MYSEQ_B);
    end if;

    RETURN ret;
END MySeq_IsConstraintValid;



function MySeq2_Equal(val1, val2: in MySeq2) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := MySeq_Equal(val1, val2);
    return ret;
end MySeq2_Equal;

function MySeq2_Init return MySeq2
is
    val: MySeq2;
begin
    val := MySeq_Init;
    return val;
end MySeq2_Init;

FUNCTION MySeq2_IsConstraintValid(val : in MySeq2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.a <= 255), ErrorCode => ERR_MYSEQ2_A);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b = taste)) OR ((val.b = welcomes)))) OR ((val.b = you))), ErrorCode => ERR_MYSEQ2_B);
    end if;

    RETURN ret;
END MySeq2_IsConstraintValid;



function MyChoice_Equal(val1, val2: in MyChoice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when a_PRESENT =>
                ret := (val1.a = val2.a);
            when b_PRESENT =>
                ret := MySeq_Equal(val1.b, val2.b);
            when c_PRESENT =>
                ret := MySeq_Equal(val1.c, val2.c);
        end case;
    end if;
	return ret;

end MyChoice_Equal;

function MyChoice_Init return MyChoice
is
    val: MyChoice;
begin
    --set a 
    declare
        a_tmp:adaasn1rtl.Asn1Boolean;
    begin
        a_tmp := FALSE;
        val := MyChoice'(kind => a_PRESENT, a => a_tmp);
    end;
    return val;
end MyChoice_Init;

FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A);
        WHEN b_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.b.a <= 255), ErrorCode => ERR_MYCHOICE_B_A);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b.b = taste)) OR ((val.b.b = welcomes)))) OR ((val.b.b = you))), ErrorCode => ERR_MYCHOICE_B_B);
            end if;

        WHEN c_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.c.a <= 255), ErrorCode => ERR_MYCHOICE_C_A);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.c.b = taste)) OR ((val.c.b = welcomes)))) OR ((val.c.b = you))), ErrorCode => ERR_MYCHOICE_C_B);
            end if;

    end case;
    RETURN ret;
END MyChoice_IsConstraintValid;



function MyChoice2_Equal(val1, val2: in MyChoice2) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := MyChoice_Equal(val1, val2);
    return ret;
end MyChoice2_Equal;

function MyChoice2_Init return MyChoice2
is
    val: MyChoice2;
begin
    val := MyChoice_Init;
    return val;
end MyChoice2_Init;

FUNCTION MyChoice2_IsConstraintValid(val : in MyChoice2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE2_A);
        WHEN b_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.b.a <= 255), ErrorCode => ERR_MYCHOICE2_B_A);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.b.b = taste)) OR ((val.b.b = welcomes)))) OR ((val.b.b = you))), ErrorCode => ERR_MYCHOICE2_B_B);
            end if;

        WHEN c_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.c.a <= 255), ErrorCode => ERR_MYCHOICE2_C_A);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.c.b = taste)) OR ((val.c.b = welcomes)))) OR ((val.c.b = you))), ErrorCode => ERR_MYCHOICE2_C_B);
            end if;

    end case;
    RETURN ret;
END MyChoice2_IsConstraintValid;



function MyReal_Equal(val1, val2: in MyReal)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end MyReal_Equal;

function MyReal_Init return MyReal
is
    val: MyReal;
begin
    val := 0.00000000000000000000E+000;
    return val;
end MyReal_Init;

FUNCTION MyReal_IsConstraintValid(val : in MyReal) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+003)), ErrorCode => ERR_MYREAL);
    RETURN ret;
END MyReal_IsConstraintValid;



function MyEnum_Equal(val1, val2: in MyEnum)
    return Boolean 
is
begin
	return val1 = val2;

end MyEnum_Equal;

function MyEnum_Init return MyEnum
is
    val: MyEnum;
begin
    val := hello;
    return val;
end MyEnum_Init;

FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = hello)) OR ((val = world)))) OR ((val = howareyou))), ErrorCode => ERR_MYENUM);
    RETURN ret;
END MyEnum_IsConstraintValid;



function MySeqOf_Equal(val1, val2: in MySeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MySeqOf_Equal;

function MySeqOf_Init return MySeqOf
is
    val: MySeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := MyEnum_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end MySeqOf_Init;

FUNCTION MySeqOf_IsConstraintValid(val : in MySeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.Data(i1) = hello)) OR ((val.Data(i1) = world)))) OR ((val.Data(i1) = howareyou))), ErrorCode => ERR_MYSEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MySeqOf_IsConstraintValid;



function MyOctStr_Equal(val1, val2: in MyOctStr)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end MyOctStr_Equal;

function MyOctStr_Init return MyOctStr
is
    val: MyOctStr;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

    return val;
end MyOctStr_Init;



function T1_replyToCommand_cmd2_Equal(val1, val2: in T1_replyToCommand_cmd2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end T1_replyToCommand_cmd2_Equal;

function T1_replyToCommand_Equal(val1, val2: in T1_replyToCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when cmd1_PRESENT =>
                ret := (val1.cmd1 = val2.cmd1);
            when cmd2_PRESENT =>
                ret := (val1.cmd2.Length = val2.cmd2.Length);
                i1 := val1.cmd2.Data'First;
                while ret and i1 <= val1.cmd2.Length loop
                    pragma Loop_Invariant (i1 >= val1.cmd2.Data'First and i1 >= val2.cmd2.Data'First and i1 <= val1.cmd2.Length  and val1.cmd2.Length = val2.cmd2.Length);
                    ret := (val1.cmd2.Data(i1) = val2.cmd2.Data(i1));
                    i1 := i1+1;
                end loop;

        end case;
    end if;
	return ret;

end T1_replyToCommand_Equal;

function T1_Equal(val1, val2: in T1)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when replyToCommand_PRESENT =>
                ret := val1.replyToCommand.kind = val2.replyToCommand.kind;
                if ret then
                    case val1.replyToCommand.kind is
                        when cmd1_PRESENT =>
                            ret := (val1.replyToCommand.cmd1 = val2.replyToCommand.cmd1);
                        when cmd2_PRESENT =>
                            ret := (val1.replyToCommand.cmd2.Length = val2.replyToCommand.cmd2.Length);
                            i1 := val1.replyToCommand.cmd2.Data'First;
                            while ret and i1 <= val1.replyToCommand.cmd2.Length loop
                                pragma Loop_Invariant (i1 >= val1.replyToCommand.cmd2.Data'First and i1 >= val2.replyToCommand.cmd2.Data'First and i1 <= val1.replyToCommand.cmd2.Length  and val1.replyToCommand.cmd2.Length = val2.replyToCommand.cmd2.Length);
                                ret := (val1.replyToCommand.cmd2.Data(i1) = val2.replyToCommand.cmd2.Data(i1));
                                i1 := i1+1;
                            end loop;

                    end case;
                end if;
        end case;
    end if;
	return ret;

end T1_Equal;

function T1_replyToCommand_cmd2_Init return T1_replyToCommand_cmd2
is
    val: T1_replyToCommand_cmd2;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end T1_replyToCommand_cmd2_Init;
function T1_replyToCommand_Init return T1_replyToCommand
is
    val: T1_replyToCommand;
begin
    --set cmd1 
    declare
        cmd1_tmp:adaasn1rtl.Asn1Boolean;
    begin
        cmd1_tmp := FALSE;
        val := T1_replyToCommand'(kind => cmd1_PRESENT, cmd1 => cmd1_tmp);
    end;
    return val;
end T1_replyToCommand_Init;
function T1_Init return T1
is
    val: T1;
begin
    --set replyToCommand 
    declare
        replyToCommand_tmp:T1_replyToCommand;
    begin
        val.replyToCommand := T1_replyToCommand_Init;
        val := T1'(kind => replyToCommand_PRESENT, replyToCommand => replyToCommand_tmp);
    end;
    return val;
end T1_Init;

FUNCTION T1_IsConstraintValid(val : in T1) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    case val.kind is
        WHEN replyToCommand_PRESENT =>
            case val.replyToCommand.kind is
                WHEN cmd1_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_T1_REPLYTOCOMMAND_CMD1);
                WHEN cmd2_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.replyToCommand.cmd2.Length) AND (val.replyToCommand.cmd2.Length <= 10)), ErrorCode => ERR_T1_REPLYTOCOMMAND_CMD2);
                    i1 := val.replyToCommand.cmd2.Data'First;
                    while ret.Success and i1 <= val.replyToCommand.cmd2.Length loop
                        pragma Loop_Invariant (i1 >= val.replyToCommand.cmd2.Data'First and i1 <= val.replyToCommand.cmd2.Length);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_T1_REPLYTOCOMMAND_CMD2_ELM);
                        i1 := i1+1;
                    end loop;

            end case;
    end case;
    RETURN ret;
END T1_IsConstraintValid;



function T2_Equal(val1, val2: in T2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := T1_Equal(val1.outputData, val2.outputData);

	return ret;

end T2_Equal;

function T2_Init return T2
is
    val: T2;
begin

    --set outputData 
    val.outputData := T1_Init;
    return val;
end T2_Init;

FUNCTION T2_IsConstraintValid(val : in T2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    case val.outputData.kind is
        WHEN replyToCommand_PRESENT =>
            case val.outputData.replyToCommand.kind is
                WHEN cmd1_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_T2_OUTPUTDATA_REPLYTOCOMMAND_CMD1);
                WHEN cmd2_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.outputData.replyToCommand.cmd2.Length) AND (val.outputData.replyToCommand.cmd2.Length <= 10)), ErrorCode => ERR_T2_OUTPUTDATA_REPLYTOCOMMAND_CMD2);
                    i1 := val.outputData.replyToCommand.cmd2.Data'First;
                    while ret.Success and i1 <= val.outputData.replyToCommand.cmd2.Length loop
                        pragma Loop_Invariant (i1 >= val.outputData.replyToCommand.cmd2.Data'First and i1 <= val.outputData.replyToCommand.cmd2.Length);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_T2_OUTPUTDATA_REPLYTOCOMMAND_CMD2_ELM);
                        i1 := i1+1;
                    end loop;

            end case;
    end case;
    RETURN ret;
END T2_IsConstraintValid;


 

END TASTE_Dataview;