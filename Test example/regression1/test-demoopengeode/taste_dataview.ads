-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
--# inherit ;


PACKAGE TASTE_Dataview with SPARK_Mode
IS


-- MyComplexSeqOf --------------------------------------------
-- MyComplexSeqOf_elem --------------------------------------------
SUBTYPE MyComplexSeqOf_elem_x is adaasn1rtl.Asn1UInt range 0 .. 255;


TYPE MyComplexSeqOf_elem IS RECORD 
    x : MyComplexSeqOf_elem_x;
END RECORD;
SUBTYPE MyComplexSeqOf_index is integer range 1..2;
TYPE MyComplexSeqOf_array IS ARRAY (MyComplexSeqOf_index) OF MyComplexSeqOf_elem;
TYPE MyComplexSeqOf IS  RECORD
    Data  : MyComplexSeqOf_array;
END RECORD;

function MyComplexSeqOf_elem_x_Equal(val1, val2: in MyComplexSeqOf_elem_x) return Boolean;

function MyComplexSeqOf_elem_Equal(val1, val2: in MyComplexSeqOf_elem) return Boolean;

function MyComplexSeqOf_Equal(val1, val2: in MyComplexSeqOf) return Boolean;

function MyComplexSeqOf_elem_x_Init return MyComplexSeqOf_elem_x;
function MyComplexSeqOf_elem_Init return MyComplexSeqOf_elem;
function MyComplexSeqOf_Init return MyComplexSeqOf;

ERR_MYCOMPLEXSEQOF_ELM_X:CONSTANT INTEGER := 31; 
FUNCTION MyComplexSeqOf_IsConstraintValid(val : in MyComplexSeqOf) return adaasn1rtl.ASN1_RESULT;
-- MyComplexChoice --------------------------------------------
-- MyComplexChoice_a --------------------------------------------
SUBTYPE MyComplexChoice_a_x is adaasn1rtl.Asn1UInt range 0 .. 255;


TYPE MyComplexChoice_a IS RECORD 
    x : MyComplexChoice_a_x;
END RECORD;

SUBTYPE MyComplexChoice_index_range is integer range 0..0;

TYPE MyComplexChoice_selection IS (MyComplexChoice_a_PRESENT);
for MyComplexChoice_selection use
    (MyComplexChoice_a_PRESENT => 1);
for MyComplexChoice_selection'Size use 32;

TYPE MyComplexChoice(kind : MyComplexChoice_selection:= MyComplexChoice_a_PRESENT) IS 
RECORD
    case kind is
    when MyComplexChoice_a_PRESENT =>
            a: MyComplexChoice_a;
    end case;
END RECORD;

FOR MyComplexChoice USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function MyComplexChoice_a_x_Equal(val1, val2: in MyComplexChoice_a_x) return Boolean;

function MyComplexChoice_a_Equal(val1, val2: in MyComplexChoice_a) return Boolean;

function MyComplexChoice_Equal(val1, val2: in MyComplexChoice) return Boolean;

function MyComplexChoice_a_x_Init return MyComplexChoice_a_x;
function MyComplexChoice_a_Init return MyComplexChoice_a;
function MyComplexChoice_Init return MyComplexChoice;

ERR_MYCOMPLEXCHOICE:CONSTANT INTEGER := 63; 
ERR_MYCOMPLEXCHOICE_A_X:CONSTANT INTEGER := 50; 
FUNCTION MyComplexChoice_IsConstraintValid(val : in MyComplexChoice) return adaasn1rtl.ASN1_RESULT;
SUBTYPE EnableDisable_index_range is integer range 0..1;
TYPE EnableDisable IS (scrubon, scruboff) with Convention => C;
for EnableDisable use
    (scrubon => 0, scruboff => 1);

function EnableDisable_Equal(val1, val2: in EnableDisable) return Boolean;

function EnableDisable_Init return EnableDisable;

ERR_ENABLEDISABLE:CONSTANT INTEGER := 70; -- 
FUNCTION EnableDisable_IsConstraintValid(val : in EnableDisable) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyInteger is adaasn1rtl.Asn1Int range -255 .. 255;


function MyInteger_Equal(val1, val2: in MyInteger) return Boolean;

function MyInteger_Init return MyInteger;

ERR_MYINTEGER:CONSTANT INTEGER := 104; -- 
FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT;
-- MyComplexType --------------------------------------------
-- MyComplexType_a --------------------------------------------
SUBTYPE MyComplexType_a_x is adaasn1rtl.Asn1UInt range 0 .. 255;


TYPE MyComplexType_a IS RECORD 
    x : MyComplexType_a_x;
    y : MyInteger;
END RECORD;

TYPE MyComplexType IS RECORD 
    a : MyComplexType_a;
END RECORD;

function MyComplexType_a_x_Equal(val1, val2: in MyComplexType_a_x) return Boolean;

function MyComplexType_a_Equal(val1, val2: in MyComplexType_a) return Boolean;

function MyComplexType_Equal(val1, val2: in MyComplexType) return Boolean;

function MyComplexType_a_x_Init return MyComplexType_a_x;
function MyComplexType_a_Init return MyComplexType_a;
function MyComplexType_Init return MyComplexType;

ERR_MYCOMPLEXTYPE_A_X:CONSTANT INTEGER := 1; 
ERR_MYCOMPLEXTYPE_A_Y:CONSTANT INTEGER := 8; 
FUNCTION MyComplexType_IsConstraintValid(val : in MyComplexType) return adaasn1rtl.ASN1_RESULT;
-- MySeq --------------------------------------------
SUBTYPE MySeq_b_index_range is integer range 0..2;
TYPE MySeq_b IS (taste, welcomes, you) with Convention => C;
for MySeq_b use
    (taste => 1, welcomes => 2, you => 3);

TYPE MySeq IS RECORD 
    a : MyInteger;
    b : MySeq_b;
END RECORD;

function MySeq_b_Equal(val1, val2: in MySeq_b) return Boolean;

function MySeq_Equal(val1, val2: in MySeq) return Boolean;

function MySeq_b_Init return MySeq_b;
function MySeq_Init return MySeq;

ERR_MYSEQ_A:CONSTANT INTEGER := 125; 
ERR_MYSEQ_B:CONSTANT INTEGER := 136; 
FUNCTION MySeq_IsConstraintValid(val : in MySeq) return adaasn1rtl.ASN1_RESULT;
-- MyChoice --------------------------------------------

SUBTYPE MyChoice_index_range is integer range 0..1;

TYPE MyChoice_selection IS (MyChoice_a_PRESENT, MyChoice_b_PRESENT);
for MyChoice_selection use
    (MyChoice_a_PRESENT => 1, MyChoice_b_PRESENT => 2);
for MyChoice_selection'Size use 32;

TYPE MyChoice(kind : MyChoice_selection:= MyChoice_a_PRESENT) IS 
RECORD
    case kind is
    when MyChoice_a_PRESENT =>
            a: adaasn1rtl.Asn1Boolean;
    when MyChoice_b_PRESENT =>
            b: MySeq;
    end case;
END RECORD;

FOR MyChoice USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function MyChoice_Equal(val1, val2: in MyChoice) return Boolean;

function MyChoice_Init return MyChoice;

ERR_MYCHOICE:CONSTANT INTEGER := 184; 
ERR_MYCHOICE_A:CONSTANT INTEGER := 149; 
ERR_MYCHOICE_B_A:CONSTANT INTEGER := 156; 
ERR_MYCHOICE_B_B:CONSTANT INTEGER := 167; 
FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT;
-- MyChoice2 --------------------------------------------
-- MyChoice2_b --------------------------------------------

SUBTYPE MyChoice2_b_index_range is integer range 0..1;

TYPE MyChoice2_b_selection IS (c_PRESENT, d_PRESENT);
for MyChoice2_b_selection use
    (c_PRESENT => 1, d_PRESENT => 2);
for MyChoice2_b_selection'Size use 32;

TYPE MyChoice2_b(kind : MyChoice2_b_selection:= c_PRESENT) IS 
RECORD
    case kind is
    when c_PRESENT =>
            c: adaasn1rtl.Asn1Boolean;
    when d_PRESENT =>
            d: MyInteger;
    end case;
END RECORD;

FOR MyChoice2_b USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

SUBTYPE MyChoice2_index_range is integer range 0..1;

TYPE MyChoice2_selection IS (MyChoice2_a_PRESENT, MyChoice2_b_PRESENT);
for MyChoice2_selection use
    (MyChoice2_a_PRESENT => 1, MyChoice2_b_PRESENT => 2);
for MyChoice2_selection'Size use 32;

TYPE MyChoice2(kind : MyChoice2_selection:= MyChoice2_a_PRESENT) IS 
RECORD
    case kind is
    when MyChoice2_a_PRESENT =>
            a: adaasn1rtl.Asn1Boolean;
    when MyChoice2_b_PRESENT =>
            b: MyChoice2_b;
    end case;
END RECORD;

FOR MyChoice2 USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function MyChoice2_b_Equal(val1, val2: in MyChoice2_b) return Boolean;

function MyChoice2_Equal(val1, val2: in MyChoice2) return Boolean;

function MyChoice2_b_Init return MyChoice2_b;
function MyChoice2_Init return MyChoice2;

ERR_MYCHOICE2:CONSTANT INTEGER := 280; 
ERR_MYCHOICE2_A:CONSTANT INTEGER := 248; 
ERR_MYCHOICE2_B:CONSTANT INTEGER := 273; 
ERR_MYCHOICE2_B_C:CONSTANT INTEGER := 255; 
ERR_MYCHOICE2_B_D:CONSTANT INTEGER := 262; 
FUNCTION MyChoice2_IsConstraintValid(val : in MyChoice2) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyReal is adaasn1rtl.Asn1Real;


function MyReal_Equal(val1, val2: in MyReal) return Boolean;

function MyReal_Init return MyReal;

ERR_MYREAL:CONSTANT INTEGER := 111; -- 
FUNCTION MyReal_IsConstraintValid(val : in MyReal) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyEnum_index_range is integer range 0..2;
TYPE MyEnum IS (hello, world, howareyou) with Convention => C;
for MyEnum use
    (hello => 0, world => 1, howareyou => 2);

function MyEnum_Equal(val1, val2: in MyEnum) return Boolean;

function MyEnum_Init return MyEnum;

ERR_MYENUM:CONSTANT INTEGER := 118; -- 
FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT;
-- MySeqOf --------------------------------------------
SUBTYPE MySeqOf_index is integer range 1..2;
TYPE MySeqOf_array IS ARRAY (MySeqOf_index) OF MyEnum;
TYPE MySeqOf IS  RECORD
    Data  : MySeqOf_array;
END RECORD;

function MySeqOf_Equal(val1, val2: in MySeqOf) return Boolean;

function MySeqOf_Init return MySeqOf;

ERR_MYSEQOF_ELM:CONSTANT INTEGER := 191; 
FUNCTION MySeqOf_IsConstraintValid(val : in MySeqOf) return adaasn1rtl.ASN1_RESULT;
-- MyRefSeqOf --------------------------------------------

TYPE MyRefSeqOf IS RECORD 
    seqof : MySeqOf;
END RECORD;

function MyRefSeqOf_Equal(val1, val2: in MyRefSeqOf) return Boolean;

function MyRefSeqOf_Init return MyRefSeqOf;

ERR_MYREFSEQOF_SEQOF_ELM:CONSTANT INTEGER := 77; 
FUNCTION MyRefSeqOf_IsConstraintValid(val : in MyRefSeqOf) return adaasn1rtl.ASN1_RESULT;
-- MyPossiblyEmptySeqOf --------------------------------------------
SUBTYPE MyPossiblyEmptySeqOf_elem is adaasn1rtl.Asn1UInt range 1 .. 2;

SUBTYPE MyPossiblyEmptySeqOf_index is integer range 1..2;
TYPE MyPossiblyEmptySeqOf_array IS ARRAY (MyPossiblyEmptySeqOf_index) OF MyPossiblyEmptySeqOf_elem;
SUBTYPE MyPossiblyEmptySeqOf_length_index is integer range 0..2;
TYPE MyPossiblyEmptySeqOf IS  RECORD
    Length : MyPossiblyEmptySeqOf_length_index;
    Data  : MyPossiblyEmptySeqOf_array;
END RECORD;

function MyPossiblyEmptySeqOf_elem_Equal(val1, val2: in MyPossiblyEmptySeqOf_elem) return Boolean;

function MyPossiblyEmptySeqOf_Equal(val1, val2: in MyPossiblyEmptySeqOf) return Boolean;

function MyPossiblyEmptySeqOf_elem_Init return MyPossiblyEmptySeqOf_elem;
function MyPossiblyEmptySeqOf_Init return MyPossiblyEmptySeqOf;

ERR_MYPOSSIBLYEMPTYSEQOF_ELM:CONSTANT INTEGER := 208; 
ERR_MYPOSSIBLYEMPTYSEQOF:CONSTANT INTEGER := 215; 
FUNCTION MyPossiblyEmptySeqOf_IsConstraintValid(val : in MyPossiblyEmptySeqOf) return adaasn1rtl.ASN1_RESULT;
-- MySeqWithEmbeddedSeqOf --------------------------------------------
-- MySeqWithEmbeddedSeqOf_a --------------------------------------------
SUBTYPE MySeqWithEmbeddedSeqOf_a_index is integer range 1..2;
TYPE MySeqWithEmbeddedSeqOf_a_array IS ARRAY (MySeqWithEmbeddedSeqOf_a_index) OF adaasn1rtl.Asn1Boolean;
SUBTYPE MySeqWithEmbeddedSeqOf_a_length_index is integer range 0..2;
TYPE MySeqWithEmbeddedSeqOf_a IS  RECORD
    Length : MySeqWithEmbeddedSeqOf_a_length_index;
    Data  : MySeqWithEmbeddedSeqOf_a_array;
END RECORD;

TYPE MySeqWithEmbeddedSeqOf IS RECORD 
    a : MySeqWithEmbeddedSeqOf_a;
END RECORD;

function MySeqWithEmbeddedSeqOf_a_Equal(val1, val2: in MySeqWithEmbeddedSeqOf_a) return Boolean;

function MySeqWithEmbeddedSeqOf_Equal(val1, val2: in MySeqWithEmbeddedSeqOf) return Boolean;

function MySeqWithEmbeddedSeqOf_a_Init return MySeqWithEmbeddedSeqOf_a;
function MySeqWithEmbeddedSeqOf_Init return MySeqWithEmbeddedSeqOf;

ERR_MYSEQWITHEMBEDDEDSEQOF_A_ELM:CONSTANT INTEGER := 222; 
ERR_MYSEQWITHEMBEDDEDSEQOF_A:CONSTANT INTEGER := 229; 
FUNCTION MySeqWithEmbeddedSeqOf_IsConstraintValid(val : in MySeqWithEmbeddedSeqOf) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyOctStr_index is integer range 1..3;
SUBTYPE MyOctStr_array IS adaasn1rtl.OctetBuffer(MyOctStr_index);
TYPE MyOctStr IS  RECORD
    Data  : MyOctStr_array;
END RECORD;

function MyOctStr_Equal(val1, val2: in MyOctStr) return Boolean;

function MyOctStr_Init return MyOctStr;

 

private
   --# hide TASTE_Dataview;


END TASTE_Dataview;