-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
--# inherit ;


PACKAGE TASTE_BasicTypes with SPARK_Mode
IS


SUBTYPE TASTE_Peek_id is adaasn1rtl.Asn1UInt range 0 .. 4294967295;


function TASTE_Peek_id_Equal(val1, val2: in TASTE_Peek_id) return Boolean;

function TASTE_Peek_id_Init return TASTE_Peek_id;

ERR_TASTE_PEEK_ID:CONSTANT INTEGER := 1; -- 
FUNCTION TASTE_Peek_id_IsConstraintValid(val : in TASTE_Peek_id) return adaasn1rtl.ASN1_RESULT;
-- TASTE_Peek_id_list --------------------------------------------
SUBTYPE TASTE_Peek_id_list_index is integer range 1..10;
TYPE TASTE_Peek_id_list_array IS ARRAY (TASTE_Peek_id_list_index) OF TASTE_Peek_id;
SUBTYPE TASTE_Peek_id_list_length_index is integer range 1..10;
TYPE TASTE_Peek_id_list IS  RECORD
    Length : TASTE_Peek_id_list_length_index;
    Data  : TASTE_Peek_id_list_array;
END RECORD;

function TASTE_Peek_id_list_Equal(val1, val2: in TASTE_Peek_id_list) return Boolean;

function TASTE_Peek_id_list_Init return TASTE_Peek_id_list;

ERR_TASTE_PEEK_ID_LIST_ELM:CONSTANT INTEGER := 8; 
ERR_TASTE_PEEK_ID_LIST:CONSTANT INTEGER := 19; 
FUNCTION TASTE_Peek_id_list_IsConstraintValid(val : in TASTE_Peek_id_list) return adaasn1rtl.ASN1_RESULT;
SUBTYPE VariableString_index is integer range 1..10;
SUBTYPE VariableString_array IS adaasn1rtl.OctetBuffer(VariableString_index);
SUBTYPE VariableString_length_index is integer range 1..10;
TYPE VariableString IS  RECORD
    Length : VariableString_length_index;
    Data  : VariableString_array;
END RECORD;

function VariableString_Equal(val1, val2: in VariableString) return Boolean;

function VariableString_Init return VariableString;

ERR_VARIABLESTRING:CONSTANT INTEGER := 26; -- 
FUNCTION VariableString_IsConstraintValid(val : in VariableString) return adaasn1rtl.ASN1_RESULT;
SUBTYPE FixedString_index is integer range 1..4;
SUBTYPE FixedString_array IS adaasn1rtl.OctetBuffer(FixedString_index);
TYPE FixedString IS  RECORD
    Data  : FixedString_array;
END RECORD;

function FixedString_Equal(val1, val2: in FixedString) return Boolean;

function FixedString_Init return FixedString;
-- SeqBool --------------------------------------------
SUBTYPE SeqBool_index is integer range 1..5;
TYPE SeqBool_array IS ARRAY (SeqBool_index) OF adaasn1rtl.Asn1Boolean;
SUBTYPE SeqBool_length_index is integer range 1..5;
TYPE SeqBool IS  RECORD
    Length : SeqBool_length_index;
    Data  : SeqBool_array;
END RECORD;

function SeqBool_Equal(val1, val2: in SeqBool) return Boolean;

function SeqBool_Init return SeqBool;

ERR_SEQBOOL_ELM:CONSTANT INTEGER := 39; 
ERR_SEQBOOL:CONSTANT INTEGER := 46; 
FUNCTION SeqBool_IsConstraintValid(val : in SeqBool) return adaasn1rtl.ASN1_RESULT;
-- SeqBoolFix --------------------------------------------
SUBTYPE SeqBoolFix_index is integer range 1..2;
TYPE SeqBoolFix_array IS ARRAY (SeqBoolFix_index) OF adaasn1rtl.Asn1Boolean;
TYPE SeqBoolFix IS  RECORD
    Data  : SeqBoolFix_array;
END RECORD;

function SeqBoolFix_Equal(val1, val2: in SeqBoolFix) return Boolean;

function SeqBoolFix_Init return SeqBoolFix;

ERR_SEQBOOLFIX_ELM:CONSTANT INTEGER := 53; 
FUNCTION SeqBoolFix_IsConstraintValid(val : in SeqBoolFix) return adaasn1rtl.ASN1_RESULT;
-- SeqEnum --------------------------------------------
SUBTYPE SeqEnum_elem_index_range is integer range 0..1;
TYPE SeqEnum_elem IS (SeqEnum_elm_hello, SeqEnum_elm_world) with Convention => C;
for SeqEnum_elem use
    (SeqEnum_elm_hello => 0, SeqEnum_elm_world => 1);
SUBTYPE SeqEnum_index is integer range 1..5;
TYPE SeqEnum_array IS ARRAY (SeqEnum_index) OF SeqEnum_elem;
SUBTYPE SeqEnum_length_index is integer range 1..5;
TYPE SeqEnum IS  RECORD
    Length : SeqEnum_length_index;
    Data  : SeqEnum_array;
END RECORD;

function SeqEnum_elem_Equal(val1, val2: in SeqEnum_elem) return Boolean;

function SeqEnum_Equal(val1, val2: in SeqEnum) return Boolean;

function SeqEnum_elem_Init return SeqEnum_elem;
function SeqEnum_Init return SeqEnum;

ERR_SEQENUM_ELM:CONSTANT INTEGER := 66; 
ERR_SEQENUM:CONSTANT INTEGER := 73; 
FUNCTION SeqEnum_IsConstraintValid(val : in SeqEnum) return adaasn1rtl.ASN1_RESULT;
-- SeqEnumFix --------------------------------------------
SUBTYPE SeqEnumFix_elem_index_range is integer range 0..1;
TYPE SeqEnumFix_elem IS (SeqEnumFix_elm_hello, SeqEnumFix_elm_world) with Convention => C;
for SeqEnumFix_elem use
    (SeqEnumFix_elm_hello => 0, SeqEnumFix_elm_world => 1);
SUBTYPE SeqEnumFix_index is integer range 1..2;
TYPE SeqEnumFix_array IS ARRAY (SeqEnumFix_index) OF SeqEnumFix_elem;
TYPE SeqEnumFix IS  RECORD
    Data  : SeqEnumFix_array;
END RECORD;

function SeqEnumFix_elem_Equal(val1, val2: in SeqEnumFix_elem) return Boolean;

function SeqEnumFix_Equal(val1, val2: in SeqEnumFix) return Boolean;

function SeqEnumFix_elem_Init return SeqEnumFix_elem;
function SeqEnumFix_Init return SeqEnumFix;

ERR_SEQENUMFIX_ELM:CONSTANT INTEGER := 80; 
FUNCTION SeqEnumFix_IsConstraintValid(val : in SeqEnumFix) return adaasn1rtl.ASN1_RESULT;
SUBTYPE Enum_T_index_range is integer range 0..4;
TYPE Enum_T IS (a, b, c, d, eE) with Convention => C;
for Enum_T use
    (a => 0, b => 1, c => 2, d => 3, eE => 4);

function Enum_T_Equal(val1, val2: in Enum_T) return Boolean;

function Enum_T_Init return Enum_T;

ERR_ENUM_T:CONSTANT INTEGER := 93; -- 
FUNCTION Enum_T_IsConstraintValid(val : in Enum_T) return adaasn1rtl.ASN1_RESULT;
-- Choice --------------------------------------------

SUBTYPE Choice_index_range is integer range 0..1;

TYPE Choice_selection IS (c1_PRESENT, cDe2_PRESENT);
for Choice_selection use
    (c1_PRESENT => 1, cDe2_PRESENT => 2);
for Choice_selection'Size use 32;

TYPE Choice(kind : Choice_selection:= c1_PRESENT) IS 
RECORD
    case kind is
    when c1_PRESENT =>
            c1: adaasn1rtl.Asn1Boolean;
    when cDe2_PRESENT =>
            cDe2: adaasn1rtl.Asn1Boolean;
    end case;
END RECORD;

FOR Choice USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function Choice_Equal(val1, val2: in Choice) return Boolean;

function Choice_Init return Choice;

ERR_CHOICE:CONSTANT INTEGER := 114; 
ERR_CHOICE_C1:CONSTANT INTEGER := 100; 
ERR_CHOICE_CDE2:CONSTANT INTEGER := 107; 
FUNCTION Choice_IsConstraintValid(val : in Choice) return adaasn1rtl.ASN1_RESULT;

 

private
   --# hide TASTE_BasicTypes;


END TASTE_BasicTypes;