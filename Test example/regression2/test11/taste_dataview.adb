-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function MyInteger_Equal(val1, val2: in MyInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyInteger_Equal;

function MyInteger_Init return MyInteger
is
    val: MyInteger;
begin
    val := 0;
    return val;
end MyInteger_Init;

FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_MYINTEGER);
    RETURN ret;
END MyInteger_IsConstraintValid;



function Some_Thing_Equal(val1, val2: in Some_Thing)
    return Boolean 
is
begin
	return val1 = val2;

end Some_Thing_Equal;

function Some_Thing_Init return Some_Thing
is
    val: Some_Thing;
begin
    val := MyInteger_Init;
    return val;
end Some_Thing_Init;

FUNCTION Some_Thing_IsConstraintValid(val : in Some_Thing) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_SOME_THING);
    RETURN ret;
END Some_Thing_IsConstraintValid;



function SeqOf_Equal(val1, val2: in SeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqOf_Equal;

function SeqOf_Init return SeqOf
is
    val: SeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := MyInteger_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end SeqOf_Init;

FUNCTION SeqOf_IsConstraintValid(val : in SeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_SEQOF);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_SEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqOf_IsConstraintValid;



function My_OctStr_Equal(val1, val2: in My_OctStr)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end My_OctStr_Equal;

function My_OctStr_Init return My_OctStr
is
    val: My_OctStr;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 20 loop
        pragma Loop_Invariant (i1 >=1 and i1<=20);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 20;
    return val;
end My_OctStr_Init;

FUNCTION My_OctStr_IsConstraintValid(val : in My_OctStr) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 20)), ErrorCode => ERR_MY_OCTSTR);
    RETURN ret;
END My_OctStr_IsConstraintValid;


 

END TASTE_Dataview;