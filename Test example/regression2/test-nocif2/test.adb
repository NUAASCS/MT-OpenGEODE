-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY Test with SPARK_Mode IS




function TestBoolean_Equal(val1, val2: in TestBoolean)
    return Boolean 
is
begin
	return val1 = val2;

end TestBoolean_Equal;

function TestBoolean_Init return TestBoolean
is
    val: TestBoolean;
begin
    val := FALSE;
    return val;
end TestBoolean_Init;

FUNCTION TestBoolean_IsConstraintValid(val : in TestBoolean) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TESTBOOLEAN);
    RETURN ret;
END TestBoolean_IsConstraintValid;



function TestInt32_Equal(val1, val2: in TestInt32)
    return Boolean 
is
begin
	return val1 = val2;

end TestInt32_Equal;

function TestInt32_Init return TestInt32
is
    val: TestInt32;
begin
    val := 0;
    return val;
end TestInt32_Init;

FUNCTION TestInt32_IsConstraintValid(val : in TestInt32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val) AND (val <= 2147483647)), ErrorCode => ERR_TESTINT32);
    RETURN ret;
END TestInt32_IsConstraintValid;



function TestFloat64_Equal(val1, val2: in TestFloat64)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end TestFloat64_Equal;

function TestFloat64_Init return TestFloat64
is
    val: TestFloat64;
begin
    val := 0.00000000000000000000E+000;
    return val;
end TestFloat64_Init;

FUNCTION TestFloat64_IsConstraintValid(val : in TestFloat64) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_TESTFLOAT64);
    RETURN ret;
END TestFloat64_IsConstraintValid;


 

END Test;