-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY Seds with SPARK_Mode IS




function SedsBoolean_Equal(val1, val2: in SedsBoolean)
    return Boolean 
is
begin
	return val1 = val2;

end SedsBoolean_Equal;

function SedsBoolean_Init return SedsBoolean
is
    val: SedsBoolean;
begin
    val := FALSE;
    return val;
end SedsBoolean_Init;

FUNCTION SedsBoolean_IsConstraintValid(val : in SedsBoolean) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEDSBOOLEAN);
    RETURN ret;
END SedsBoolean_IsConstraintValid;



function SedsUint8_Equal(val1, val2: in SedsUint8)
    return Boolean 
is
begin
	return val1 = val2;

end SedsUint8_Equal;

function SedsUint8_Init return SedsUint8
is
    val: SedsUint8;
begin
    val := 0;
    return val;
end SedsUint8_Init;

FUNCTION SedsUint8_IsConstraintValid(val : in SedsUint8) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_SEDSUINT8);
    RETURN ret;
END SedsUint8_IsConstraintValid;



function SedsUint16_Equal(val1, val2: in SedsUint16)
    return Boolean 
is
begin
	return val1 = val2;

end SedsUint16_Equal;

function SedsUint16_Init return SedsUint16
is
    val: SedsUint16;
begin
    val := 0;
    return val;
end SedsUint16_Init;

FUNCTION SedsUint16_IsConstraintValid(val : in SedsUint16) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 65535), ErrorCode => ERR_SEDSUINT16);
    RETURN ret;
END SedsUint16_IsConstraintValid;



function SedsUint32_Equal(val1, val2: in SedsUint32)
    return Boolean 
is
begin
	return val1 = val2;

end SedsUint32_Equal;

function SedsUint32_Init return SedsUint32
is
    val: SedsUint32;
begin
    val := 0;
    return val;
end SedsUint32_Init;

FUNCTION SedsUint32_IsConstraintValid(val : in SedsUint32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_SEDSUINT32);
    RETURN ret;
END SedsUint32_IsConstraintValid;



function SedsInt8_Equal(val1, val2: in SedsInt8)
    return Boolean 
is
begin
	return val1 = val2;

end SedsInt8_Equal;

function SedsInt8_Init return SedsInt8
is
    val: SedsInt8;
begin
    val := 0;
    return val;
end SedsInt8_Init;

FUNCTION SedsInt8_IsConstraintValid(val : in SedsInt8) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-128 <= val) AND (val <= 127)), ErrorCode => ERR_SEDSINT8);
    RETURN ret;
END SedsInt8_IsConstraintValid;



function SedsInt16_Equal(val1, val2: in SedsInt16)
    return Boolean 
is
begin
	return val1 = val2;

end SedsInt16_Equal;

function SedsInt16_Init return SedsInt16
is
    val: SedsInt16;
begin
    val := 0;
    return val;
end SedsInt16_Init;

FUNCTION SedsInt16_IsConstraintValid(val : in SedsInt16) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-32768 <= val) AND (val <= 32767)), ErrorCode => ERR_SEDSINT16);
    RETURN ret;
END SedsInt16_IsConstraintValid;



function SedsInt32_Equal(val1, val2: in SedsInt32)
    return Boolean 
is
begin
	return val1 = val2;

end SedsInt32_Equal;

function SedsInt32_Init return SedsInt32
is
    val: SedsInt32;
begin
    val := 0;
    return val;
end SedsInt32_Init;

FUNCTION SedsInt32_IsConstraintValid(val : in SedsInt32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val) AND (val <= 2147483647)), ErrorCode => ERR_SEDSINT32);
    RETURN ret;
END SedsInt32_IsConstraintValid;



function SedsFloat32_Equal(val1, val2: in SedsFloat32)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsFloat32_Equal;

function SedsFloat32_Init return SedsFloat32
is
    val: SedsFloat32;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsFloat32_Init;

FUNCTION SedsFloat32_IsConstraintValid(val : in SedsFloat32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.40282346638528860000E+038 <= val) AND (val <= 3.40282346638528860000E+038)), ErrorCode => ERR_SEDSFLOAT32);
    RETURN ret;
END SedsFloat32_IsConstraintValid;



function SedsFloat64_Equal(val1, val2: in SedsFloat64)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsFloat64_Equal;

function SedsFloat64_Init return SedsFloat64
is
    val: SedsFloat64;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsFloat64_Init;

FUNCTION SedsFloat64_IsConstraintValid(val : in SedsFloat64) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSFLOAT64);
    RETURN ret;
END SedsFloat64_IsConstraintValid;



function SedsNumberOfMetre_Equal(val1, val2: in SedsNumberOfMetre)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfMetre_Equal;

function SedsNumberOfMetre_Init return SedsNumberOfMetre
is
    val: SedsNumberOfMetre;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfMetre_Init;

FUNCTION SedsNumberOfMetre_IsConstraintValid(val : in SedsNumberOfMetre) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFMETRE);
    RETURN ret;
END SedsNumberOfMetre_IsConstraintValid;



function SedsPosition_Equal(val1, val2: in SedsPosition)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (adaasn1rtl.Asn1Real_Equal(val1.Data(i1), val2.Data(i1)));
        i1 := i1+1;
    end loop;
	return ret;

end SedsPosition_Equal;

function SedsPosition_Init return SedsPosition
is
    val: SedsPosition;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := SedsNumberOfMetre_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end SedsPosition_Init;

FUNCTION SedsPosition_IsConstraintValid(val : in SedsPosition) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 3);
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.Data(i1)) AND (val.Data(i1) <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSPOSITION_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SedsPosition_IsConstraintValid;



function SedsRadianRate_Equal(val1, val2: in SedsRadianRate)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsRadianRate_Equal;

function SedsRadianRate_Init return SedsRadianRate
is
    val: SedsRadianRate;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsRadianRate_Init;

FUNCTION SedsRadianRate_IsConstraintValid(val : in SedsRadianRate) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSRADIANRATE);
    RETURN ret;
END SedsRadianRate_IsConstraintValid;



function SedsAngularRate_Equal(val1, val2: in SedsAngularRate)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (adaasn1rtl.Asn1Real_Equal(val1.Data(i1), val2.Data(i1)));
        i1 := i1+1;
    end loop;
	return ret;

end SedsAngularRate_Equal;

function SedsAngularRate_Init return SedsAngularRate
is
    val: SedsAngularRate;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := SedsRadianRate_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end SedsAngularRate_Init;

FUNCTION SedsAngularRate_IsConstraintValid(val : in SedsAngularRate) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 3);
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.Data(i1)) AND (val.Data(i1) <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSANGULARRATE_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SedsAngularRate_IsConstraintValid;



function SedsMetreRate_Equal(val1, val2: in SedsMetreRate)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsMetreRate_Equal;

function SedsMetreRate_Init return SedsMetreRate
is
    val: SedsMetreRate;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsMetreRate_Init;

FUNCTION SedsMetreRate_IsConstraintValid(val : in SedsMetreRate) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSMETRERATE);
    RETURN ret;
END SedsMetreRate_IsConstraintValid;



function SedsVelocity_Equal(val1, val2: in SedsVelocity)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (adaasn1rtl.Asn1Real_Equal(val1.Data(i1), val2.Data(i1)));
        i1 := i1+1;
    end loop;
	return ret;

end SedsVelocity_Equal;

function SedsVelocity_Init return SedsVelocity
is
    val: SedsVelocity;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 3 loop
        pragma Loop_Invariant (i1 >=1 and i1<=3);
        val.Data(i1) := SedsMetreRate_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end SedsVelocity_Init;

FUNCTION SedsVelocity_IsConstraintValid(val : in SedsVelocity) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 3 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 3);
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.Data(i1)) AND (val.Data(i1) <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSVELOCITY_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SedsVelocity_IsConstraintValid;



function SedsNumberOfSeconds_Equal(val1, val2: in SedsNumberOfSeconds)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfSeconds_Equal;

function SedsNumberOfSeconds_Init return SedsNumberOfSeconds
is
    val: SedsNumberOfSeconds;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfSeconds_Init;

FUNCTION SedsNumberOfSeconds_IsConstraintValid(val : in SedsNumberOfSeconds) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFSECONDS);
    RETURN ret;
END SedsNumberOfSeconds_IsConstraintValid;



function SedsValidityFlag_Equal(val1, val2: in SedsValidityFlag)
    return Boolean 
is
begin
	return val1 = val2;

end SedsValidityFlag_Equal;

function SedsValidityFlag_Init return SedsValidityFlag
is
    val: SedsValidityFlag;
begin
    val := FALSE;
    return val;
end SedsValidityFlag_Init;

FUNCTION SedsValidityFlag_IsConstraintValid(val : in SedsValidityFlag) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEDSVALIDITYFLAG);
    RETURN ret;
END SedsValidityFlag_IsConstraintValid;



function SedsCommandStatus_Equal(val1, val2: in SedsCommandStatus)
    return Boolean 
is
begin
	return val1 = val2;

end SedsCommandStatus_Equal;

function SedsCommandStatus_Init return SedsCommandStatus
is
    val: SedsCommandStatus;
begin
    val := FALSE;
    return val;
end SedsCommandStatus_Init;

FUNCTION SedsCommandStatus_IsConstraintValid(val : in SedsCommandStatus) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEDSCOMMANDSTATUS);
    RETURN ret;
END SedsCommandStatus_IsConstraintValid;



function SedsNumberOfVolt_Equal(val1, val2: in SedsNumberOfVolt)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfVolt_Equal;

function SedsNumberOfVolt_Init return SedsNumberOfVolt
is
    val: SedsNumberOfVolt;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfVolt_Init;

FUNCTION SedsNumberOfVolt_IsConstraintValid(val : in SedsNumberOfVolt) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFVOLT);
    RETURN ret;
END SedsNumberOfVolt_IsConstraintValid;



function SedsNumberOfWatt_Equal(val1, val2: in SedsNumberOfWatt)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfWatt_Equal;

function SedsNumberOfWatt_Init return SedsNumberOfWatt
is
    val: SedsNumberOfWatt;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfWatt_Init;

FUNCTION SedsNumberOfWatt_IsConstraintValid(val : in SedsNumberOfWatt) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFWATT);
    RETURN ret;
END SedsNumberOfWatt_IsConstraintValid;



function SedsNumberOfRadian_Equal(val1, val2: in SedsNumberOfRadian)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfRadian_Equal;

function SedsNumberOfRadian_Init return SedsNumberOfRadian
is
    val: SedsNumberOfRadian;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfRadian_Init;

FUNCTION SedsNumberOfRadian_IsConstraintValid(val : in SedsNumberOfRadian) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFRADIAN);
    RETURN ret;
END SedsNumberOfRadian_IsConstraintValid;



function SedsNumberOfNewton_Equal(val1, val2: in SedsNumberOfNewton)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfNewton_Equal;

function SedsNumberOfNewton_Init return SedsNumberOfNewton
is
    val: SedsNumberOfNewton;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfNewton_Init;

FUNCTION SedsNumberOfNewton_IsConstraintValid(val : in SedsNumberOfNewton) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFNEWTON);
    RETURN ret;
END SedsNumberOfNewton_IsConstraintValid;



function SedsBitRate_Equal(val1, val2: in SedsBitRate)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsBitRate_Equal;

function SedsBitRate_Init return SedsBitRate
is
    val: SedsBitRate;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsBitRate_Init;

FUNCTION SedsBitRate_IsConstraintValid(val : in SedsBitRate) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSBITRATE);
    RETURN ret;
END SedsBitRate_IsConstraintValid;



function SedsSecondsSinceTAI_Equal(val1, val2: in SedsSecondsSinceTAI)
    return Boolean 
is
begin
	return val1 = val2;

end SedsSecondsSinceTAI_Equal;

function SedsSecondsSinceTAI_Init return SedsSecondsSinceTAI
is
    val: SedsSecondsSinceTAI;
begin
    val := 0;
    return val;
end SedsSecondsSinceTAI_Init;

FUNCTION SedsSecondsSinceTAI_IsConstraintValid(val : in SedsSecondsSinceTAI) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_SEDSSECONDSSINCETAI);
    RETURN ret;
END SedsSecondsSinceTAI_IsConstraintValid;



function SedsCucTime_fldFine_Equal(val1, val2: in SedsCucTime_fldFine)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsCucTime_fldFine_Equal;

function SedsCucTime_Equal(val1, val2: in SedsCucTime)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldCoarse = val2.fldCoarse);

    if ret then
        ret := SedsCucTime_fldFine_Equal(val1.fldFine, val2.fldFine);

    end if;
	return ret;

end SedsCucTime_Equal;

function SedsCucTime_fldFine_Init return SedsCucTime_fldFine
is
    val: SedsCucTime_fldFine;
begin
    val := SedsNumberOfSeconds_Init;
    return val;
end SedsCucTime_fldFine_Init;
function SedsCucTime_Init return SedsCucTime
is
    val: SedsCucTime;
begin

    --set fldCoarse 
    val.fldCoarse := SedsSecondsSinceTAI_Init;
    --set fldFine 
    val.fldFine := SedsCucTime_fldFine_Init;
    return val;
end SedsCucTime_Init;

FUNCTION SedsCucTime_IsConstraintValid(val : in SedsCucTime) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldCoarse <= 4294967295), ErrorCode => ERR_SEDSCUCTIME_FLDCOARSE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.fldFine) AND (val.fldFine <= 1.79769313486231570000E+308)) AND ((0.00000000000000000000E+000 <= val.fldFine) AND (val.fldFine <= 1.00000000000000000000E+000)), ErrorCode => ERR_SEDSCUCTIME_FLDFINE);
    end if;

    RETURN ret;
END SedsCucTime_IsConstraintValid;



function SedsDaysSinceTAI_Equal(val1, val2: in SedsDaysSinceTAI)
    return Boolean 
is
begin
	return val1 = val2;

end SedsDaysSinceTAI_Equal;

function SedsDaysSinceTAI_Init return SedsDaysSinceTAI
is
    val: SedsDaysSinceTAI;
begin
    val := 0;
    return val;
end SedsDaysSinceTAI_Init;

FUNCTION SedsDaysSinceTAI_IsConstraintValid(val : in SedsDaysSinceTAI) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_SEDSDAYSSINCETAI);
    RETURN ret;
END SedsDaysSinceTAI_IsConstraintValid;



function SedsCdsTime_fldSeconds_Equal(val1, val2: in SedsCdsTime_fldSeconds)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsCdsTime_fldSeconds_Equal;

function SedsCdsTime_Equal(val1, val2: in SedsCdsTime)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.fldDays = val2.fldDays);

    if ret then
        ret := SedsCdsTime_fldSeconds_Equal(val1.fldSeconds, val2.fldSeconds);

    end if;
	return ret;

end SedsCdsTime_Equal;

function SedsCdsTime_fldSeconds_Init return SedsCdsTime_fldSeconds
is
    val: SedsCdsTime_fldSeconds;
begin
    val := SedsNumberOfSeconds_Init;
    return val;
end SedsCdsTime_fldSeconds_Init;
function SedsCdsTime_Init return SedsCdsTime
is
    val: SedsCdsTime;
begin

    --set fldDays 
    val.fldDays := SedsDaysSinceTAI_Init;
    --set fldSeconds 
    val.fldSeconds := SedsCdsTime_fldSeconds_Init;
    return val;
end SedsCdsTime_Init;

FUNCTION SedsCdsTime_IsConstraintValid(val : in SedsCdsTime) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.fldDays <= 4294967295), ErrorCode => ERR_SEDSCDSTIME_FLDDAYS);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.fldSeconds) AND (val.fldSeconds <= 1.79769313486231570000E+308)) AND ((0.00000000000000000000E+000 <= val.fldSeconds) AND (val.fldSeconds <= 8.64000000000000000000E+004)), ErrorCode => ERR_SEDSCDSTIME_FLDSECONDS);
    end if;

    RETURN ret;
END SedsCdsTime_IsConstraintValid;



function SedsQuaternianCoordinate_Equal(val1, val2: in SedsQuaternianCoordinate)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsQuaternianCoordinate_Equal;

function SedsQuaternianCoordinate_Init return SedsQuaternianCoordinate
is
    val: SedsQuaternianCoordinate;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsQuaternianCoordinate_Init;

FUNCTION SedsQuaternianCoordinate_IsConstraintValid(val : in SedsQuaternianCoordinate) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+000 <= val) AND (val <= 1.00000000000000000000E+000)), ErrorCode => ERR_SEDSQUATERNIANCOORDINATE);
    RETURN ret;
END SedsQuaternianCoordinate_IsConstraintValid;



function SedsQuaternian_Equal(val1, val2: in SedsQuaternian)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.fldQ1, val2.fldQ1));

    if ret then
        ret := (adaasn1rtl.Asn1Real_Equal(val1.fldQ2, val2.fldQ2));

        if ret then
            ret := (adaasn1rtl.Asn1Real_Equal(val1.fldQ3, val2.fldQ3));

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.fldScalar, val2.fldScalar));

            end if;
        end if;
    end if;
	return ret;

end SedsQuaternian_Equal;

function SedsQuaternian_Init return SedsQuaternian
is
    val: SedsQuaternian;
begin

    --set fldQ1 
    val.fldQ1 := SedsQuaternianCoordinate_Init;
    --set fldQ2 
    val.fldQ2 := SedsQuaternianCoordinate_Init;
    --set fldQ3 
    val.fldQ3 := SedsQuaternianCoordinate_Init;
    --set fldScalar 
    val.fldScalar := SedsQuaternianCoordinate_Init;
    return val;
end SedsQuaternian_Init;

FUNCTION SedsQuaternian_IsConstraintValid(val : in SedsQuaternian) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+000 <= val.fldQ1) AND (val.fldQ1 <= 1.00000000000000000000E+000)), ErrorCode => ERR_SEDSQUATERNIAN_FLDQ1);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+000 <= val.fldQ2) AND (val.fldQ2 <= 1.00000000000000000000E+000)), ErrorCode => ERR_SEDSQUATERNIAN_FLDQ2);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+000 <= val.fldQ3) AND (val.fldQ3 <= 1.00000000000000000000E+000)), ErrorCode => ERR_SEDSQUATERNIAN_FLDQ3);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+000 <= val.fldScalar) AND (val.fldScalar <= 1.00000000000000000000E+000)), ErrorCode => ERR_SEDSQUATERNIAN_FLDSCALAR);
            end if;

        end if;

    end if;

    RETURN ret;
END SedsQuaternian_IsConstraintValid;



function SedsAngle_Equal(val1, val2: in SedsAngle)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsAngle_Equal;

function SedsAngle_Init return SedsAngle
is
    val: SedsAngle;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsAngle_Init;

FUNCTION SedsAngle_IsConstraintValid(val : in SedsAngle) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.14159265358979310000E+000 <= val) AND (val <= 3.14159265358979310000E+000)), ErrorCode => ERR_SEDSANGLE);
    RETURN ret;
END SedsAngle_IsConstraintValid;



function SedsKeplerianOrbitalElements_fldE_Equal(val1, val2: in SedsKeplerianOrbitalElements_fldE)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsKeplerianOrbitalElements_fldE_Equal;

function SedsKeplerianOrbitalElements_fldI_Equal(val1, val2: in SedsKeplerianOrbitalElements_fldI)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsKeplerianOrbitalElements_fldI_Equal;

function SedsKeplerianOrbitalElements_Equal(val1, val2: in SedsKeplerianOrbitalElements)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (adaasn1rtl.Asn1Real_Equal(val1.fldA, val2.fldA));

    if ret then
        ret := SedsKeplerianOrbitalElements_fldE_Equal(val1.fldE, val2.fldE);

        if ret then
            ret := SedsKeplerianOrbitalElements_fldI_Equal(val1.fldI, val2.fldI);

            if ret then
                ret := (adaasn1rtl.Asn1Real_Equal(val1.fldRa, val2.fldRa));

                if ret then
                    ret := (adaasn1rtl.Asn1Real_Equal(val1.fldOmega, val2.fldOmega));

                    if ret then
                        ret := (adaasn1rtl.Asn1Real_Equal(val1.fldNu, val2.fldNu));

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end SedsKeplerianOrbitalElements_Equal;

function SedsKeplerianOrbitalElements_fldE_Init return SedsKeplerianOrbitalElements_fldE
is
    val: SedsKeplerianOrbitalElements_fldE;
begin
    val := SedsFloat64_Init;
    return val;
end SedsKeplerianOrbitalElements_fldE_Init;
function SedsKeplerianOrbitalElements_fldI_Init return SedsKeplerianOrbitalElements_fldI
is
    val: SedsKeplerianOrbitalElements_fldI;
begin
    val := SedsAngle_Init;
    return val;
end SedsKeplerianOrbitalElements_fldI_Init;
function SedsKeplerianOrbitalElements_Init return SedsKeplerianOrbitalElements
is
    val: SedsKeplerianOrbitalElements;
begin

    --set fldA 
    val.fldA := SedsNumberOfMetre_Init;
    --set fldE 
    val.fldE := SedsKeplerianOrbitalElements_fldE_Init;
    --set fldI 
    val.fldI := SedsKeplerianOrbitalElements_fldI_Init;
    --set fldRa 
    val.fldRa := SedsAngle_Init;
    --set fldOmega 
    val.fldOmega := SedsAngle_Init;
    --set fldNu 
    val.fldNu := SedsAngle_Init;
    return val;
end SedsKeplerianOrbitalElements_Init;

FUNCTION SedsKeplerianOrbitalElements_IsConstraintValid(val : in SedsKeplerianOrbitalElements) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.fldA) AND (val.fldA <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSKEPLERIANORBITALELEMENTS_FLDA);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.79769313486231570000E+308 <= val.fldE) AND (val.fldE <= 1.79769313486231570000E+308)) AND ((0.00000000000000000000E+000 <= val.fldE) AND (val.fldE <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSKEPLERIANORBITALELEMENTS_FLDE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.14159265358979310000E+000 <= val.fldI) AND (val.fldI <= 3.14159265358979310000E+000)) AND ((0.00000000000000000000E+000 <= val.fldI) AND (val.fldI <= 3.14159265358979310000E+000)), ErrorCode => ERR_SEDSKEPLERIANORBITALELEMENTS_FLDI);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.14159265358979310000E+000 <= val.fldRa) AND (val.fldRa <= 3.14159265358979310000E+000)), ErrorCode => ERR_SEDSKEPLERIANORBITALELEMENTS_FLDRA);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.14159265358979310000E+000 <= val.fldOmega) AND (val.fldOmega <= 3.14159265358979310000E+000)), ErrorCode => ERR_SEDSKEPLERIANORBITALELEMENTS_FLDOMEGA);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.14159265358979310000E+000 <= val.fldNu) AND (val.fldNu <= 3.14159265358979310000E+000)), ErrorCode => ERR_SEDSKEPLERIANORBITALELEMENTS_FLDNU);
                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END SedsKeplerianOrbitalElements_IsConstraintValid;



function SedsNumberOfKelvin_Equal(val1, val2: in SedsNumberOfKelvin)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfKelvin_Equal;

function SedsNumberOfKelvin_Init return SedsNumberOfKelvin
is
    val: SedsNumberOfKelvin;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfKelvin_Init;

FUNCTION SedsNumberOfKelvin_IsConstraintValid(val : in SedsNumberOfKelvin) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFKELVIN);
    RETURN ret;
END SedsNumberOfKelvin_IsConstraintValid;



function SedsNumberOfKilograms_Equal(val1, val2: in SedsNumberOfKilograms)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfKilograms_Equal;

function SedsNumberOfKilograms_Init return SedsNumberOfKilograms
is
    val: SedsNumberOfKilograms;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfKilograms_Init;

FUNCTION SedsNumberOfKilograms_IsConstraintValid(val : in SedsNumberOfKilograms) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFKILOGRAMS);
    RETURN ret;
END SedsNumberOfKilograms_IsConstraintValid;



function SedsNumberOfAmperes_Equal(val1, val2: in SedsNumberOfAmperes)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfAmperes_Equal;

function SedsNumberOfAmperes_Init return SedsNumberOfAmperes
is
    val: SedsNumberOfAmperes;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfAmperes_Init;

FUNCTION SedsNumberOfAmperes_IsConstraintValid(val : in SedsNumberOfAmperes) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFAMPERES);
    RETURN ret;
END SedsNumberOfAmperes_IsConstraintValid;



function SedsNumberOfBits_Equal(val1, val2: in SedsNumberOfBits)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end SedsNumberOfBits_Equal;

function SedsNumberOfBits_Init return SedsNumberOfBits
is
    val: SedsNumberOfBits;
begin
    val := 0.00000000000000000000E+000;
    return val;
end SedsNumberOfBits_Init;

FUNCTION SedsNumberOfBits_IsConstraintValid(val : in SedsNumberOfBits) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0.00000000000000000000E+000 <= val) AND (val <= 1.79769313486231570000E+308)), ErrorCode => ERR_SEDSNUMBEROFBITS);
    RETURN ret;
END SedsNumberOfBits_IsConstraintValid;


 

END Seds;