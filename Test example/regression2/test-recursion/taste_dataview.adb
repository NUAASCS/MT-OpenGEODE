-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function Letter_Equal(val1, val2: in Letter)
    return Boolean 
is
begin
	return val1 = val2;

end Letter_Equal;

function Letter_Init return Letter
is
    val: Letter;
begin
    val := a;
    return val;
end Letter_Init;

FUNCTION Letter_IsConstraintValid(val : in Letter) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((((((((((((((((((((((((((((((((((((((((((val = a)) OR ((val = b)))) OR ((val = c)))) OR ((val = d)))) OR ((val = e)))) OR ((val = f)))) OR ((val = g)))) OR ((val = h)))) OR ((val = i)))) OR ((val = j)))) OR ((val = k)))) OR ((val = l)))) OR ((val = m)))) OR ((val = n)))) OR ((val = o)))) OR ((val = p)))) OR ((val = q)))) OR ((val = r)))) OR ((val = s)))) OR ((val = t)))) OR ((val = u)))) OR ((val = v)))) OR ((val = w)))) OR ((val = x)))) OR ((val = y)))) OR ((val = z))), ErrorCode => ERR_LETTER);
    RETURN ret;
END Letter_IsConstraintValid;



function Path_elem_Equal(val1, val2: in Path_elem)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end Path_elem_Equal;

function Path_elem_Init return Path_elem
is
    val: Path_elem;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := Letter_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end Path_elem_Init;

FUNCTION Path_elem_IsConstraintValid(val : in Path_elem) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 255)), ErrorCode => ERR_PATH_ELEM);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((((((((((((((((((((((((((((((((((((((((((val.Data(i1) = a)) OR ((val.Data(i1) = b)))) OR ((val.Data(i1) = c)))) OR ((val.Data(i1) = d)))) OR ((val.Data(i1) = e)))) OR ((val.Data(i1) = f)))) OR ((val.Data(i1) = g)))) OR ((val.Data(i1) = h)))) OR ((val.Data(i1) = i)))) OR ((val.Data(i1) = j)))) OR ((val.Data(i1) = k)))) OR ((val.Data(i1) = l)))) OR ((val.Data(i1) = m)))) OR ((val.Data(i1) = n)))) OR ((val.Data(i1) = o)))) OR ((val.Data(i1) = p)))) OR ((val.Data(i1) = q)))) OR ((val.Data(i1) = r)))) OR ((val.Data(i1) = s)))) OR ((val.Data(i1) = t)))) OR ((val.Data(i1) = u)))) OR ((val.Data(i1) = v)))) OR ((val.Data(i1) = w)))) OR ((val.Data(i1) = x)))) OR ((val.Data(i1) = y)))) OR ((val.Data(i1) = z))), ErrorCode => ERR_PATH_ELEM_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Path_elem_IsConstraintValid;



function LetterInt_Equal(val1, val2: in LetterInt)
    return Boolean 
is
begin
	return val1 = val2;

end LetterInt_Equal;

function LetterInt_Init return LetterInt
is
    val: LetterInt;
begin
    val := 0;
    return val;
end LetterInt_Init;

FUNCTION LetterInt_IsConstraintValid(val : in LetterInt) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 25), ErrorCode => ERR_LETTERINT);
    RETURN ret;
END LetterInt_IsConstraintValid;



function Cost_ty_Equal(val1, val2: in Cost_ty)
    return Boolean 
is
begin
	return val1 = val2;

end Cost_ty_Equal;

function Cost_ty_Init return Cost_ty
is
    val: Cost_ty;
begin
    val := 0;
    return val;
end Cost_ty_Init;

FUNCTION Cost_ty_IsConstraintValid(val : in Cost_ty) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_COST_TY);
    RETURN ret;
END Cost_ty_IsConstraintValid;



function Tree_Elem_Equal(val1, val2: in Tree_Elem)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.cost = val2.cost);

    if ret then
        ret := (val1.son = val2.son);

    end if;
	return ret;

end Tree_Elem_Equal;

function Tree_Elem_Init return Tree_Elem
is
    val: Tree_Elem;
begin

    --set cost 
    val.cost := Cost_ty_Init;
    --set son 
    val.son := Letter_Init;
    return val;
end Tree_Elem_Init;

FUNCTION Tree_Elem_IsConstraintValid(val : in Tree_Elem) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.cost <= 255), ErrorCode => ERR_TREE_ELEM_COST);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((((((((((((((((((((((((((((((((((((((((((val.son = a)) OR ((val.son = b)))) OR ((val.son = c)))) OR ((val.son = d)))) OR ((val.son = e)))) OR ((val.son = f)))) OR ((val.son = g)))) OR ((val.son = h)))) OR ((val.son = i)))) OR ((val.son = j)))) OR ((val.son = k)))) OR ((val.son = l)))) OR ((val.son = m)))) OR ((val.son = n)))) OR ((val.son = o)))) OR ((val.son = p)))) OR ((val.son = q)))) OR ((val.son = r)))) OR ((val.son = s)))) OR ((val.son = t)))) OR ((val.son = u)))) OR ((val.son = v)))) OR ((val.son = w)))) OR ((val.son = x)))) OR ((val.son = y)))) OR ((val.son = z))), ErrorCode => ERR_TREE_ELEM_SON);
    end if;

    RETURN ret;
END Tree_Elem_IsConstraintValid;



function Sons_Equal(val1, val2: in Sons)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := Tree_Elem_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end Sons_Equal;

function Sons_Init return Sons
is
    val: Sons;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := Tree_Elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end Sons_Init;

FUNCTION Sons_IsConstraintValid(val : in Sons) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_SONS);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1).cost <= 255), ErrorCode => ERR_SONS_ELM_COST);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((((((((((((((((((((((((((((((((((((((((((val.Data(i1).son = a)) OR ((val.Data(i1).son = b)))) OR ((val.Data(i1).son = c)))) OR ((val.Data(i1).son = d)))) OR ((val.Data(i1).son = e)))) OR ((val.Data(i1).son = f)))) OR ((val.Data(i1).son = g)))) OR ((val.Data(i1).son = h)))) OR ((val.Data(i1).son = i)))) OR ((val.Data(i1).son = j)))) OR ((val.Data(i1).son = k)))) OR ((val.Data(i1).son = l)))) OR ((val.Data(i1).son = m)))) OR ((val.Data(i1).son = n)))) OR ((val.Data(i1).son = o)))) OR ((val.Data(i1).son = p)))) OR ((val.Data(i1).son = q)))) OR ((val.Data(i1).son = r)))) OR ((val.Data(i1).son = s)))) OR ((val.Data(i1).son = t)))) OR ((val.Data(i1).son = u)))) OR ((val.Data(i1).son = v)))) OR ((val.Data(i1).son = w)))) OR ((val.Data(i1).son = x)))) OR ((val.Data(i1).son = y)))) OR ((val.Data(i1).son = z))), ErrorCode => ERR_SONS_ELM_SON);
        end if;

        i1 := i1+1;
    end loop;

    RETURN ret;
END Sons_IsConstraintValid;



function Tree_Equal(val1, val2: in Tree)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 26 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := Sons_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end Tree_Equal;

function Tree_Init return Tree
is
    val: Tree;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 26 loop
        pragma Loop_Invariant (i1 >=1 and i1<=26);
        val.Data(i1) := Sons_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end Tree_Init;

FUNCTION Tree_IsConstraintValid(val : in Tree) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 26 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 26);
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Data(i1).Length) AND (val.Data(i1).Length <= 100)), ErrorCode => ERR_TREE_ELM);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= val.Data(i1).Length loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= val.Data(i1).Length);
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1).Data(i2).cost <= 255), ErrorCode => ERR_TREE_ELM_ELM_COST);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((((((((((((((((((((((((((((((((((((((((((val.Data(i1).Data(i2).son = a)) OR ((val.Data(i1).Data(i2).son = b)))) OR ((val.Data(i1).Data(i2).son = c)))) OR ((val.Data(i1).Data(i2).son = d)))) OR ((val.Data(i1).Data(i2).son = e)))) OR ((val.Data(i1).Data(i2).son = f)))) OR ((val.Data(i1).Data(i2).son = g)))) OR ((val.Data(i1).Data(i2).son = h)))) OR ((val.Data(i1).Data(i2).son = i)))) OR ((val.Data(i1).Data(i2).son = j)))) OR ((val.Data(i1).Data(i2).son = k)))) OR ((val.Data(i1).Data(i2).son = l)))) OR ((val.Data(i1).Data(i2).son = m)))) OR ((val.Data(i1).Data(i2).son = n)))) OR ((val.Data(i1).Data(i2).son = o)))) OR ((val.Data(i1).Data(i2).son = p)))) OR ((val.Data(i1).Data(i2).son = q)))) OR ((val.Data(i1).Data(i2).son = r)))) OR ((val.Data(i1).Data(i2).son = s)))) OR ((val.Data(i1).Data(i2).son = t)))) OR ((val.Data(i1).Data(i2).son = u)))) OR ((val.Data(i1).Data(i2).son = v)))) OR ((val.Data(i1).Data(i2).son = w)))) OR ((val.Data(i1).Data(i2).son = x)))) OR ((val.Data(i1).Data(i2).son = y)))) OR ((val.Data(i1).Data(i2).son = z))), ErrorCode => ERR_TREE_ELM_ELM_SON);
            end if;

            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END Tree_IsConstraintValid;



function Path_Equal(val1, val2: in Path)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.cost = val2.cost);

    if ret then
        ret := Path_elem_Equal(val1.elem, val2.elem);

    end if;
	return ret;

end Path_Equal;

function Path_Init return Path
is
    val: Path;
begin

    --set cost 
    val.cost := Cost_ty_Init;
    --set elem 
    val.elem := Path_elem_Init;
    return val;
end Path_Init;

FUNCTION Path_IsConstraintValid(val : in Path) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.cost <= 255), ErrorCode => ERR_PATH_COST);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.elem.Length) AND (val.elem.Length <= 255)), ErrorCode => ERR_PATH_ELEM_2);
        i1 := val.elem.Data'First;
        while ret.Success and i1 <= val.elem.Length loop
            pragma Loop_Invariant (i1 >= val.elem.Data'First and i1 <= val.elem.Length);
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((((((((((((((((((((((((((((((((((((((((((((val.elem.Data(i1) = a)) OR ((val.elem.Data(i1) = b)))) OR ((val.elem.Data(i1) = c)))) OR ((val.elem.Data(i1) = d)))) OR ((val.elem.Data(i1) = e)))) OR ((val.elem.Data(i1) = f)))) OR ((val.elem.Data(i1) = g)))) OR ((val.elem.Data(i1) = h)))) OR ((val.elem.Data(i1) = i)))) OR ((val.elem.Data(i1) = j)))) OR ((val.elem.Data(i1) = k)))) OR ((val.elem.Data(i1) = l)))) OR ((val.elem.Data(i1) = m)))) OR ((val.elem.Data(i1) = n)))) OR ((val.elem.Data(i1) = o)))) OR ((val.elem.Data(i1) = p)))) OR ((val.elem.Data(i1) = q)))) OR ((val.elem.Data(i1) = r)))) OR ((val.elem.Data(i1) = s)))) OR ((val.elem.Data(i1) = t)))) OR ((val.elem.Data(i1) = u)))) OR ((val.elem.Data(i1) = v)))) OR ((val.elem.Data(i1) = w)))) OR ((val.elem.Data(i1) = x)))) OR ((val.elem.Data(i1) = y)))) OR ((val.elem.Data(i1) = z))), ErrorCode => ERR_PATH_ELEM_ELM_2);
            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END Path_IsConstraintValid;


 

END TASTE_Dataview;