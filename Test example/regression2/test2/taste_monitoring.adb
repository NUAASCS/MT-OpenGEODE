-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_MONITORING with SPARK_Mode IS




function TASTE_Peek_base_address_Equal(val1, val2: in TASTE_Peek_base_address)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_base_address_Equal;

function TASTE_Peek_offset_Equal(val1, val2: in TASTE_Peek_offset)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_offset_Equal;

function TASTE_Peek_base_type_Equal(val1, val2: in TASTE_Peek_base_type)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_base_type_Equal;

function TASTE_Peek_nb_of_elements_Equal(val1, val2: in TASTE_Peek_nb_of_elements)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_nb_of_elements_Equal;

function TASTE_Peek_sample_time_Equal(val1, val2: in TASTE_Peek_sample_time)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_sample_time_Equal;

function TASTE_Peek_Equal(val1, val2: in TASTE_Peek)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TASTE_Peek_base_address_Equal(val1.base_address, val2.base_address);

    if ret then
        ret := TASTE_Peek_offset_Equal(val1.offset, val2.offset);

        if ret then
            ret := TASTE_Peek_base_type_Equal(val1.base_type, val2.base_type);

            if ret then
                ret := TASTE_Peek_nb_of_elements_Equal(val1.nb_of_elements, val2.nb_of_elements);

                if ret then
                    ret := TASTE_Peek_sample_time_Equal(val1.sample_time, val2.sample_time);

                end if;
            end if;
        end if;
    end if;
	return ret;

end TASTE_Peek_Equal;

function TASTE_Peek_base_address_Init return TASTE_Peek_base_address
is
    val: TASTE_Peek_base_address;
begin
    val := 0;
    return val;
end TASTE_Peek_base_address_Init;
function TASTE_Peek_offset_Init return TASTE_Peek_offset
is
    val: TASTE_Peek_offset;
begin
    val := 0;
    return val;
end TASTE_Peek_offset_Init;
function TASTE_Peek_base_type_Init return TASTE_Peek_base_type
is
    val: TASTE_Peek_base_type;
begin
    val := int_32;
    return val;
end TASTE_Peek_base_type_Init;
function TASTE_Peek_nb_of_elements_Init return TASTE_Peek_nb_of_elements
is
    val: TASTE_Peek_nb_of_elements;
begin
    val := 1;
    return val;
end TASTE_Peek_nb_of_elements_Init;
function TASTE_Peek_sample_time_Init return TASTE_Peek_sample_time
is
    val: TASTE_Peek_sample_time;
begin
    val := 0;
    return val;
end TASTE_Peek_sample_time_Init;
function TASTE_Peek_Init return TASTE_Peek
is
    val: TASTE_Peek;
begin

    --set base_address 
    val.base_address := TASTE_Peek_base_address_Init;
    --set offset 
    val.offset := TASTE_Peek_offset_Init;
    --set base_type 
    val.base_type := TASTE_Peek_base_type_Init;
    --set nb_of_elements 
    val.nb_of_elements := TASTE_Peek_nb_of_elements_Init;
    --set sample_time 
    val.sample_time := TASTE_Peek_sample_time_Init;
    return val;
end TASTE_Peek_Init;

FUNCTION TASTE_Peek_IsConstraintValid(val : in TASTE_Peek) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.base_address <= 4294967295), ErrorCode => ERR_TASTE_PEEK_BASE_ADDRESS);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.offset) AND (val.offset <= 2147483647)), ErrorCode => ERR_TASTE_PEEK_OFFSET);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.base_type = int_32)) OR ((val.base_type = int_64)))) OR ((val.base_type = real_single)))) OR ((val.base_type = real_double)))) OR ((val.base_type = octet_string))), ErrorCode => ERR_TASTE_PEEK_BASE_TYPE);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.nb_of_elements) AND (val.nb_of_elements <= 10)), ErrorCode => ERR_TASTE_PEEK_NB_OF_ELEMENTS);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.sample_time <= 15), ErrorCode => ERR_TASTE_PEEK_SAMPLE_TIME);
                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END TASTE_Peek_IsConstraintValid;



function TASTE_Peek_list_Equal(val1, val2: in TASTE_Peek_list)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := TASTE_Peek_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TASTE_Peek_list_Equal;

function TASTE_Peek_list_Init return TASTE_Peek_list
is
    val: TASTE_Peek_list;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := TASTE_Peek_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end TASTE_Peek_list_Init;

FUNCTION TASTE_Peek_list_IsConstraintValid(val : in TASTE_Peek_list) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 5)), ErrorCode => ERR_TASTE_PEEK_LIST);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1).base_address <= 4294967295), ErrorCode => ERR_TASTE_PEEK_LIST_ELM_BASE_ADDRESS);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.Data(i1).offset) AND (val.Data(i1).offset <= 2147483647)), ErrorCode => ERR_TASTE_PEEK_LIST_ELM_OFFSET);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.Data(i1).base_type = int_32)) OR ((val.Data(i1).base_type = int_64)))) OR ((val.Data(i1).base_type = real_single)))) OR ((val.Data(i1).base_type = real_double)))) OR ((val.Data(i1).base_type = octet_string))), ErrorCode => ERR_TASTE_PEEK_LIST_ELM_BASE_TYPE);
                if ret.Success then
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Data(i1).nb_of_elements) AND (val.Data(i1).nb_of_elements <= 10)), ErrorCode => ERR_TASTE_PEEK_LIST_ELM_NB_OF_ELEMENTS);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1).sample_time <= 15), ErrorCode => ERR_TASTE_PEEK_LIST_ELM_SAMPLE_TIME);
                    end if;

                end if;

            end if;

        end if;

        i1 := i1+1;
    end loop;

    RETURN ret;
END TASTE_Peek_list_IsConstraintValid;



function TASTE_Peek_id_Equal(val1, val2: in TASTE_Peek_id)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_id_Equal;

function TASTE_Peek_id_Init return TASTE_Peek_id
is
    val: TASTE_Peek_id;
begin
    val := 0;
    return val;
end TASTE_Peek_id_Init;

FUNCTION TASTE_Peek_id_IsConstraintValid(val : in TASTE_Peek_id) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_TASTE_PEEK_ID);
    RETURN ret;
END TASTE_Peek_id_IsConstraintValid;



function TASTE_Peek_id_list_Equal(val1, val2: in TASTE_Peek_id_list)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TASTE_Peek_id_list_Equal;

function TASTE_Peek_id_list_Init return TASTE_Peek_id_list
is
    val: TASTE_Peek_id_list;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := TASTE_Peek_id_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end TASTE_Peek_id_list_Init;

FUNCTION TASTE_Peek_id_list_IsConstraintValid(val : in TASTE_Peek_id_list) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 10)), ErrorCode => ERR_TASTE_PEEK_ID_LIST);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 4294967295), ErrorCode => ERR_TASTE_PEEK_ID_LIST_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END TASTE_Peek_id_list_IsConstraintValid;



function TASTE_Monitoring_value_int_32_Equal(val1, val2: in TASTE_Monitoring_value_int_32)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Monitoring_value_int_32_Equal;

function TASTE_Monitoring_value_int_64_Equal(val1, val2: in TASTE_Monitoring_value_int_64)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Monitoring_value_int_64_Equal;

function TASTE_Monitoring_value_octet_string_Equal(val1, val2: in TASTE_Monitoring_value_octet_string)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end TASTE_Monitoring_value_octet_string_Equal;

function TASTE_Monitoring_value_Equal(val1, val2: in TASTE_Monitoring_value)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when int_32_PRESENT =>
                ret := (val1.int_32 = val2.int_32);
            when int_64_PRESENT =>
                ret := (val1.int_64 = val2.int_64);
            when real_single_PRESENT =>
                ret := (adaasn1rtl.Asn1Real_Equal(val1.real_single, val2.real_single));
            when real_double_PRESENT =>
                ret := (adaasn1rtl.Asn1Real_Equal(val1.real_double, val2.real_double));
            when octet_string_PRESENT =>
                ret := (val1.octet_string.Length = val2.octet_string.Length and then val1.octet_string.Data(1 .. val1.octet_string.Length) = val2.octet_string.Data(1 .. val2.octet_string.Length));
        end case;
    end if;
	return ret;

end TASTE_Monitoring_value_Equal;

function TASTE_Monitoring_value_int_32_Init return TASTE_Monitoring_value_int_32
is
    val: TASTE_Monitoring_value_int_32;
begin
    val := 0;
    return val;
end TASTE_Monitoring_value_int_32_Init;
function TASTE_Monitoring_value_int_64_Init return TASTE_Monitoring_value_int_64
is
    val: TASTE_Monitoring_value_int_64;
begin
    val := 0;
    return val;
end TASTE_Monitoring_value_int_64_Init;
function TASTE_Monitoring_value_octet_string_Init return TASTE_Monitoring_value_octet_string
is
    val: TASTE_Monitoring_value_octet_string;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 10;
    return val;
end TASTE_Monitoring_value_octet_string_Init;
function TASTE_Monitoring_value_Init return TASTE_Monitoring_value
is
    val: TASTE_Monitoring_value;
begin
    --set int_32 
    declare
        int_32_tmp:TASTE_Monitoring_value_int_32;
    begin
        val.int_32 := TASTE_Monitoring_value_int_32_Init;
        val := TASTE_Monitoring_value'(kind => int_32_PRESENT, int_32 => int_32_tmp);
    end;
    return val;
end TASTE_Monitoring_value_Init;

FUNCTION TASTE_Monitoring_value_IsConstraintValid(val : in TASTE_Monitoring_value) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN int_32_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.int_32) AND (val.int_32 <= 2147483647)), ErrorCode => ERR_TASTE_MONITORING_VALUE_INT_32);
        WHEN int_64_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (-9223372036854775807 <= val.int_64), ErrorCode => ERR_TASTE_MONITORING_VALUE_INT_64);
        WHEN real_single_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-9.99999999999999980000E+037 <= val.real_single) AND (val.real_single <= 9.99999999999999980000E+037)), ErrorCode => ERR_TASTE_MONITORING_VALUE_REAL_SINGLE);
        WHEN real_double_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val.real_double) AND (val.real_double <= 1.00000000000000000000E+308)), ErrorCode => ERR_TASTE_MONITORING_VALUE_REAL_DOUBLE);
        WHEN octet_string_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.octet_string.Length) AND (val.octet_string.Length <= 10)), ErrorCode => ERR_TASTE_MONITORING_VALUE_OCTET_STRING);
    end case;
    RETURN ret;
END TASTE_Monitoring_value_IsConstraintValid;



function TASTE_Monitoring_values_Equal(val1, val2: in TASTE_Monitoring_values)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := TASTE_Monitoring_value_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TASTE_Monitoring_values_Equal;

function TASTE_Monitoring_Equal(val1, val2: in TASTE_Monitoring)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.id = val2.id);

    if ret then
        ret := TASTE_Monitoring_values_Equal(val1.values, val2.values);

    end if;
	return ret;

end TASTE_Monitoring_Equal;

function TASTE_Monitoring_values_Init return TASTE_Monitoring_values
is
    val: TASTE_Monitoring_values;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := TASTE_Monitoring_value_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end TASTE_Monitoring_values_Init;
function TASTE_Monitoring_Init return TASTE_Monitoring
is
    val: TASTE_Monitoring;
begin

    --set id 
    val.id := TASTE_Peek_id_Init;
    --set values 
    val.values := TASTE_Monitoring_values_Init;
    return val;
end TASTE_Monitoring_Init;

FUNCTION TASTE_Monitoring_IsConstraintValid(val : in TASTE_Monitoring) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.id <= 4294967295), ErrorCode => ERR_TASTE_MONITORING_ID);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.values.Length) AND (val.values.Length <= 10)), ErrorCode => ERR_TASTE_MONITORING_VALUES);
        i1 := val.values.Data'First;
        while ret.Success and i1 <= val.values.Length loop
            pragma Loop_Invariant (i1 >= val.values.Data'First and i1 <= val.values.Length);
            case val.values.Data(i1).kind is
                WHEN int_32_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.values.Data(i1).int_32) AND (val.values.Data(i1).int_32 <= 2147483647)), ErrorCode => ERR_TASTE_MONITORING_VALUES_ELM_INT_32);
                WHEN int_64_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (-9223372036854775807 <= val.values.Data(i1).int_64), ErrorCode => ERR_TASTE_MONITORING_VALUES_ELM_INT_64);
                WHEN real_single_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-9.99999999999999980000E+037 <= val.values.Data(i1).real_single) AND (val.values.Data(i1).real_single <= 9.99999999999999980000E+037)), ErrorCode => ERR_TASTE_MONITORING_VALUES_ELM_REAL_SINGLE);
                WHEN real_double_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val.values.Data(i1).real_double) AND (val.values.Data(i1).real_double <= 1.00000000000000000000E+308)), ErrorCode => ERR_TASTE_MONITORING_VALUES_ELM_REAL_DOUBLE);
                WHEN octet_string_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.values.Data(i1).octet_string.Length) AND (val.values.Data(i1).octet_string.Length <= 10)), ErrorCode => ERR_TASTE_MONITORING_VALUES_ELM_OCTET_STRING);
            end case;
            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END TASTE_Monitoring_IsConstraintValid;



function TASTE_Monitoring_list_Equal(val1, val2: in TASTE_Monitoring_list)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := TASTE_Monitoring_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TASTE_Monitoring_list_Equal;

function TASTE_Monitoring_list_Init return TASTE_Monitoring_list
is
    val: TASTE_Monitoring_list;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := TASTE_Monitoring_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end TASTE_Monitoring_list_Init;

FUNCTION TASTE_Monitoring_list_IsConstraintValid(val : in TASTE_Monitoring_list) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 5)), ErrorCode => ERR_TASTE_MONITORING_LIST);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1).id <= 4294967295), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_ID);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Data(i1).values.Length) AND (val.Data(i1).values.Length <= 10)), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_VALUES);
            i2 := val.Data(i1).values.Data'First;
            while ret.Success and i2 <= val.Data(i1).values.Length loop
                pragma Loop_Invariant (i2 >= val.Data(i1).values.Data'First and i2 <= val.Data(i1).values.Length);
                case val.Data(i1).values.Data(i2).kind is
                    WHEN int_32_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.Data(i1).values.Data(i2).int_32) AND (val.Data(i1).values.Data(i2).int_32 <= 2147483647)), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_VALUES_ELM_INT_32);
                    WHEN int_64_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (-9223372036854775807 <= val.Data(i1).values.Data(i2).int_64), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_VALUES_ELM_INT_64);
                    WHEN real_single_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-9.99999999999999980000E+037 <= val.Data(i1).values.Data(i2).real_single) AND (val.Data(i1).values.Data(i2).real_single <= 9.99999999999999980000E+037)), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_VALUES_ELM_REAL_SINGLE);
                    WHEN real_double_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val.Data(i1).values.Data(i2).real_double) AND (val.Data(i1).values.Data(i2).real_double <= 1.00000000000000000000E+308)), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_VALUES_ELM_REAL_DOUBLE);
                    WHEN octet_string_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Data(i1).values.Data(i2).octet_string.Length) AND (val.Data(i1).values.Data(i2).octet_string.Length <= 10)), ErrorCode => ERR_TASTE_MONITORING_LIST_ELM_VALUES_ELM_OCTET_STRING);
                end case;
                i2 := i2+1;
            end loop;

        end if;

        i1 := i1+1;
    end loop;

    RETURN ret;
END TASTE_Monitoring_list_IsConstraintValid;



function TASTE_Poke_list_Equal(val1, val2: in TASTE_Poke_list) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := TASTE_Monitoring_list_Equal(val1, val2);
    return ret;
end TASTE_Poke_list_Equal;

function TASTE_Poke_list_Init return TASTE_Poke_list
is
    val: TASTE_Poke_list;
begin
    val := TASTE_Monitoring_list_Init;
    return val;
end TASTE_Poke_list_Init;

FUNCTION TASTE_Poke_list_IsConstraintValid(val : in TASTE_Poke_list) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 5)), ErrorCode => ERR_TASTE_POKE_LIST);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1).id <= 4294967295), ErrorCode => ERR_TASTE_POKE_LIST_ELM_ID);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Data(i1).values.Length) AND (val.Data(i1).values.Length <= 10)), ErrorCode => ERR_TASTE_POKE_LIST_ELM_VALUES);
            i2 := val.Data(i1).values.Data'First;
            while ret.Success and i2 <= val.Data(i1).values.Length loop
                pragma Loop_Invariant (i2 >= val.Data(i1).values.Data'First and i2 <= val.Data(i1).values.Length);
                case val.Data(i1).values.Data(i2).kind is
                    WHEN int_32_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.Data(i1).values.Data(i2).int_32) AND (val.Data(i1).values.Data(i2).int_32 <= 2147483647)), ErrorCode => ERR_TASTE_POKE_LIST_ELM_VALUES_ELM_INT_32);
                    WHEN int_64_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (-9223372036854775807 <= val.Data(i1).values.Data(i2).int_64), ErrorCode => ERR_TASTE_POKE_LIST_ELM_VALUES_ELM_INT_64);
                    WHEN real_single_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-9.99999999999999980000E+037 <= val.Data(i1).values.Data(i2).real_single) AND (val.Data(i1).values.Data(i2).real_single <= 9.99999999999999980000E+037)), ErrorCode => ERR_TASTE_POKE_LIST_ELM_VALUES_ELM_REAL_SINGLE);
                    WHEN real_double_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-1.00000000000000000000E+308 <= val.Data(i1).values.Data(i2).real_double) AND (val.Data(i1).values.Data(i2).real_double <= 1.00000000000000000000E+308)), ErrorCode => ERR_TASTE_POKE_LIST_ELM_VALUES_ELM_REAL_DOUBLE);
                    WHEN octet_string_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Data(i1).values.Data(i2).octet_string.Length) AND (val.Data(i1).values.Data(i2).octet_string.Length <= 10)), ErrorCode => ERR_TASTE_POKE_LIST_ELM_VALUES_ELM_OCTET_STRING);
                end case;
                i2 := i2+1;
            end loop;

        end if;

        i1 := i1+1;
    end loop;

    RETURN ret;
END TASTE_Poke_list_IsConstraintValid;



function TASTE_Peek_limit_Equal(val1, val2: in TASTE_Peek_limit)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_limit_Equal;

function TASTE_Peek_limit_Init return TASTE_Peek_limit
is
    val: TASTE_Peek_limit;
begin
    val := 0;
    return val;
end TASTE_Peek_limit_Init;

FUNCTION TASTE_Peek_limit_IsConstraintValid(val : in TASTE_Peek_limit) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 1000), ErrorCode => ERR_TASTE_PEEK_LIMIT);
    RETURN ret;
END TASTE_Peek_limit_IsConstraintValid;


 

END TASTE_MONITORING;