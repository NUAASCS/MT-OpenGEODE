-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY DataModel with SPARK_Mode IS




function TotoT3_Equal(val1, val2: in TotoT3)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.yy = val2.yy);

	return ret;

end TotoT3_Equal;

function TotoT3_Init return TotoT3
is
    val: TotoT3;
begin

    --set yy 
    val.yy := FALSE;
    return val;
end TotoT3_Init;

FUNCTION TotoT3_IsConstraintValid(val : in TotoT3) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TOTOT3_YY);
    RETURN ret;
END TotoT3_IsConstraintValid;



function TotoT1_Equal(val1, val2: in TotoT1)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TotoT3_Equal(val1.a, val2.a);

	return ret;

end TotoT1_Equal;

function TotoT1_Init return TotoT1
is
    val: TotoT1;
begin

    --set a 
    val.a := TotoT3_Init;
    return val;
end TotoT1_Init;

FUNCTION TotoT1_IsConstraintValid(val : in TotoT1) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TOTOT1_A_YY);
    RETURN ret;
END TotoT1_IsConstraintValid;



function TotoT2_choice_b_one_Equal(val1, val2: in TotoT2_choice_b_one)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TotoT1_Equal(val1.xx, val2.xx);

	return ret;

end TotoT2_choice_b_one_Equal;

function TotoT2_choice_b_Equal(val1, val2: in TotoT2_choice_b)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when one_PRESENT =>
                ret := TotoT1_Equal(val1.one.xx, val2.one.xx);

        end case;
    end if;
	return ret;

end TotoT2_choice_b_Equal;

function TotoT2_Equal(val1, val2: in TotoT2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when choice_a_PRESENT =>
                ret := (val1.choice_a = val2.choice_a);
            when choice_b_PRESENT =>
                ret := val1.choice_b.kind = val2.choice_b.kind;
                if ret then
                    case val1.choice_b.kind is
                        when one_PRESENT =>
                            ret := TotoT1_Equal(val1.choice_b.one.xx, val2.choice_b.one.xx);

                    end case;
                end if;
        end case;
    end if;
	return ret;

end TotoT2_Equal;

function TotoT2_choice_b_one_Init return TotoT2_choice_b_one
is
    val: TotoT2_choice_b_one;
begin

    --set xx 
    val.xx := TotoT1_Init;
    return val;
end TotoT2_choice_b_one_Init;
function TotoT2_choice_b_Init return TotoT2_choice_b
is
    val: TotoT2_choice_b;
begin
    --set one 
    declare
        one_tmp:TotoT2_choice_b_one;
    begin
        val.one := TotoT2_choice_b_one_Init;
        val := TotoT2_choice_b'(kind => one_PRESENT, one => one_tmp);
    end;
    return val;
end TotoT2_choice_b_Init;
function TotoT2_Init return TotoT2
is
    val: TotoT2;
begin
    --set choice_a 
    declare
        choice_a_tmp:adaasn1rtl.Asn1Boolean;
    begin
        choice_a_tmp := FALSE;
        val := TotoT2'(kind => choice_a_PRESENT, choice_a => choice_a_tmp);
    end;
    return val;
end TotoT2_Init;

FUNCTION TotoT2_IsConstraintValid(val : in TotoT2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN choice_a_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TOTOT2_CHOICE_A);
        WHEN choice_b_PRESENT =>
            case val.choice_b.kind is
                WHEN one_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TOTOT2_CHOICE_B_ONE_XX_A_YY);
            end case;
    end case;
    RETURN ret;
END TotoT2_IsConstraintValid;


 

END DataModel;