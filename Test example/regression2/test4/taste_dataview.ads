-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
--# inherit ;


PACKAGE TASTE_Dataview with SPARK_Mode
IS


-- MyComplexSeqOf --------------------------------------------
-- MyComplexSeqOf_elem --------------------------------------------
SUBTYPE MyComplexSeqOf_elem_x is adaasn1rtl.Asn1UInt range 0 .. 255;


TYPE MyComplexSeqOf_elem IS RECORD 
    x : MyComplexSeqOf_elem_x;
END RECORD;
SUBTYPE MyComplexSeqOf_index is integer range 1..2;
TYPE MyComplexSeqOf_array IS ARRAY (MyComplexSeqOf_index) OF MyComplexSeqOf_elem;
TYPE MyComplexSeqOf IS  RECORD
    Data  : MyComplexSeqOf_array;
END RECORD;

function MyComplexSeqOf_elem_x_Equal(val1, val2: in MyComplexSeqOf_elem_x) return Boolean;

function MyComplexSeqOf_elem_Equal(val1, val2: in MyComplexSeqOf_elem) return Boolean;

function MyComplexSeqOf_Equal(val1, val2: in MyComplexSeqOf) return Boolean;

function MyComplexSeqOf_elem_x_Init return MyComplexSeqOf_elem_x;
function MyComplexSeqOf_elem_Init return MyComplexSeqOf_elem;
function MyComplexSeqOf_Init return MyComplexSeqOf;

ERR_MYCOMPLEXSEQOF_ELM_X:CONSTANT INTEGER := 74; 
FUNCTION MyComplexSeqOf_IsConstraintValid(val : in MyComplexSeqOf) return adaasn1rtl.ASN1_RESULT;
-- MyComplexChoice --------------------------------------------
-- MyComplexChoice_a --------------------------------------------
SUBTYPE MyComplexChoice_a_x is adaasn1rtl.Asn1UInt range 0 .. 255;


TYPE MyComplexChoice_a IS RECORD 
    x : MyComplexChoice_a_x;
END RECORD;

SUBTYPE MyComplexChoice_index_range is integer range 0..0;

TYPE MyComplexChoice_selection IS (MyComplexChoice_a_PRESENT);
for MyComplexChoice_selection use
    (MyComplexChoice_a_PRESENT => 1);
for MyComplexChoice_selection'Size use 32;

TYPE MyComplexChoice(kind : MyComplexChoice_selection:= MyComplexChoice_a_PRESENT) IS 
RECORD
    case kind is
    when MyComplexChoice_a_PRESENT =>
            a: MyComplexChoice_a;
    end case;
END RECORD;

FOR MyComplexChoice USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function MyComplexChoice_a_x_Equal(val1, val2: in MyComplexChoice_a_x) return Boolean;

function MyComplexChoice_a_Equal(val1, val2: in MyComplexChoice_a) return Boolean;

function MyComplexChoice_Equal(val1, val2: in MyComplexChoice) return Boolean;

function MyComplexChoice_a_x_Init return MyComplexChoice_a_x;
function MyComplexChoice_a_Init return MyComplexChoice_a;
function MyComplexChoice_Init return MyComplexChoice;

ERR_MYCOMPLEXCHOICE:CONSTANT INTEGER := 106; 
ERR_MYCOMPLEXCHOICE_A_X:CONSTANT INTEGER := 93; 
FUNCTION MyComplexChoice_IsConstraintValid(val : in MyComplexChoice) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyInteger is adaasn1rtl.Asn1UInt range 0 .. 255;


function MyInteger_Equal(val1, val2: in MyInteger) return Boolean;

function MyInteger_Init return MyInteger;

ERR_MYINTEGER:CONSTANT INTEGER := 140; -- 
FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT;
-- DeepSeq --------------------------------------------
-- DeepSeq_a --------------------------------------------
-- DeepSeq_a_b --------------------------------------------
-- DeepSeq_a_b_d --------------------------------------------

SUBTYPE DeepSeq_a_b_d_index_range is integer range 0..0;

TYPE DeepSeq_a_b_d_selection IS (e_PRESENT);
for DeepSeq_a_b_d_selection use
    (e_PRESENT => 1);
for DeepSeq_a_b_d_selection'Size use 32;

TYPE DeepSeq_a_b_d(kind : DeepSeq_a_b_d_selection:= e_PRESENT) IS 
RECORD
    case kind is
    when e_PRESENT =>
            e: adaasn1rtl.Asn1Boolean;
    end case;
END RECORD;

FOR DeepSeq_a_b_d USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

TYPE DeepSeq_a_b IS RECORD 
    c : MyInteger;
    d : DeepSeq_a_b_d;
END RECORD;

TYPE DeepSeq_a IS RECORD 
    b : DeepSeq_a_b;
END RECORD;

TYPE DeepSeq IS RECORD 
    a : DeepSeq_a;
END RECORD;

function DeepSeq_a_b_d_Equal(val1, val2: in DeepSeq_a_b_d) return Boolean;

function DeepSeq_a_b_Equal(val1, val2: in DeepSeq_a_b) return Boolean;

function DeepSeq_a_Equal(val1, val2: in DeepSeq_a) return Boolean;

function DeepSeq_Equal(val1, val2: in DeepSeq) return Boolean;

function DeepSeq_a_b_d_Init return DeepSeq_a_b_d;
function DeepSeq_a_b_Init return DeepSeq_a_b;
function DeepSeq_a_Init return DeepSeq_a;
function DeepSeq_Init return DeepSeq;

ERR_DEEPSEQ_A_B_C:CONSTANT INTEGER := 1; 
ERR_DEEPSEQ_A_B_D:CONSTANT INTEGER := 19; 
ERR_DEEPSEQ_A_B_D_E:CONSTANT INTEGER := 12; 
FUNCTION DeepSeq_IsConstraintValid(val : in DeepSeq) return adaasn1rtl.ASN1_RESULT;
-- MyComplexType --------------------------------------------
-- MyComplexType_a --------------------------------------------
SUBTYPE MyComplexType_a_x is adaasn1rtl.Asn1UInt range 0 .. 255;


TYPE MyComplexType_a IS RECORD 
    x : MyComplexType_a_x;
    y : MyInteger;
END RECORD;

TYPE MyComplexType IS RECORD 
    a : MyComplexType_a;
END RECORD;

function MyComplexType_a_x_Equal(val1, val2: in MyComplexType_a_x) return Boolean;

function MyComplexType_a_Equal(val1, val2: in MyComplexType_a) return Boolean;

function MyComplexType_Equal(val1, val2: in MyComplexType) return Boolean;

function MyComplexType_a_x_Init return MyComplexType_a_x;
function MyComplexType_a_Init return MyComplexType_a;
function MyComplexType_Init return MyComplexType;

ERR_MYCOMPLEXTYPE_A_X:CONSTANT INTEGER := 44; 
ERR_MYCOMPLEXTYPE_A_Y:CONSTANT INTEGER := 51; 
FUNCTION MyComplexType_IsConstraintValid(val : in MyComplexType) return adaasn1rtl.ASN1_RESULT;
-- MySeq --------------------------------------------
SUBTYPE MySeq_b_index_range is integer range 0..2;
TYPE MySeq_b IS (taste, welcomes, you) with Convention => C;
for MySeq_b use
    (taste => 1, welcomes => 2, you => 3);

TYPE MySeq IS RECORD 
    a : MyInteger;
    b : MySeq_b;
END RECORD;

function MySeq_b_Equal(val1, val2: in MySeq_b) return Boolean;

function MySeq_Equal(val1, val2: in MySeq) return Boolean;

function MySeq_b_Init return MySeq_b;
function MySeq_Init return MySeq;

ERR_MYSEQ_A:CONSTANT INTEGER := 161; 
ERR_MYSEQ_B:CONSTANT INTEGER := 172; 
FUNCTION MySeq_IsConstraintValid(val : in MySeq) return adaasn1rtl.ASN1_RESULT;
-- MyChoice --------------------------------------------

SUBTYPE MyChoice_index_range is integer range 0..1;

TYPE MyChoice_selection IS (MyChoice_a_PRESENT, b_PRESENT);
for MyChoice_selection use
    (MyChoice_a_PRESENT => 1, b_PRESENT => 2);
for MyChoice_selection'Size use 32;

TYPE MyChoice(kind : MyChoice_selection:= MyChoice_a_PRESENT) IS 
RECORD
    case kind is
    when MyChoice_a_PRESENT =>
            a: adaasn1rtl.Asn1Boolean;
    when b_PRESENT =>
            b: MySeq;
    end case;
END RECORD;

FOR MyChoice USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function MyChoice_Equal(val1, val2: in MyChoice) return Boolean;

function MyChoice_Init return MyChoice;

ERR_MYCHOICE:CONSTANT INTEGER := 220; 
ERR_MYCHOICE_A:CONSTANT INTEGER := 185; 
ERR_MYCHOICE_B_A:CONSTANT INTEGER := 192; 
ERR_MYCHOICE_B_B:CONSTANT INTEGER := 203; 
FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyReal is adaasn1rtl.Asn1Real;


function MyReal_Equal(val1, val2: in MyReal) return Boolean;

function MyReal_Init return MyReal;

ERR_MYREAL:CONSTANT INTEGER := 147; -- 
FUNCTION MyReal_IsConstraintValid(val : in MyReal) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyEnum_index_range is integer range 0..2;
TYPE MyEnum IS (hello, world, howareyou) with Convention => C;
for MyEnum use
    (hello => 0, world => 1, howareyou => 2);

function MyEnum_Equal(val1, val2: in MyEnum) return Boolean;

function MyEnum_Init return MyEnum;

ERR_MYENUM:CONSTANT INTEGER := 154; -- 
FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT;
-- MySeqOf --------------------------------------------
SUBTYPE MySeqOf_index is integer range 1..2;
TYPE MySeqOf_array IS ARRAY (MySeqOf_index) OF MyEnum;
TYPE MySeqOf IS  RECORD
    Data  : MySeqOf_array;
END RECORD;

function MySeqOf_Equal(val1, val2: in MySeqOf) return Boolean;

function MySeqOf_Init return MySeqOf;

ERR_MYSEQOF_ELM:CONSTANT INTEGER := 227; 
FUNCTION MySeqOf_IsConstraintValid(val : in MySeqOf) return adaasn1rtl.ASN1_RESULT;
-- MyRefSeqOf --------------------------------------------

TYPE MyRefSeqOf IS RECORD 
    seqof : MySeqOf;
END RECORD;

function MyRefSeqOf_Equal(val1, val2: in MyRefSeqOf) return Boolean;

function MyRefSeqOf_Init return MyRefSeqOf;

ERR_MYREFSEQOF_SEQOF_ELM:CONSTANT INTEGER := 113; 
FUNCTION MyRefSeqOf_IsConstraintValid(val : in MyRefSeqOf) return adaasn1rtl.ASN1_RESULT;
-- MyPossiblyEmptySeqOf --------------------------------------------
SUBTYPE MyPossiblyEmptySeqOf_elem is adaasn1rtl.Asn1UInt range 1 .. 2;

SUBTYPE MyPossiblyEmptySeqOf_index is integer range 1..2;
TYPE MyPossiblyEmptySeqOf_array IS ARRAY (MyPossiblyEmptySeqOf_index) OF MyPossiblyEmptySeqOf_elem;
SUBTYPE MyPossiblyEmptySeqOf_length_index is integer range 0..2;
TYPE MyPossiblyEmptySeqOf IS  RECORD
    Length : MyPossiblyEmptySeqOf_length_index;
    Data  : MyPossiblyEmptySeqOf_array;
END RECORD;

function MyPossiblyEmptySeqOf_elem_Equal(val1, val2: in MyPossiblyEmptySeqOf_elem) return Boolean;

function MyPossiblyEmptySeqOf_Equal(val1, val2: in MyPossiblyEmptySeqOf) return Boolean;

function MyPossiblyEmptySeqOf_elem_Init return MyPossiblyEmptySeqOf_elem;
function MyPossiblyEmptySeqOf_Init return MyPossiblyEmptySeqOf;

ERR_MYPOSSIBLYEMPTYSEQOF_ELM:CONSTANT INTEGER := 244; 
ERR_MYPOSSIBLYEMPTYSEQOF:CONSTANT INTEGER := 251; 
FUNCTION MyPossiblyEmptySeqOf_IsConstraintValid(val : in MyPossiblyEmptySeqOf) return adaasn1rtl.ASN1_RESULT;
-- MySeqWithEmbeddedSeqOf --------------------------------------------
-- MySeqWithEmbeddedSeqOf_a --------------------------------------------
SUBTYPE MySeqWithEmbeddedSeqOf_a_index is integer range 1..2;
TYPE MySeqWithEmbeddedSeqOf_a_array IS ARRAY (MySeqWithEmbeddedSeqOf_a_index) OF adaasn1rtl.Asn1Boolean;
SUBTYPE MySeqWithEmbeddedSeqOf_a_length_index is integer range 0..2;
TYPE MySeqWithEmbeddedSeqOf_a IS  RECORD
    Length : MySeqWithEmbeddedSeqOf_a_length_index;
    Data  : MySeqWithEmbeddedSeqOf_a_array;
END RECORD;

TYPE MySeqWithEmbeddedSeqOf IS RECORD 
    a : MySeqWithEmbeddedSeqOf_a;
END RECORD;

function MySeqWithEmbeddedSeqOf_a_Equal(val1, val2: in MySeqWithEmbeddedSeqOf_a) return Boolean;

function MySeqWithEmbeddedSeqOf_Equal(val1, val2: in MySeqWithEmbeddedSeqOf) return Boolean;

function MySeqWithEmbeddedSeqOf_a_Init return MySeqWithEmbeddedSeqOf_a;
function MySeqWithEmbeddedSeqOf_Init return MySeqWithEmbeddedSeqOf;

ERR_MYSEQWITHEMBEDDEDSEQOF_A_ELM:CONSTANT INTEGER := 258; 
ERR_MYSEQWITHEMBEDDEDSEQOF_A:CONSTANT INTEGER := 265; 
FUNCTION MySeqWithEmbeddedSeqOf_IsConstraintValid(val : in MySeqWithEmbeddedSeqOf) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyOctStr_index is integer range 1..3;
SUBTYPE MyOctStr_array IS adaasn1rtl.OctetBuffer(MyOctStr_index);
TYPE MyOctStr IS  RECORD
    Data  : MyOctStr_array;
END RECORD;

function MyOctStr_Equal(val1, val2: in MyOctStr) return Boolean;

function MyOctStr_Init return MyOctStr;

 

private
   --# hide TASTE_Dataview;


END TASTE_Dataview;