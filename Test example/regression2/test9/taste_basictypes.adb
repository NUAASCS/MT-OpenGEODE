-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_BasicTypes with SPARK_Mode IS




function T_Int32_Equal(val1, val2: in T_Int32)
    return Boolean 
is
begin
	return val1 = val2;

end T_Int32_Equal;

function T_Int32_Init return T_Int32
is
    val: T_Int32;
begin
    val := 0;
    return val;
end T_Int32_Init;

FUNCTION T_Int32_IsConstraintValid(val : in T_Int32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val) AND (val <= 2147483647)), ErrorCode => ERR_T_INT32);
    RETURN ret;
END T_Int32_IsConstraintValid;



function T_UInt32_Equal(val1, val2: in T_UInt32)
    return Boolean 
is
begin
	return val1 = val2;

end T_UInt32_Equal;

function T_UInt32_Init return T_UInt32
is
    val: T_UInt32;
begin
    val := 0;
    return val;
end T_UInt32_Init;

FUNCTION T_UInt32_IsConstraintValid(val : in T_UInt32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_T_UINT32);
    RETURN ret;
END T_UInt32_IsConstraintValid;



function T_Int8_Equal(val1, val2: in T_Int8)
    return Boolean 
is
begin
	return val1 = val2;

end T_Int8_Equal;

function T_Int8_Init return T_Int8
is
    val: T_Int8;
begin
    val := 0;
    return val;
end T_Int8_Init;

FUNCTION T_Int8_IsConstraintValid(val : in T_Int8) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-128 <= val) AND (val <= 127)), ErrorCode => ERR_T_INT8);
    RETURN ret;
END T_Int8_IsConstraintValid;



function T_UInt8_Equal(val1, val2: in T_UInt8)
    return Boolean 
is
begin
	return val1 = val2;

end T_UInt8_Equal;

function T_UInt8_Init return T_UInt8
is
    val: T_UInt8;
begin
    val := 0;
    return val;
end T_UInt8_Init;

FUNCTION T_UInt8_IsConstraintValid(val : in T_UInt8) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_T_UINT8);
    RETURN ret;
END T_UInt8_IsConstraintValid;



function T_Boolean_Equal(val1, val2: in T_Boolean)
    return Boolean 
is
begin
	return val1 = val2;

end T_Boolean_Equal;

function T_Boolean_Init return T_Boolean
is
    val: T_Boolean;
begin
    val := FALSE;
    return val;
end T_Boolean_Init;

FUNCTION T_Boolean_IsConstraintValid(val : in T_Boolean) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_T_BOOLEAN);
    RETURN ret;
END T_Boolean_IsConstraintValid;



function BitString_Equal(val1, val2: in BitString)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end BitString_Equal;

function BitString_Init return BitString
is
    val: BitString;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 32 loop
        pragma Loop_Invariant (i1 >=1 and i1<=32);
        val.Data(i1) := adaasn1rtl.BIT(0);
        i1 := i1 + 1;
    end loop;

    return val;
end BitString_Init;



function OctString_Equal(val1, val2: in OctString)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end OctString_Equal;

function OctString_Init return OctString
is
    val: OctString;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

    return val;
end OctString_Init;



function SeqBit_Equal(val1, val2: in SeqBit)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 32 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end SeqBit_Equal;

function SeqBit_Init return SeqBit
is
    val: SeqBit;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 32 loop
        pragma Loop_Invariant (i1 >=1 and i1<=32);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end SeqBit_Init;

FUNCTION SeqBit_IsConstraintValid(val : in SeqBit) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 32 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 32);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBIT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBit_IsConstraintValid;



function SeqBit2_Equal(val1, val2: in SeqBit2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqBit2_Equal;

function SeqBit2_Init return SeqBit2
is
    val: SeqBit2;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 32 loop
        pragma Loop_Invariant (i1 >=1 and i1<=32);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqBit2_Init;

FUNCTION SeqBit2_IsConstraintValid(val : in SeqBit2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 32)), ErrorCode => ERR_SEQBIT2);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBIT2_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBit2_IsConstraintValid;



function Int32_Equal(val1, val2: in Int32)
    return Boolean 
is
begin
	return val1 = val2;

end Int32_Equal;

function Int32_Init return Int32
is
    val: Int32;
begin
    val := 0;
    return val;
end Int32_Init;

FUNCTION Int32_IsConstraintValid(val : in Int32) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val) AND (val <= 2147483647)), ErrorCode => ERR_INT32);
    RETURN ret;
END Int32_IsConstraintValid;



function Point_Equal(val1, val2: in Point)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.x = val2.x);

    if ret then
        ret := (val1.y = val2.y);

    end if;
	return ret;

end Point_Equal;

function Point_Init return Point
is
    val: Point;
begin

    --set x 
    val.x := Int32_Init;
    --set y 
    val.y := Int32_Init;
    return val;
end Point_Init;

FUNCTION Point_IsConstraintValid(val : in Point) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.x) AND (val.x <= 2147483647)), ErrorCode => ERR_POINT_X);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.y) AND (val.y <= 2147483647)), ErrorCode => ERR_POINT_Y);
    end if;

    RETURN ret;
END Point_IsConstraintValid;



function List_Equal(val1, val2: in List)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end List_Equal;

function List_Init return List
is
    val: List;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := Int32_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end List_Init;

FUNCTION List_IsConstraintValid(val : in List) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.Data(i1)) AND (val.Data(i1) <= 2147483647)), ErrorCode => ERR_LIST_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END List_IsConstraintValid;



function Nested_a_b_c_Equal(val1, val2: in Nested_a_b_c)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Point_Equal(val1.p, val2.p);

    if ret then
        ret := List_Equal(val1.l, val2.l);

    end if;
	return ret;

end Nested_a_b_c_Equal;

function Nested_a_b_Equal(val1, val2: in Nested_a_b)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Nested_a_b_c_Equal(val1.c, val2.c);

	return ret;

end Nested_a_b_Equal;

function Nested_a_Equal(val1, val2: in Nested_a)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Nested_a_b_Equal(val1.b, val2.b);

	return ret;

end Nested_a_Equal;

function Nested_Equal(val1, val2: in Nested)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Nested_a_Equal(val1.a, val2.a);

	return ret;

end Nested_Equal;

function Nested_a_b_c_Init return Nested_a_b_c
is
    val: Nested_a_b_c;
begin

    --set p 
    val.p := Point_Init;
    --set l 
    val.l := List_Init;
    return val;
end Nested_a_b_c_Init;
function Nested_a_b_Init return Nested_a_b
is
    val: Nested_a_b;
begin

    --set c 
    val.c := Nested_a_b_c_Init;
    return val;
end Nested_a_b_Init;
function Nested_a_Init return Nested_a
is
    val: Nested_a;
begin

    --set b 
    val.b := Nested_a_b_Init;
    return val;
end Nested_a_Init;
function Nested_Init return Nested
is
    val: Nested;
begin

    --set a 
    val.a := Nested_a_Init;
    return val;
end Nested_Init;

FUNCTION Nested_IsConstraintValid(val : in Nested) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.a.b.c.p.x) AND (val.a.b.c.p.x <= 2147483647)), ErrorCode => ERR_NESTED_A_B_C_P_X);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.a.b.c.p.y) AND (val.a.b.c.p.y <= 2147483647)), ErrorCode => ERR_NESTED_A_B_C_P_Y);
    end if;

    if ret.Success then
        i1 := val.a.b.c.l.Data'First;
        while ret.Success and i1 <= 2 loop
            pragma Loop_Invariant (i1 >= val.a.b.c.l.Data'First and i1 <= 2);
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((-2147483648 <= val.a.b.c.l.Data(i1)) AND (val.a.b.c.l.Data(i1) <= 2147483647)), ErrorCode => ERR_NESTED_A_B_C_L_ELM);
            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END Nested_IsConstraintValid;


 

END TASTE_BasicTypes;