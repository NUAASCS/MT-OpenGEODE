-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH CcsdsSoisSubnetwork;
use type CcsdsSoisSubnetwork.OctetTypeT;
use type CcsdsSoisSubnetwork.OctetTypeT;
use type CcsdsSoisSubnetwork.OctetTypeT;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY Demo with SPARK_Mode IS




function TelecommandUserDataTypeBodyT_userData_Equal(val1, val2: in TelecommandUserDataTypeBodyT_userData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TelecommandUserDataTypeBodyT_userData_Equal;

function TelecommandUserDataTypeBodyT_Equal(val1, val2: in TelecommandUserDataTypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TelecommandUserDataTypeBodyT_userData_Equal(val1.userData, val2.userData);

	return ret;

end TelecommandUserDataTypeBodyT_Equal;

function TelecommandUserDataTypeBodyT_userData_Init return TelecommandUserDataTypeBodyT_userData
is
    val: TelecommandUserDataTypeBodyT_userData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := CcsdsSoisSubnetwork.OctetTypeT_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end TelecommandUserDataTypeBodyT_userData_Init;
function TelecommandUserDataTypeBodyT_Init return TelecommandUserDataTypeBodyT
is
    val: TelecommandUserDataTypeBodyT;
begin

    --set userData 
    val.userData := TelecommandUserDataTypeBodyT_userData_Init;
    return val;
end TelecommandUserDataTypeBodyT_Init;

FUNCTION TelecommandUserDataTypeBodyT_IsConstraintValid(val : in TelecommandUserDataTypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.userData.Length) AND (val.userData.Length <= 255)), ErrorCode => ERR_TELECOMMANDUSERDATATYPEBODYT_USERDATA);
    i1 := val.userData.Data'First;
    while ret.Success and i1 <= val.userData.Length loop
        pragma Loop_Invariant (i1 >= val.userData.Data'First and i1 <= val.userData.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.userData.Data(i1) <= 255), ErrorCode => ERR_TELECOMMANDUSERDATATYPEBODYT_USERDATA_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END TelecommandUserDataTypeBodyT_IsConstraintValid;



function StatusFlag1TypeT_Equal(val1, val2: in StatusFlag1TypeT)
    return Boolean 
is
begin
	return val1 = val2;

end StatusFlag1TypeT_Equal;

function StatusFlag1TypeT_Init return StatusFlag1TypeT
is
    val: StatusFlag1TypeT;
begin
    val := FALSE;
    return val;
end StatusFlag1TypeT_Init;

FUNCTION StatusFlag1TypeT_IsConstraintValid(val : in StatusFlag1TypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_STATUSFLAG1TYPET);
    RETURN ret;
END StatusFlag1TypeT_IsConstraintValid;



function StatusFlag2TypeT_Equal(val1, val2: in StatusFlag2TypeT)
    return Boolean 
is
begin
	return val1 = val2;

end StatusFlag2TypeT_Equal;

function StatusFlag2TypeT_Init return StatusFlag2TypeT
is
    val: StatusFlag2TypeT;
begin
    val := FALSE;
    return val;
end StatusFlag2TypeT_Init;

FUNCTION StatusFlag2TypeT_IsConstraintValid(val : in StatusFlag2TypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_STATUSFLAG2TYPET);
    RETURN ret;
END StatusFlag2TypeT_IsConstraintValid;



function CalibratedHKTypeT_Equal(val1, val2: in CalibratedHKTypeT)
    return Boolean 
is
begin
	return adaasn1rtl.Asn1Real_Equal(val1, val2);

end CalibratedHKTypeT_Equal;

function CalibratedHKTypeT_Init return CalibratedHKTypeT
is
    val: CalibratedHKTypeT;
begin
    val := 0.00000000000000000000E+000;
    return val;
end CalibratedHKTypeT_Init;

FUNCTION CalibratedHKTypeT_IsConstraintValid(val : in CalibratedHKTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((-3.40282346638528860000E+038 <= val) AND (val <= 3.40282346638528860000E+038)), ErrorCode => ERR_CALIBRATEDHKTYPET);
    RETURN ret;
END CalibratedHKTypeT_IsConstraintValid;



function QueryCountTypeT_Equal(val1, val2: in QueryCountTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end QueryCountTypeT_Equal;

function QueryCountTypeT_Init return QueryCountTypeT
is
    val: QueryCountTypeT;
begin
    val := 0;
    return val;
end QueryCountTypeT_Init;

FUNCTION QueryCountTypeT_IsConstraintValid(val : in QueryCountTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_QUERYCOUNTTYPET);
    RETURN ret;
END QueryCountTypeT_IsConstraintValid;



function ExtendedModeTypeT_Equal(val1, val2: in ExtendedModeTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end ExtendedModeTypeT_Equal;

function ExtendedModeTypeT_Init return ExtendedModeTypeT
is
    val: ExtendedModeTypeT;
begin
    val := 0;
    return val;
end ExtendedModeTypeT_Init;

FUNCTION ExtendedModeTypeT_IsConstraintValid(val : in ExtendedModeTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_EXTENDEDMODETYPET);
    RETURN ret;
END ExtendedModeTypeT_IsConstraintValid;



function ExtendedModeUnionTypeBodyT_Equal(val1, val2: in ExtendedModeUnionTypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.mode = val2.mode);

	return ret;

end ExtendedModeUnionTypeBodyT_Equal;

function ExtendedModeUnionTypeBodyT_Init return ExtendedModeUnionTypeBodyT
is
    val: ExtendedModeUnionTypeBodyT;
begin

    --set mode 
    val.mode := ExtendedModeTypeT_Init;
    return val;
end ExtendedModeUnionTypeBodyT_Init;

FUNCTION ExtendedModeUnionTypeBodyT_IsConstraintValid(val : in ExtendedModeUnionTypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.mode <= 255), ErrorCode => ERR_EXTENDEDMODEUNIONTYPEBODYT_MODE);
    RETURN ret;
END ExtendedModeUnionTypeBodyT_IsConstraintValid;



function ExtendedStatusTypeT_Equal(val1, val2: in ExtendedStatusTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end ExtendedStatusTypeT_Equal;

function ExtendedStatusTypeT_Init return ExtendedStatusTypeT
is
    val: ExtendedStatusTypeT;
begin
    val := 0;
    return val;
end ExtendedStatusTypeT_Init;

FUNCTION ExtendedStatusTypeT_IsConstraintValid(val : in ExtendedStatusTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_EXTENDEDSTATUSTYPET);
    RETURN ret;
END ExtendedStatusTypeT_IsConstraintValid;



function ExtendedStatusUnionTypeBodyT_Equal(val1, val2: in ExtendedStatusUnionTypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.status = val2.status);

	return ret;

end ExtendedStatusUnionTypeBodyT_Equal;

function ExtendedStatusUnionTypeBodyT_Init return ExtendedStatusUnionTypeBodyT
is
    val: ExtendedStatusUnionTypeBodyT;
begin

    --set status 
    val.status := ExtendedStatusTypeT_Init;
    return val;
end ExtendedStatusUnionTypeBodyT_Init;

FUNCTION ExtendedStatusUnionTypeBodyT_IsConstraintValid(val : in ExtendedStatusUnionTypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.status <= 255), ErrorCode => ERR_EXTENDEDSTATUSUNIONTYPEBODYT_STATUS);
    RETURN ret;
END ExtendedStatusUnionTypeBodyT_IsConstraintValid;



function ExtendedStatusOrModeTypeT_body_choice_Equal(val1, val2: in ExtendedStatusOrModeTypeT_body_choice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when ExtendedStatusOrModeTypeT_body_choice_mode_PRESENT =>
                ret := ExtendedModeUnionTypeBodyT_Equal(val1.mode, val2.mode);
            when body_choice_status_PRESENT =>
                ret := ExtendedStatusUnionTypeBodyT_Equal(val1.status, val2.status);
        end case;
    end if;
	return ret;

end ExtendedStatusOrModeTypeT_body_choice_Equal;

function ExtendedStatusOrModeTypeT_Equal(val1, val2: in ExtendedStatusOrModeTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.queryCount = val2.queryCount);

    if ret then
        ret := ExtendedStatusOrModeTypeT_body_choice_Equal(val1.body_choice, val2.body_choice);

    end if;
	return ret;

end ExtendedStatusOrModeTypeT_Equal;

function ExtendedStatusOrModeTypeT_body_choice_Init return ExtendedStatusOrModeTypeT_body_choice
is
    val: ExtendedStatusOrModeTypeT_body_choice;
begin
    --set mode 
    declare
        mode_tmp:ExtendedModeUnionTypeBodyT;
    begin
        mode_tmp := ExtendedModeUnionTypeBodyT_Init;
        val := ExtendedStatusOrModeTypeT_body_choice'(kind => ExtendedStatusOrModeTypeT_body_choice_mode_PRESENT, mode => mode_tmp);
    end;
    return val;
end ExtendedStatusOrModeTypeT_body_choice_Init;
function ExtendedStatusOrModeTypeT_Init return ExtendedStatusOrModeTypeT
is
    val: ExtendedStatusOrModeTypeT;
begin

    --set queryCount 
    val.queryCount := QueryCountTypeT_Init;
    --set body_choice 
    val.body_choice := ExtendedStatusOrModeTypeT_body_choice_Init;
    return val;
end ExtendedStatusOrModeTypeT_Init;

FUNCTION ExtendedStatusOrModeTypeT_IsConstraintValid(val : in ExtendedStatusOrModeTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.queryCount <= 255), ErrorCode => ERR_EXTENDEDSTATUSORMODETYPET_QUERYCOUNT);
    if ret.Success then
        case val.body_choice.kind is
            WHEN ExtendedStatusOrModeTypeT_body_choice_mode_PRESENT =>
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.mode.mode <= 255), ErrorCode => ERR_EXTENDEDSTATUSORMODETYPET_BODY_CHOICE_MODE_MODE);
            WHEN body_choice_status_PRESENT =>
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.status.status <= 255), ErrorCode => ERR_EXTENDEDSTATUSORMODETYPET_BODY_CHOICE_STATUS_STATUS);
        end case;
    end if;

    RETURN ret;
END ExtendedStatusOrModeTypeT_IsConstraintValid;



function HKTypeT_Equal(val1, val2: in HKTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end HKTypeT_Equal;

function HKTypeT_Init return HKTypeT
is
    val: HKTypeT;
begin
    val := 0;
    return val;
end HKTypeT_Init;

FUNCTION HKTypeT_IsConstraintValid(val : in HKTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_HKTYPET);
    RETURN ret;
END HKTypeT_IsConstraintValid;



function TelemetrySet1TypeT_Equal(val1, val2: in TelemetrySet1TypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.hk1 = val2.hk1);

    if ret then
        ret := (val1.hk2 = val2.hk2);

    end if;
	return ret;

end TelemetrySet1TypeT_Equal;

function TelemetrySet1TypeT_Init return TelemetrySet1TypeT
is
    val: TelemetrySet1TypeT;
begin

    --set hk1 
    val.hk1 := HKTypeT_Init;
    --set hk2 
    val.hk2 := HKTypeT_Init;
    return val;
end TelemetrySet1TypeT_Init;

FUNCTION TelemetrySet1TypeT_IsConstraintValid(val : in TelemetrySet1TypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.hk1 <= 255), ErrorCode => ERR_TELEMETRYSET1TYPET_HK1);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.hk2 <= 255), ErrorCode => ERR_TELEMETRYSET1TYPET_HK2);
    end if;

    RETURN ret;
END TelemetrySet1TypeT_IsConstraintValid;



function Telemetry1TypeBodyT_Equal(val1, val2: in Telemetry1TypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TelemetrySet1TypeT_Equal(val1.telemetrySet, val2.telemetrySet);

	return ret;

end Telemetry1TypeBodyT_Equal;

function Telemetry1TypeBodyT_Init return Telemetry1TypeBodyT
is
    val: Telemetry1TypeBodyT;
begin

    --set telemetrySet 
    val.telemetrySet := TelemetrySet1TypeT_Init;
    return val;
end Telemetry1TypeBodyT_Init;

FUNCTION Telemetry1TypeBodyT_IsConstraintValid(val : in Telemetry1TypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk1 <= 255), ErrorCode => ERR_TELEMETRY1TYPEBODYT_TELEMETRYSET_HK1);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk2 <= 255), ErrorCode => ERR_TELEMETRY1TYPEBODYT_TELEMETRYSET_HK2);
    end if;

    RETURN ret;
END Telemetry1TypeBodyT_IsConstraintValid;



function TelemetrySet2TypeT_Equal(val1, val2: in TelemetrySet2TypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.hk3 = val2.hk3);

    if ret then
        ret := (val1.hk4 = val2.hk4);

    end if;
	return ret;

end TelemetrySet2TypeT_Equal;

function TelemetrySet2TypeT_Init return TelemetrySet2TypeT
is
    val: TelemetrySet2TypeT;
begin

    --set hk3 
    val.hk3 := HKTypeT_Init;
    --set hk4 
    val.hk4 := HKTypeT_Init;
    return val;
end TelemetrySet2TypeT_Init;

FUNCTION TelemetrySet2TypeT_IsConstraintValid(val : in TelemetrySet2TypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.hk3 <= 255), ErrorCode => ERR_TELEMETRYSET2TYPET_HK3);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.hk4 <= 255), ErrorCode => ERR_TELEMETRYSET2TYPET_HK4);
    end if;

    RETURN ret;
END TelemetrySet2TypeT_IsConstraintValid;



function Telemetry2TypeBodyT_Equal(val1, val2: in Telemetry2TypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TelemetrySet2TypeT_Equal(val1.telemetrySet, val2.telemetrySet);

	return ret;

end Telemetry2TypeBodyT_Equal;

function Telemetry2TypeBodyT_Init return Telemetry2TypeBodyT
is
    val: Telemetry2TypeBodyT;
begin

    --set telemetrySet 
    val.telemetrySet := TelemetrySet2TypeT_Init;
    return val;
end Telemetry2TypeBodyT_Init;

FUNCTION Telemetry2TypeBodyT_IsConstraintValid(val : in Telemetry2TypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk3 <= 255), ErrorCode => ERR_TELEMETRY2TYPEBODYT_TELEMETRYSET_HK3);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk4 <= 255), ErrorCode => ERR_TELEMETRY2TYPEBODYT_TELEMETRYSET_HK4);
    end if;

    RETURN ret;
END Telemetry2TypeBodyT_IsConstraintValid;



function CommandStatusTypeT_Equal(val1, val2: in CommandStatusTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end CommandStatusTypeT_Equal;

function CommandStatusTypeT_Init return CommandStatusTypeT
is
    val: CommandStatusTypeT;
begin
    val := 0;
    return val;
end CommandStatusTypeT_Init;

FUNCTION CommandStatusTypeT_IsConstraintValid(val : in CommandStatusTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 65535), ErrorCode => ERR_COMMANDSTATUSTYPET);
    RETURN ret;
END CommandStatusTypeT_IsConstraintValid;



function TelemetryAckTypeBodyT_Equal(val1, val2: in TelemetryAckTypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.status = val2.status);

	return ret;

end TelemetryAckTypeBodyT_Equal;

function TelemetryAckTypeBodyT_Init return TelemetryAckTypeBodyT
is
    val: TelemetryAckTypeBodyT;
begin

    --set status 
    val.status := CommandStatusTypeT_Init;
    return val;
end TelemetryAckTypeBodyT_Init;

FUNCTION TelemetryAckTypeBodyT_IsConstraintValid(val : in TelemetryAckTypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.status <= 65535), ErrorCode => ERR_TELEMETRYACKTYPEBODYT_STATUS);
    RETURN ret;
END TelemetryAckTypeBodyT_IsConstraintValid;



function EventDataTypeT_Equal(val1, val2: in EventDataTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end EventDataTypeT_Equal;

function EventDataTypeT_Init return EventDataTypeT
is
    val: EventDataTypeT;
begin
    val := 0;
    return val;
end EventDataTypeT_Init;

FUNCTION EventDataTypeT_IsConstraintValid(val : in EventDataTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_EVENTDATATYPET);
    RETURN ret;
END EventDataTypeT_IsConstraintValid;



function UserDataLengthTypeT_Equal(val1, val2: in UserDataLengthTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end UserDataLengthTypeT_Equal;

function UserDataLengthTypeT_Init return UserDataLengthTypeT
is
    val: UserDataLengthTypeT;
begin
    val := 0;
    return val;
end UserDataLengthTypeT_Init;

FUNCTION UserDataLengthTypeT_IsConstraintValid(val : in UserDataLengthTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 65535), ErrorCode => ERR_USERDATALENGTHTYPET);
    RETURN ret;
END UserDataLengthTypeT_IsConstraintValid;



function ModeTypeT_Equal(val1, val2: in ModeTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end ModeTypeT_Equal;

function ModeTypeT_Init return ModeTypeT
is
    val: ModeTypeT;
begin
    val := reset;
    return val;
end ModeTypeT_Init;

FUNCTION ModeTypeT_IsConstraintValid(val : in ModeTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val = reset)) OR ((val = doALittleBitOfStuff)))) OR ((val = doLotsOfStuff)))) OR ((val = doTonnesOfStuffBadly)))) OR ((val = revealABugAndMalfunction))), ErrorCode => ERR_MODETYPET);
    RETURN ret;
END ModeTypeT_IsConstraintValid;



function TelecommandModeTypeBodyT_Equal(val1, val2: in TelecommandModeTypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.mode = val2.mode);

	return ret;

end TelecommandModeTypeBodyT_Equal;

function TelecommandModeTypeBodyT_Init return TelecommandModeTypeBodyT
is
    val: TelecommandModeTypeBodyT;
begin

    --set mode 
    val.mode := ModeTypeT_Init;
    return val;
end TelecommandModeTypeBodyT_Init;

FUNCTION TelecommandModeTypeBodyT_IsConstraintValid(val : in TelecommandModeTypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.mode = reset)) OR ((val.mode = doALittleBitOfStuff)))) OR ((val.mode = doLotsOfStuff)))) OR ((val.mode = doTonnesOfStuffBadly)))) OR ((val.mode = revealABugAndMalfunction))), ErrorCode => ERR_TELECOMMANDMODETYPEBODYT_MODE);
    RETURN ret;
END TelecommandModeTypeBodyT_IsConstraintValid;



function TelecommandTypeT_body_choice_Equal(val1, val2: in TelecommandTypeT_body_choice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when TelecommandTypeT_body_choice_mode_PRESENT =>
                ret := TelecommandModeTypeBodyT_Equal(val1.mode, val2.mode);
            when userData_PRESENT =>
                ret := TelecommandUserDataTypeBodyT_Equal(val1.userData, val2.userData);
        end case;
    end if;
	return ret;

end TelecommandTypeT_body_choice_Equal;

function TelecommandTypeT_Equal(val1, val2: in TelecommandTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TelecommandTypeT_body_choice_Equal(val1.body_choice, val2.body_choice);

	return ret;

end TelecommandTypeT_Equal;

function TelecommandTypeT_body_choice_Init return TelecommandTypeT_body_choice
is
    val: TelecommandTypeT_body_choice;
begin
    --set mode 
    declare
        mode_tmp:TelecommandModeTypeBodyT;
    begin
        mode_tmp := TelecommandModeTypeBodyT_Init;
        val := TelecommandTypeT_body_choice'(kind => TelecommandTypeT_body_choice_mode_PRESENT, mode => mode_tmp);
    end;
    return val;
end TelecommandTypeT_body_choice_Init;
function TelecommandTypeT_Init return TelecommandTypeT
is
    val: TelecommandTypeT;
begin

    --set body_choice 
    val.body_choice := TelecommandTypeT_body_choice_Init;
    return val;
end TelecommandTypeT_Init;

FUNCTION TelecommandTypeT_IsConstraintValid(val : in TelecommandTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    case val.body_choice.kind is
        WHEN TelecommandTypeT_body_choice_mode_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.body_choice.mode.mode = reset)) OR ((val.body_choice.mode.mode = doALittleBitOfStuff)))) OR ((val.body_choice.mode.mode = doLotsOfStuff)))) OR ((val.body_choice.mode.mode = doTonnesOfStuffBadly)))) OR ((val.body_choice.mode.mode = revealABugAndMalfunction))), ErrorCode => ERR_TELECOMMANDTYPET_BODY_CHOICE_MODE_MODE);
        WHEN userData_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.body_choice.userData.userData.Length) AND (val.body_choice.userData.userData.Length <= 255)), ErrorCode => ERR_TELECOMMANDTYPET_BODY_CHOICE_USERDATA_USERDATA);
            i1 := val.body_choice.userData.userData.Data'First;
            while ret.Success and i1 <= val.body_choice.userData.userData.Length loop
                pragma Loop_Invariant (i1 >= val.body_choice.userData.userData.Data'First and i1 <= val.body_choice.userData.userData.Length);
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.userData.userData.Data(i1) <= 255), ErrorCode => ERR_TELECOMMANDTYPET_BODY_CHOICE_USERDATA_USERDATA_ELM);
                i1 := i1+1;
            end loop;

    end case;
    RETURN ret;
END TelecommandTypeT_IsConstraintValid;



function EventTypeTypeT_Equal(val1, val2: in EventTypeTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end EventTypeTypeT_Equal;

function EventTypeTypeT_Init return EventTypeTypeT
is
    val: EventTypeTypeT;
begin
    val := event1;
    return val;
end EventTypeTypeT_Init;

FUNCTION EventTypeTypeT_IsConstraintValid(val : in EventTypeTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val = event1)) OR ((val = event2)))) OR ((val = event3))), ErrorCode => ERR_EVENTTYPETYPET);
    RETURN ret;
END EventTypeTypeT_IsConstraintValid;



function EventTypeT_Equal(val1, val2: in EventTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := (val1.data_value = val2.data_value);

    end if;
	return ret;

end EventTypeT_Equal;

function EventTypeT_Init return EventTypeT
is
    val: EventTypeT;
begin

    --set typeKeyword 
    val.typeKeyword := EventTypeTypeT_Init;
    --set data_value 
    val.data_value := EventDataTypeT_Init;
    return val;
end EventTypeT_Init;

FUNCTION EventTypeT_IsConstraintValid(val : in EventTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.typeKeyword = event1)) OR ((val.typeKeyword = event2)))) OR ((val.typeKeyword = event3))), ErrorCode => ERR_EVENTTYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.data_value <= 255), ErrorCode => ERR_EVENTTYPET_DATA_VALUE);
    end if;

    RETURN ret;
END EventTypeT_IsConstraintValid;



function TelemetryEventTypeBodyT_Equal(val1, val2: in TelemetryEventTypeBodyT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.eventType = val2.eventType);

    if ret then
        ret := (val1.eventData = val2.eventData);

    end if;
	return ret;

end TelemetryEventTypeBodyT_Equal;

function TelemetryEventTypeBodyT_Init return TelemetryEventTypeBodyT
is
    val: TelemetryEventTypeBodyT;
begin

    --set eventType 
    val.eventType := EventTypeTypeT_Init;
    --set eventData 
    val.eventData := EventDataTypeT_Init;
    return val;
end TelemetryEventTypeBodyT_Init;

FUNCTION TelemetryEventTypeBodyT_IsConstraintValid(val : in TelemetryEventTypeBodyT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.eventType = event1)) OR ((val.eventType = event2)))) OR ((val.eventType = event3))), ErrorCode => ERR_TELEMETRYEVENTTYPEBODYT_EVENTTYPE);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.eventData <= 255), ErrorCode => ERR_TELEMETRYEVENTTYPEBODYT_EVENTDATA);
    end if;

    RETURN ret;
END TelemetryEventTypeBodyT_IsConstraintValid;



function TelemetryTypeT_body_choice_Equal(val1, val2: in TelemetryTypeT_body_choice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when ack_PRESENT =>
                ret := TelemetryAckTypeBodyT_Equal(val1.ack, val2.ack);
            when type1_PRESENT =>
                ret := Telemetry1TypeBodyT_Equal(val1.type1, val2.type1);
            when type2_PRESENT =>
                ret := Telemetry2TypeBodyT_Equal(val1.type2, val2.type2);
            when event_PRESENT =>
                ret := TelemetryEventTypeBodyT_Equal(val1.event, val2.event);
        end case;
    end if;
	return ret;

end TelemetryTypeT_body_choice_Equal;

function TelemetryTypeT_Equal(val1, val2: in TelemetryTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := TelemetryTypeT_body_choice_Equal(val1.body_choice, val2.body_choice);

	return ret;

end TelemetryTypeT_Equal;

function TelemetryTypeT_body_choice_Init return TelemetryTypeT_body_choice
is
    val: TelemetryTypeT_body_choice;
begin
    --set ack 
    declare
        ack_tmp:TelemetryAckTypeBodyT;
    begin
        ack_tmp := TelemetryAckTypeBodyT_Init;
        val := TelemetryTypeT_body_choice'(kind => ack_PRESENT, ack => ack_tmp);
    end;
    return val;
end TelemetryTypeT_body_choice_Init;
function TelemetryTypeT_Init return TelemetryTypeT
is
    val: TelemetryTypeT;
begin

    --set body_choice 
    val.body_choice := TelemetryTypeT_body_choice_Init;
    return val;
end TelemetryTypeT_Init;

FUNCTION TelemetryTypeT_IsConstraintValid(val : in TelemetryTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.body_choice.kind is
        WHEN ack_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.ack.status <= 65535), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_ACK_STATUS);
        WHEN type1_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.type1.telemetrySet.hk1 <= 255), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_TYPE1_TELEMETRYSET_HK1);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.type1.telemetrySet.hk2 <= 255), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_TYPE1_TELEMETRYSET_HK2);
            end if;

        WHEN type2_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.type2.telemetrySet.hk3 <= 255), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_TYPE2_TELEMETRYSET_HK3);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.type2.telemetrySet.hk4 <= 255), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_TYPE2_TELEMETRYSET_HK4);
            end if;

        WHEN event_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.body_choice.event.eventType = event1)) OR ((val.body_choice.event.eventType = event2)))) OR ((val.body_choice.event.eventType = event3))), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_EVENT_EVENTTYPE);
            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.body_choice.event.eventData <= 255), ErrorCode => ERR_TELEMETRYTYPET_BODY_CHOICE_EVENT_EVENTDATA);
            end if;

    end case;
    RETURN ret;
END TelemetryTypeT_IsConstraintValid;



function ReadStatusModeCommandTypeT_Equal(val1, val2: in ReadStatusModeCommandTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end ReadStatusModeCommandTypeT_Equal;

function ReadStatusModeCommandTypeT_Init return ReadStatusModeCommandTypeT
is
    val: ReadStatusModeCommandTypeT;
begin
    val := readStatus;
    return val;
end ReadStatusModeCommandTypeT_Init;

FUNCTION ReadStatusModeCommandTypeT_IsConstraintValid(val : in ReadStatusModeCommandTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = readStatus)) OR ((val = readMode))), ErrorCode => ERR_READSTATUSMODECOMMANDTYPET);
    RETURN ret;
END ReadStatusModeCommandTypeT_IsConstraintValid;



function ExtendedStatusModeEnumTypeT_Equal(val1, val2: in ExtendedStatusModeEnumTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end ExtendedStatusModeEnumTypeT_Equal;

function ExtendedStatusModeEnumTypeT_Init return ExtendedStatusModeEnumTypeT
is
    val: ExtendedStatusModeEnumTypeT;
begin
    val := ExtendedStatusModeEnumTypeT_mode;
    return val;
end ExtendedStatusModeEnumTypeT_Init;

FUNCTION ExtendedStatusModeEnumTypeT_IsConstraintValid(val : in ExtendedStatusModeEnumTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = ExtendedStatusModeEnumTypeT_mode)) OR ((val = status))), ErrorCode => ERR_EXTENDEDSTATUSMODEENUMTYPET);
    RETURN ret;
END ExtendedStatusModeEnumTypeT_IsConstraintValid;



function ExtendedStatusUnionTypeT_Equal(val1, val2: in ExtendedStatusUnionTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.queryCount = val2.queryCount);

    if ret then
        ret := (val1.typeKeyword = val2.typeKeyword);

        if ret then
            ret := (val1.status = val2.status);

        end if;
    end if;
	return ret;

end ExtendedStatusUnionTypeT_Equal;

function ExtendedStatusUnionTypeT_Init return ExtendedStatusUnionTypeT
is
    val: ExtendedStatusUnionTypeT;
begin

    --set queryCount 
    val.queryCount := QueryCountTypeT_Init;
    --set typeKeyword 
    val.typeKeyword := ExtendedStatusModeEnumTypeT_Init;
    --set status 
    val.status := ExtendedStatusTypeT_Init;
    return val;
end ExtendedStatusUnionTypeT_Init;

FUNCTION ExtendedStatusUnionTypeT_IsConstraintValid(val : in ExtendedStatusUnionTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.queryCount <= 255), ErrorCode => ERR_EXTENDEDSTATUSUNIONTYPET_QUERYCOUNT);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.typeKeyword = ExtendedStatusModeEnumTypeT_mode)) OR ((val.typeKeyword = status))), ErrorCode => ERR_EXTENDEDSTATUSUNIONTYPET_TYPEKEYWORD);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.status <= 255), ErrorCode => ERR_EXTENDEDSTATUSUNIONTYPET_STATUS);
        end if;

    end if;

    RETURN ret;
END ExtendedStatusUnionTypeT_IsConstraintValid;



function ExtendedModeUnionTypeT_Equal(val1, val2: in ExtendedModeUnionTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.queryCount = val2.queryCount);

    if ret then
        ret := (val1.typeKeyword = val2.typeKeyword);

        if ret then
            ret := (val1.mode = val2.mode);

        end if;
    end if;
	return ret;

end ExtendedModeUnionTypeT_Equal;

function ExtendedModeUnionTypeT_Init return ExtendedModeUnionTypeT
is
    val: ExtendedModeUnionTypeT;
begin

    --set queryCount 
    val.queryCount := QueryCountTypeT_Init;
    --set typeKeyword 
    val.typeKeyword := ExtendedStatusModeEnumTypeT_Init;
    --set mode 
    val.mode := ExtendedModeTypeT_Init;
    return val;
end ExtendedModeUnionTypeT_Init;

FUNCTION ExtendedModeUnionTypeT_IsConstraintValid(val : in ExtendedModeUnionTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.queryCount <= 255), ErrorCode => ERR_EXTENDEDMODEUNIONTYPET_QUERYCOUNT);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.typeKeyword = ExtendedStatusModeEnumTypeT_mode)) OR ((val.typeKeyword = status))), ErrorCode => ERR_EXTENDEDMODEUNIONTYPET_TYPEKEYWORD);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.mode <= 255), ErrorCode => ERR_EXTENDEDMODEUNIONTYPET_MODE);
        end if;

    end if;

    RETURN ret;
END ExtendedModeUnionTypeT_IsConstraintValid;



function TelecommandTypeEnumTypeT_Equal(val1, val2: in TelecommandTypeEnumTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end TelecommandTypeEnumTypeT_Equal;

function TelecommandTypeEnumTypeT_Init return TelecommandTypeEnumTypeT
is
    val: TelecommandTypeEnumTypeT;
begin
    val := TelecommandTypeEnumTypeT_mode;
    return val;
end TelecommandTypeEnumTypeT_Init;

FUNCTION TelecommandTypeEnumTypeT_IsConstraintValid(val : in TelecommandTypeEnumTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val = TelecommandTypeEnumTypeT_mode)) OR ((val = userData))), ErrorCode => ERR_TELECOMMANDTYPEENUMTYPET);
    RETURN ret;
END TelecommandTypeEnumTypeT_IsConstraintValid;



function TelecommandModeTypeT_Equal(val1, val2: in TelecommandModeTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := (val1.mode = val2.mode);

    end if;
	return ret;

end TelecommandModeTypeT_Equal;

function TelecommandModeTypeT_Init return TelecommandModeTypeT
is
    val: TelecommandModeTypeT;
begin

    --set typeKeyword 
    val.typeKeyword := TelecommandTypeEnumTypeT_Init;
    --set mode 
    val.mode := ModeTypeT_Init;
    return val;
end TelecommandModeTypeT_Init;

FUNCTION TelecommandModeTypeT_IsConstraintValid(val : in TelecommandModeTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.typeKeyword = TelecommandTypeEnumTypeT_mode)) OR ((val.typeKeyword = userData))), ErrorCode => ERR_TELECOMMANDMODETYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.mode = reset)) OR ((val.mode = doALittleBitOfStuff)))) OR ((val.mode = doLotsOfStuff)))) OR ((val.mode = doTonnesOfStuffBadly)))) OR ((val.mode = revealABugAndMalfunction))), ErrorCode => ERR_TELECOMMANDMODETYPET_MODE);
    end if;

    RETURN ret;
END TelecommandModeTypeT_IsConstraintValid;



function TelecommandUserDataTypeT_userData_Equal(val1, val2: in TelecommandUserDataTypeT_userData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TelecommandUserDataTypeT_userData_Equal;

function TelecommandUserDataTypeT_Equal(val1, val2: in TelecommandUserDataTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := TelecommandUserDataTypeT_userData_Equal(val1.userData, val2.userData);

    end if;
	return ret;

end TelecommandUserDataTypeT_Equal;

function TelecommandUserDataTypeT_userData_Init return TelecommandUserDataTypeT_userData
is
    val: TelecommandUserDataTypeT_userData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := CcsdsSoisSubnetwork.OctetTypeT_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end TelecommandUserDataTypeT_userData_Init;
function TelecommandUserDataTypeT_Init return TelecommandUserDataTypeT
is
    val: TelecommandUserDataTypeT;
begin

    --set typeKeyword 
    val.typeKeyword := TelecommandTypeEnumTypeT_Init;
    --set userData 
    val.userData := TelecommandUserDataTypeT_userData_Init;
    return val;
end TelecommandUserDataTypeT_Init;

FUNCTION TelecommandUserDataTypeT_IsConstraintValid(val : in TelecommandUserDataTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.typeKeyword = TelecommandTypeEnumTypeT_mode)) OR ((val.typeKeyword = userData))), ErrorCode => ERR_TELECOMMANDUSERDATATYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.userData.Length) AND (val.userData.Length <= 255)), ErrorCode => ERR_TELECOMMANDUSERDATATYPET_USERDATA);
        i1 := val.userData.Data'First;
        while ret.Success and i1 <= val.userData.Length loop
            pragma Loop_Invariant (i1 >= val.userData.Data'First and i1 <= val.userData.Length);
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.userData.Data(i1) <= 255), ErrorCode => ERR_TELECOMMANDUSERDATATYPET_USERDATA_ELM);
            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END TelecommandUserDataTypeT_IsConstraintValid;



function TelemetryTypeEnumTypeT_Equal(val1, val2: in TelemetryTypeEnumTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end TelemetryTypeEnumTypeT_Equal;

function TelemetryTypeEnumTypeT_Init return TelemetryTypeEnumTypeT
is
    val: TelemetryTypeEnumTypeT;
begin
    val := ack;
    return val;
end TelemetryTypeEnumTypeT_Init;

FUNCTION TelemetryTypeEnumTypeT_IsConstraintValid(val : in TelemetryTypeEnumTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((val = ack)) OR ((val = type1)))) OR ((val = type2)))) OR ((val = event))), ErrorCode => ERR_TELEMETRYTYPEENUMTYPET);
    RETURN ret;
END TelemetryTypeEnumTypeT_IsConstraintValid;



function TelemetryAckTypeT_Equal(val1, val2: in TelemetryAckTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := (val1.status = val2.status);

    end if;
	return ret;

end TelemetryAckTypeT_Equal;

function TelemetryAckTypeT_Init return TelemetryAckTypeT
is
    val: TelemetryAckTypeT;
begin

    --set typeKeyword 
    val.typeKeyword := TelemetryTypeEnumTypeT_Init;
    --set status 
    val.status := CommandStatusTypeT_Init;
    return val;
end TelemetryAckTypeT_Init;

FUNCTION TelemetryAckTypeT_IsConstraintValid(val : in TelemetryAckTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((val.typeKeyword = ack)) OR ((val.typeKeyword = type1)))) OR ((val.typeKeyword = type2)))) OR ((val.typeKeyword = event))), ErrorCode => ERR_TELEMETRYACKTYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.status <= 65535), ErrorCode => ERR_TELEMETRYACKTYPET_STATUS);
    end if;

    RETURN ret;
END TelemetryAckTypeT_IsConstraintValid;



function Telemetry1TypeT_Equal(val1, val2: in Telemetry1TypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := TelemetrySet1TypeT_Equal(val1.telemetrySet, val2.telemetrySet);

    end if;
	return ret;

end Telemetry1TypeT_Equal;

function Telemetry1TypeT_Init return Telemetry1TypeT
is
    val: Telemetry1TypeT;
begin

    --set typeKeyword 
    val.typeKeyword := TelemetryTypeEnumTypeT_Init;
    --set telemetrySet 
    val.telemetrySet := TelemetrySet1TypeT_Init;
    return val;
end Telemetry1TypeT_Init;

FUNCTION Telemetry1TypeT_IsConstraintValid(val : in Telemetry1TypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((val.typeKeyword = ack)) OR ((val.typeKeyword = type1)))) OR ((val.typeKeyword = type2)))) OR ((val.typeKeyword = event))), ErrorCode => ERR_TELEMETRY1TYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk1 <= 255), ErrorCode => ERR_TELEMETRY1TYPET_TELEMETRYSET_HK1);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk2 <= 255), ErrorCode => ERR_TELEMETRY1TYPET_TELEMETRYSET_HK2);
        end if;

    end if;

    RETURN ret;
END Telemetry1TypeT_IsConstraintValid;



function Telemetry2TypeT_Equal(val1, val2: in Telemetry2TypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := TelemetrySet2TypeT_Equal(val1.telemetrySet, val2.telemetrySet);

    end if;
	return ret;

end Telemetry2TypeT_Equal;

function Telemetry2TypeT_Init return Telemetry2TypeT
is
    val: Telemetry2TypeT;
begin

    --set typeKeyword 
    val.typeKeyword := TelemetryTypeEnumTypeT_Init;
    --set telemetrySet 
    val.telemetrySet := TelemetrySet2TypeT_Init;
    return val;
end Telemetry2TypeT_Init;

FUNCTION Telemetry2TypeT_IsConstraintValid(val : in Telemetry2TypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((val.typeKeyword = ack)) OR ((val.typeKeyword = type1)))) OR ((val.typeKeyword = type2)))) OR ((val.typeKeyword = event))), ErrorCode => ERR_TELEMETRY2TYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk3 <= 255), ErrorCode => ERR_TELEMETRY2TYPET_TELEMETRYSET_HK3);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.telemetrySet.hk4 <= 255), ErrorCode => ERR_TELEMETRY2TYPET_TELEMETRYSET_HK4);
        end if;

    end if;

    RETURN ret;
END Telemetry2TypeT_IsConstraintValid;



function TelemetryEventTypeT_Equal(val1, val2: in TelemetryEventTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.typeKeyword = val2.typeKeyword);

    if ret then
        ret := (val1.eventType = val2.eventType);

        if ret then
            ret := (val1.eventData = val2.eventData);

        end if;
    end if;
	return ret;

end TelemetryEventTypeT_Equal;

function TelemetryEventTypeT_Init return TelemetryEventTypeT
is
    val: TelemetryEventTypeT;
begin

    --set typeKeyword 
    val.typeKeyword := TelemetryTypeEnumTypeT_Init;
    --set eventType 
    val.eventType := EventTypeTypeT_Init;
    --set eventData 
    val.eventData := EventDataTypeT_Init;
    return val;
end TelemetryEventTypeT_Init;

FUNCTION TelemetryEventTypeT_IsConstraintValid(val : in TelemetryEventTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((val.typeKeyword = ack)) OR ((val.typeKeyword = type1)))) OR ((val.typeKeyword = type2)))) OR ((val.typeKeyword = event))), ErrorCode => ERR_TELEMETRYEVENTTYPET_TYPEKEYWORD);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.eventType = event1)) OR ((val.eventType = event2)))) OR ((val.eventType = event3))), ErrorCode => ERR_TELEMETRYEVENTTYPET_EVENTTYPE);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.eventData <= 255), ErrorCode => ERR_TELEMETRYEVENTTYPET_EVENTDATA);
        end if;

    end if;

    RETURN ret;
END TelemetryEventTypeT_IsConstraintValid;



function OpCountTypeT_Equal(val1, val2: in OpCountTypeT)
    return Boolean 
is
begin
	return val1 = val2;

end OpCountTypeT_Equal;

function OpCountTypeT_Init return OpCountTypeT
is
    val: OpCountTypeT;
begin
    val := 0;
    return val;
end OpCountTypeT_Init;

FUNCTION OpCountTypeT_IsConstraintValid(val : in OpCountTypeT) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 39), ErrorCode => ERR_OPCOUNTTYPET);
    RETURN ret;
END OpCountTypeT_IsConstraintValid;



function StatusTypeT_Equal(val1, val2: in StatusTypeT)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.statusFlag1 = val2.statusFlag1);

    if ret then
        ret := (val1.statusFlag2 = val2.statusFlag2);

        if ret then
            ret := (val1.opCount = val2.opCount);

        end if;
    end if;
	return ret;

end StatusTypeT_Equal;

function StatusTypeT_Init return StatusTypeT
is
    val: StatusTypeT;
begin

    --set statusFlag1 
    val.statusFlag1 := StatusFlag1TypeT_Init;
    --set statusFlag2 
    val.statusFlag2 := StatusFlag2TypeT_Init;
    --set opCount 
    val.opCount := OpCountTypeT_Init;
    return val;
end StatusTypeT_Init;

FUNCTION StatusTypeT_IsConstraintValid(val : in StatusTypeT) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_STATUSTYPET_STATUSFLAG1);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_STATUSTYPET_STATUSFLAG2);
        if ret.Success then
            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.opCount <= 39), ErrorCode => ERR_STATUSTYPET_OPCOUNT);
        end if;

    end if;

    RETURN ret;
END StatusTypeT_IsConstraintValid;


 

END Demo;