-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
WITH Demo;
WITH CcsdsSoisSubnetwork;
use type Demo.ExtendedStatusOrModeTypeT_body_choice;
use type Demo.ExtendedStatusOrModeTypeT;
use type Demo.QueryCountTypeT;
use type Demo.ExtendedModeUnionTypeBodyT;
use type Demo.ExtendedModeTypeT;
use type Demo.ExtendedStatusUnionTypeBodyT;
use type Demo.ExtendedStatusTypeT;
use type Demo.StatusTypeT;
use type Demo.StatusFlag1TypeT;
use type Demo.StatusFlag2TypeT;
use type Demo.OpCountTypeT;
use type Demo.TelecommandTypeT_body_choice;
use type Demo.TelecommandTypeT;
use type Demo.TelecommandModeTypeBodyT;
use type Demo.ModeTypeT;
use type Demo.TelecommandUserDataTypeBodyT_userData;
use type Demo.TelecommandUserDataTypeBodyT;
use type CcsdsSoisSubnetwork.OctetTypeT;
use type Demo.TelemetryTypeT_body_choice;
use type Demo.TelemetryTypeT;
use type Demo.TelemetryAckTypeBodyT;
use type Demo.CommandStatusTypeT;
use type Demo.Telemetry1TypeBodyT;
use type Demo.TelemetrySet1TypeT;
use type Demo.HKTypeT;
use type Demo.HKTypeT;
use type Demo.Telemetry2TypeBodyT;
use type Demo.TelemetrySet2TypeT;
use type Demo.HKTypeT;
use type Demo.HKTypeT;
use type Demo.TelemetryEventTypeBodyT;
use type Demo.EventTypeTypeT;
use type Demo.EventDataTypeT;
use type Demo.TelecommandTypeT_body_choice;
use type Demo.TelecommandTypeT;
use type Demo.TelecommandModeTypeBodyT;
use type Demo.ModeTypeT;
use type Demo.TelecommandUserDataTypeBodyT_userData;
use type Demo.TelecommandUserDataTypeBodyT;
use type CcsdsSoisSubnetwork.OctetTypeT;
use type Demo.TelemetryTypeT_body_choice;
use type Demo.TelemetryTypeT;
use type Demo.TelemetryAckTypeBodyT;
use type Demo.CommandStatusTypeT;
use type Demo.Telemetry1TypeBodyT;
use type Demo.TelemetrySet1TypeT;
use type Demo.HKTypeT;
use type Demo.HKTypeT;
use type Demo.Telemetry2TypeBodyT;
use type Demo.TelemetrySet2TypeT;
use type Demo.HKTypeT;
use type Demo.HKTypeT;
use type Demo.TelemetryEventTypeBodyT;
use type Demo.EventTypeTypeT;
use type Demo.EventDataTypeT;
use type Demo.TelemetryTypeT_body_choice;
use type Demo.TelemetryTypeT;
use type Demo.TelemetryAckTypeBodyT;
use type Demo.CommandStatusTypeT;
use type Demo.Telemetry1TypeBodyT;
use type Demo.TelemetrySet1TypeT;
use type Demo.HKTypeT;
use type Demo.HKTypeT;
use type Demo.Telemetry2TypeBodyT;
use type Demo.TelemetrySet2TypeT;
use type Demo.HKTypeT;
use type Demo.HKTypeT;
use type Demo.TelemetryEventTypeBodyT;
use type Demo.EventTypeTypeT;
use type Demo.EventDataTypeT;
use type Demo.TelecommandTypeT_body_choice;
use type Demo.TelecommandTypeT;
use type Demo.TelecommandModeTypeBodyT;
use type Demo.ModeTypeT;
use type Demo.TelecommandUserDataTypeBodyT_userData;
use type Demo.TelecommandUserDataTypeBodyT;
use type CcsdsSoisSubnetwork.OctetTypeT;
use type CcsdsSoisSubnetwork.MemoryIDTypeT;
use type CcsdsSoisSubnetwork.MemoryAddressTypeT;
use type Demo.ReadStatusModeCommandTypeT;
use type CcsdsSoisSubnetwork.MemoryIDTypeT;
use type CcsdsSoisSubnetwork.MemoryAddressTypeT;
use type Demo.ReadStatusModeCommandTypeT;
use type CcsdsSoisSubnetwork.MemoryIDTypeT;
use type CcsdsSoisSubnetwork.MemoryAddressTypeT;
use type Demo.ReadStatusModeCommandTypeT;
use type CcsdsSoisSubnetwork.MemoryIDTypeT;
use type CcsdsSoisSubnetwork.MemoryAddressTypeT;
use type Demo.ReadStatusModeCommandTypeT;
use type Demo.ExtendedStatusOrModeTypeT_body_choice;
use type Demo.ExtendedStatusOrModeTypeT;
use type Demo.QueryCountTypeT;
use type Demo.ExtendedModeUnionTypeBodyT;
use type Demo.ExtendedModeTypeT;
use type Demo.ExtendedStatusUnionTypeBodyT;
use type Demo.ExtendedStatusTypeT;
use type Demo.StatusTypeT;
use type Demo.StatusFlag1TypeT;
use type Demo.StatusFlag2TypeT;
use type Demo.OpCountTypeT;
use type Demo.ExtendedStatusOrModeTypeT_body_choice;
use type Demo.ExtendedStatusOrModeTypeT;
use type Demo.QueryCountTypeT;
use type Demo.ExtendedModeUnionTypeBodyT;
use type Demo.ExtendedModeTypeT;
use type Demo.ExtendedStatusUnionTypeBodyT;
use type Demo.ExtendedStatusTypeT;
use type Demo.StatusTypeT;
use type Demo.StatusFlag1TypeT;
use type Demo.StatusFlag2TypeT;
use type Demo.OpCountTypeT;
use type CcsdsSoisSubnetwork.MemoryIDTypeT;
use type CcsdsSoisSubnetwork.MemoryAddressTypeT;
use type Demo.ReadStatusModeCommandTypeT;
use type CcsdsSoisSubnetwork.MemoryIDTypeT;
use type CcsdsSoisSubnetwork.MemoryAddressTypeT;
use type Demo.ReadStatusModeCommandTypeT;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY CcsdsSoisSubnetworkInterfaces with SPARK_Mode IS




function MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype_Equal(val1, val2: in MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Demo.ExtendedStatusOrModeTypeT_Equal(val1.data_value, val2.data_value);

	return ret;

end MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype_Equal;

function MASInterfaceTypeUpType_replyToCommand_readStatustype_Equal(val1, val2: in MASInterfaceTypeUpType_replyToCommand_readStatustype)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Demo.StatusTypeT_Equal(val1.data_value, val2.data_value);

	return ret;

end MASInterfaceTypeUpType_replyToCommand_readStatustype_Equal;

function MASInterfaceTypeUpType_replyToCommand_write_Equal(val1, val2: in MASInterfaceTypeUpType_replyToCommand_write)
    return Boolean 
is
begin
	return True;

end MASInterfaceTypeUpType_replyToCommand_write_Equal;

function MASInterfaceTypeUpType_replyToCommand_Equal(val1, val2: in MASInterfaceTypeUpType_replyToCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when replyToCommand_readExtendedstatusormodetype_PRESENT =>
                ret := Demo.ExtendedStatusOrModeTypeT_Equal(val1.readExtendedstatusormodetype.data_value, val2.readExtendedstatusormodetype.data_value);

            when replyToCommand_readStatustype_PRESENT =>
                ret := Demo.StatusTypeT_Equal(val1.readStatustype.data_value, val2.readStatustype.data_value);

            when replyToCommand_write_PRESENT =>
                ret := TRUE;
        end case;
    end if;
	return ret;

end MASInterfaceTypeUpType_replyToCommand_Equal;

function MASInterfaceTypeUpType_Equal(val1, val2: in MASInterfaceTypeUpType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when MASInterfaceTypeUpType_replyToCommand_PRESENT =>
                ret := val1.replyToCommand.kind = val2.replyToCommand.kind;
                if ret then
                    case val1.replyToCommand.kind is
                        when replyToCommand_readExtendedstatusormodetype_PRESENT =>
                            ret := Demo.ExtendedStatusOrModeTypeT_Equal(val1.replyToCommand.readExtendedstatusormodetype.data_value, val2.replyToCommand.readExtendedstatusormodetype.data_value);

                        when replyToCommand_readStatustype_PRESENT =>
                            ret := Demo.StatusTypeT_Equal(val1.replyToCommand.readStatustype.data_value, val2.replyToCommand.readStatustype.data_value);

                        when replyToCommand_write_PRESENT =>
                            ret := TRUE;
                    end case;
                end if;
        end case;
    end if;
	return ret;

end MASInterfaceTypeUpType_Equal;

function MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype_Init return MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype
is
    val: MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype;
begin

    --set data_value 
    val.data_value := Demo.ExtendedStatusOrModeTypeT_Init;
    return val;
end MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype_Init;
function MASInterfaceTypeUpType_replyToCommand_readStatustype_Init return MASInterfaceTypeUpType_replyToCommand_readStatustype
is
    val: MASInterfaceTypeUpType_replyToCommand_readStatustype;
begin

    --set data_value 
    val.data_value := Demo.StatusTypeT_Init;
    return val;
end MASInterfaceTypeUpType_replyToCommand_readStatustype_Init;
function MASInterfaceTypeUpType_replyToCommand_write_Init return MASInterfaceTypeUpType_replyToCommand_write
is
    val: MASInterfaceTypeUpType_replyToCommand_write;
begin
    val := (null record);
    return val;
end MASInterfaceTypeUpType_replyToCommand_write_Init;
function MASInterfaceTypeUpType_replyToCommand_Init return MASInterfaceTypeUpType_replyToCommand
is
    val: MASInterfaceTypeUpType_replyToCommand;
begin
    --set readExtendedstatusormodetype 
    declare
        readExtendedstatusormodetype_tmp:MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype;
    begin
        val.readExtendedstatusormodetype := MASInterfaceTypeUpType_replyToCommand_readExtendedstatusormodetype_Init;
        val := MASInterfaceTypeUpType_replyToCommand'(kind => replyToCommand_readExtendedstatusormodetype_PRESENT, readExtendedstatusormodetype => readExtendedstatusormodetype_tmp);
    end;
    return val;
end MASInterfaceTypeUpType_replyToCommand_Init;
function MASInterfaceTypeUpType_Init return MASInterfaceTypeUpType
is
    val: MASInterfaceTypeUpType;
begin
    --set replyToCommand 
    declare
        replyToCommand_tmp:MASInterfaceTypeUpType_replyToCommand;
    begin
        val.replyToCommand := MASInterfaceTypeUpType_replyToCommand_Init;
        val := MASInterfaceTypeUpType'(kind => MASInterfaceTypeUpType_replyToCommand_PRESENT, replyToCommand => replyToCommand_tmp);
    end;
    return val;
end MASInterfaceTypeUpType_Init;

FUNCTION MASInterfaceTypeUpType_IsConstraintValid(val : in MASInterfaceTypeUpType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN MASInterfaceTypeUpType_replyToCommand_PRESENT =>
            case val.replyToCommand.kind is
                WHEN replyToCommand_readExtendedstatusormodetype_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.readExtendedstatusormodetype.data_value.queryCount <= 255), ErrorCode => ERR_MASINTERFACETYPEUPTYPE_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_QUERYCOUNT);
                    if ret.Success then
                        case val.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.kind is
                            WHEN Demo.ExtendedStatusOrModeTypeT_body_choice_mode_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.mode.mode <= 255), ErrorCode => ERR_MASINTERFACETYPEUPTYPE_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_BODY_CHOICE_MODE_MODE);
                            WHEN Demo.body_choice_status_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.status.status <= 255), ErrorCode => ERR_MASINTERFACETYPEUPTYPE_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_BODY_CHOICE_STATUS_STATUS);
                        end case;
                    end if;

                WHEN replyToCommand_readStatustype_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPEUPTYPE_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_STATUSFLAG1);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPEUPTYPE_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_STATUSFLAG2);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.readStatustype.data_value.opCount <= 39), ErrorCode => ERR_MASINTERFACETYPEUPTYPE_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_OPCOUNT);
                        end if;

                    end if;

                WHEN replyToCommand_write_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
            end case;
    end case;
    RETURN ret;
END MASInterfaceTypeUpType_IsConstraintValid;



function PSInterfaceTypeDownType_sendCommand_send_Equal(val1, val2: in PSInterfaceTypeDownType_sendCommand_send)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Demo.TelecommandTypeT_Equal(val1.data_value, val2.data_value);

	return ret;

end PSInterfaceTypeDownType_sendCommand_send_Equal;

function PSInterfaceTypeDownType_sendCommand_Equal(val1, val2: in PSInterfaceTypeDownType_sendCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when send_PRESENT =>
                ret := Demo.TelecommandTypeT_Equal(val1.send.data_value, val2.send.data_value);

        end case;
    end if;
	return ret;

end PSInterfaceTypeDownType_sendCommand_Equal;

function PSInterfaceTypeDownType_Equal(val1, val2: in PSInterfaceTypeDownType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when PSInterfaceTypeDownType_sendCommand_PRESENT =>
                ret := val1.sendCommand.kind = val2.sendCommand.kind;
                if ret then
                    case val1.sendCommand.kind is
                        when send_PRESENT =>
                            ret := Demo.TelecommandTypeT_Equal(val1.sendCommand.send.data_value, val2.sendCommand.send.data_value);

                    end case;
                end if;
        end case;
    end if;
	return ret;

end PSInterfaceTypeDownType_Equal;

function PSInterfaceTypeDownType_sendCommand_send_Init return PSInterfaceTypeDownType_sendCommand_send
is
    val: PSInterfaceTypeDownType_sendCommand_send;
begin

    --set data_value 
    val.data_value := Demo.TelecommandTypeT_Init;
    return val;
end PSInterfaceTypeDownType_sendCommand_send_Init;
function PSInterfaceTypeDownType_sendCommand_Init return PSInterfaceTypeDownType_sendCommand
is
    val: PSInterfaceTypeDownType_sendCommand;
begin
    --set send 
    declare
        send_tmp:PSInterfaceTypeDownType_sendCommand_send;
    begin
        val.send := PSInterfaceTypeDownType_sendCommand_send_Init;
        val := PSInterfaceTypeDownType_sendCommand'(kind => send_PRESENT, send => send_tmp);
    end;
    return val;
end PSInterfaceTypeDownType_sendCommand_Init;
function PSInterfaceTypeDownType_Init return PSInterfaceTypeDownType
is
    val: PSInterfaceTypeDownType;
begin
    --set sendCommand 
    declare
        sendCommand_tmp:PSInterfaceTypeDownType_sendCommand;
    begin
        val.sendCommand := PSInterfaceTypeDownType_sendCommand_Init;
        val := PSInterfaceTypeDownType'(kind => PSInterfaceTypeDownType_sendCommand_PRESENT, sendCommand => sendCommand_tmp);
    end;
    return val;
end PSInterfaceTypeDownType_Init;

FUNCTION PSInterfaceTypeDownType_IsConstraintValid(val : in PSInterfaceTypeDownType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    case val.kind is
        WHEN PSInterfaceTypeDownType_sendCommand_PRESENT =>
            case val.sendCommand.kind is
                WHEN send_PRESENT =>
                    case val.sendCommand.send.data_value.body_choice.kind is
                        WHEN Demo.TelecommandTypeT_body_choice_mode_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.sendCommand.send.data_value.body_choice.mode.mode = Demo.reset)) OR ((val.sendCommand.send.data_value.body_choice.mode.mode = Demo.doALittleBitOfStuff)))) OR ((val.sendCommand.send.data_value.body_choice.mode.mode = Demo.doLotsOfStuff)))) OR ((val.sendCommand.send.data_value.body_choice.mode.mode = Demo.doTonnesOfStuffBadly)))) OR ((val.sendCommand.send.data_value.body_choice.mode.mode = Demo.revealABugAndMalfunction))), ErrorCode => ERR_PSINTERFACETYPEDOWNTYPE_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_MODE_MODE);
                        WHEN Demo.userData_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.sendCommand.send.data_value.body_choice.userData.userData.Length) AND (val.sendCommand.send.data_value.body_choice.userData.userData.Length <= 255)), ErrorCode => ERR_PSINTERFACETYPEDOWNTYPE_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_USERDATA_USERDATA);
                            i1 := val.sendCommand.send.data_value.body_choice.userData.userData.Data'First;
                            while ret.Success and i1 <= val.sendCommand.send.data_value.body_choice.userData.userData.Length loop
                                pragma Loop_Invariant (i1 >= val.sendCommand.send.data_value.body_choice.userData.userData.Data'First and i1 <= val.sendCommand.send.data_value.body_choice.userData.userData.Length);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.sendCommand.send.data_value.body_choice.userData.userData.Data(i1) <= 255), ErrorCode => ERR_PSINTERFACETYPEDOWNTYPE_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_USERDATA_USERDATA_ELM);
                                i1 := i1+1;
                            end loop;

                    end case;
            end case;
    end case;
    RETURN ret;
END PSInterfaceTypeDownType_IsConstraintValid;



function PSInterfaceTypeUpType_replyToCommand_receive_Equal(val1, val2: in PSInterfaceTypeUpType_replyToCommand_receive)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Demo.TelemetryTypeT_Equal(val1.data_value, val2.data_value);

	return ret;

end PSInterfaceTypeUpType_replyToCommand_receive_Equal;

function PSInterfaceTypeUpType_replyToCommand_Equal(val1, val2: in PSInterfaceTypeUpType_replyToCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when receive_PRESENT =>
                ret := Demo.TelemetryTypeT_Equal(val1.receive.data_value, val2.receive.data_value);

        end case;
    end if;
	return ret;

end PSInterfaceTypeUpType_replyToCommand_Equal;

function PSInterfaceTypeUpType_Equal(val1, val2: in PSInterfaceTypeUpType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when PSInterfaceTypeUpType_replyToCommand_PRESENT =>
                ret := val1.replyToCommand.kind = val2.replyToCommand.kind;
                if ret then
                    case val1.replyToCommand.kind is
                        when receive_PRESENT =>
                            ret := Demo.TelemetryTypeT_Equal(val1.replyToCommand.receive.data_value, val2.replyToCommand.receive.data_value);

                    end case;
                end if;
        end case;
    end if;
	return ret;

end PSInterfaceTypeUpType_Equal;

function PSInterfaceTypeUpType_replyToCommand_receive_Init return PSInterfaceTypeUpType_replyToCommand_receive
is
    val: PSInterfaceTypeUpType_replyToCommand_receive;
begin

    --set data_value 
    val.data_value := Demo.TelemetryTypeT_Init;
    return val;
end PSInterfaceTypeUpType_replyToCommand_receive_Init;
function PSInterfaceTypeUpType_replyToCommand_Init return PSInterfaceTypeUpType_replyToCommand
is
    val: PSInterfaceTypeUpType_replyToCommand;
begin
    --set receive 
    declare
        receive_tmp:PSInterfaceTypeUpType_replyToCommand_receive;
    begin
        val.receive := PSInterfaceTypeUpType_replyToCommand_receive_Init;
        val := PSInterfaceTypeUpType_replyToCommand'(kind => receive_PRESENT, receive => receive_tmp);
    end;
    return val;
end PSInterfaceTypeUpType_replyToCommand_Init;
function PSInterfaceTypeUpType_Init return PSInterfaceTypeUpType
is
    val: PSInterfaceTypeUpType;
begin
    --set replyToCommand 
    declare
        replyToCommand_tmp:PSInterfaceTypeUpType_replyToCommand;
    begin
        val.replyToCommand := PSInterfaceTypeUpType_replyToCommand_Init;
        val := PSInterfaceTypeUpType'(kind => PSInterfaceTypeUpType_replyToCommand_PRESENT, replyToCommand => replyToCommand_tmp);
    end;
    return val;
end PSInterfaceTypeUpType_Init;

FUNCTION PSInterfaceTypeUpType_IsConstraintValid(val : in PSInterfaceTypeUpType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN PSInterfaceTypeUpType_replyToCommand_PRESENT =>
            case val.replyToCommand.kind is
                WHEN receive_PRESENT =>
                    case val.replyToCommand.receive.data_value.body_choice.kind is
                        WHEN Demo.ack_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.receive.data_value.body_choice.ack.status <= 65535), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_ACK_STATUS);
                        WHEN Demo.type1_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.receive.data_value.body_choice.type1.telemetrySet.hk1 <= 255), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE1_TELEMETRYSET_HK1);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.receive.data_value.body_choice.type1.telemetrySet.hk2 <= 255), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE1_TELEMETRYSET_HK2);
                            end if;

                        WHEN Demo.type2_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.receive.data_value.body_choice.type2.telemetrySet.hk3 <= 255), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE2_TELEMETRYSET_HK3);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.receive.data_value.body_choice.type2.telemetrySet.hk4 <= 255), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE2_TELEMETRYSET_HK4);
                            end if;

                        WHEN Demo.event_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event1)) OR ((val.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event2)))) OR ((val.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event3))), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_EVENT_EVENTTYPE);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.replyToCommand.receive.data_value.body_choice.event.eventData <= 255), ErrorCode => ERR_PSINTERFACETYPEUPTYPE_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_EVENT_EVENTDATA);
                            end if;

                    end case;
            end case;
    end case;
    RETURN ret;
END PSInterfaceTypeUpType_IsConstraintValid;



function PSInterfaceTypeProviderType_Equal(val1, val2: in PSInterfaceTypeProviderType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.inputReady = val2.inputReady);

    if ret then
        ret := PSInterfaceTypeDownType_Equal(val1.inputData, val2.inputData);

        if ret then
            ret := PSInterfaceTypeUpType_Equal(val1.outputData, val2.outputData);

        end if;
    end if;
	return ret;

end PSInterfaceTypeProviderType_Equal;

function PSInterfaceTypeProviderType_Init return PSInterfaceTypeProviderType
is
    val: PSInterfaceTypeProviderType;
begin

    --set inputReady 
    val.inputReady := FALSE;
    --set inputData 
    val.inputData := PSInterfaceTypeDownType_Init;
    --set outputData 
    val.outputData := PSInterfaceTypeUpType_Init;
    return val;
end PSInterfaceTypeProviderType_Init;

FUNCTION PSInterfaceTypeProviderType_IsConstraintValid(val : in PSInterfaceTypeProviderType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_INPUTREADY);
    if ret.Success then
        case val.inputData.kind is
            WHEN PSInterfaceTypeDownType_sendCommand_PRESENT =>
                case val.inputData.sendCommand.kind is
                    WHEN send_PRESENT =>
                        case val.inputData.sendCommand.send.data_value.body_choice.kind is
                            WHEN Demo.TelecommandTypeT_body_choice_mode_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.inputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.reset)) OR ((val.inputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.doALittleBitOfStuff)))) OR ((val.inputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.doLotsOfStuff)))) OR ((val.inputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.doTonnesOfStuffBadly)))) OR ((val.inputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.revealABugAndMalfunction))), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_MODE_MODE);
                            WHEN Demo.userData_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Length) AND (val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Length <= 255)), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_USERDATA_USERDATA);
                                i1 := val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Data'First;
                                while ret.Success and i1 <= val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Length loop
                                    pragma Loop_Invariant (i1 >= val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Data'First and i1 <= val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Length);
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.sendCommand.send.data_value.body_choice.userData.userData.Data(i1) <= 255), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_USERDATA_USERDATA_ELM);
                                    i1 := i1+1;
                                end loop;

                        end case;
                end case;
        end case;
        if ret.Success then
            case val.outputData.kind is
                WHEN PSInterfaceTypeUpType_replyToCommand_PRESENT =>
                    case val.outputData.replyToCommand.kind is
                        WHEN receive_PRESENT =>
                            case val.outputData.replyToCommand.receive.data_value.body_choice.kind is
                                WHEN Demo.ack_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.receive.data_value.body_choice.ack.status <= 65535), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_ACK_STATUS);
                                WHEN Demo.type1_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.receive.data_value.body_choice.type1.telemetrySet.hk1 <= 255), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE1_TELEMETRYSET_HK1);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.receive.data_value.body_choice.type1.telemetrySet.hk2 <= 255), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE1_TELEMETRYSET_HK2);
                                    end if;

                                WHEN Demo.type2_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.receive.data_value.body_choice.type2.telemetrySet.hk3 <= 255), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE2_TELEMETRYSET_HK3);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.receive.data_value.body_choice.type2.telemetrySet.hk4 <= 255), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE2_TELEMETRYSET_HK4);
                                    end if;

                                WHEN Demo.event_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.outputData.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event1)) OR ((val.outputData.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event2)))) OR ((val.outputData.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event3))), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_EVENT_EVENTTYPE);
                                    if ret.Success then
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.receive.data_value.body_choice.event.eventData <= 255), ErrorCode => ERR_PSINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_EVENT_EVENTDATA);
                                    end if;

                            end case;
                    end case;
            end case;
        end if;

    end if;

    RETURN ret;
END PSInterfaceTypeProviderType_IsConstraintValid;



function PSInterfaceTypeClientType_Equal(val1, val2: in PSInterfaceTypeClientType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.inputReady = val2.inputReady);

    if ret then
        ret := PSInterfaceTypeUpType_Equal(val1.inputData, val2.inputData);

        if ret then
            ret := PSInterfaceTypeDownType_Equal(val1.outputData, val2.outputData);

        end if;
    end if;
	return ret;

end PSInterfaceTypeClientType_Equal;

function PSInterfaceTypeClientType_Init return PSInterfaceTypeClientType
is
    val: PSInterfaceTypeClientType;
begin

    --set inputReady 
    val.inputReady := FALSE;
    --set inputData 
    val.inputData := PSInterfaceTypeUpType_Init;
    --set outputData 
    val.outputData := PSInterfaceTypeDownType_Init;
    return val;
end PSInterfaceTypeClientType_Init;

FUNCTION PSInterfaceTypeClientType_IsConstraintValid(val : in PSInterfaceTypeClientType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTREADY);
    if ret.Success then
        case val.inputData.kind is
            WHEN PSInterfaceTypeUpType_replyToCommand_PRESENT =>
                case val.inputData.replyToCommand.kind is
                    WHEN receive_PRESENT =>
                        case val.inputData.replyToCommand.receive.data_value.body_choice.kind is
                            WHEN Demo.ack_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.receive.data_value.body_choice.ack.status <= 65535), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_ACK_STATUS);
                            WHEN Demo.type1_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.receive.data_value.body_choice.type1.telemetrySet.hk1 <= 255), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE1_TELEMETRYSET_HK1);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.receive.data_value.body_choice.type1.telemetrySet.hk2 <= 255), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE1_TELEMETRYSET_HK2);
                                end if;

                            WHEN Demo.type2_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.receive.data_value.body_choice.type2.telemetrySet.hk3 <= 255), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE2_TELEMETRYSET_HK3);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.receive.data_value.body_choice.type2.telemetrySet.hk4 <= 255), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_TYPE2_TELEMETRYSET_HK4);
                                end if;

                            WHEN Demo.event_PRESENT =>
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (((((val.inputData.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event1)) OR ((val.inputData.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event2)))) OR ((val.inputData.replyToCommand.receive.data_value.body_choice.event.eventType = Demo.event3))), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_EVENT_EVENTTYPE);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.receive.data_value.body_choice.event.eventData <= 255), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_RECEIVE_DATA_VALUE_BODY_CHOICE_EVENT_EVENTDATA);
                                end if;

                        end case;
                end case;
        end case;
        if ret.Success then
            case val.outputData.kind is
                WHEN PSInterfaceTypeDownType_sendCommand_PRESENT =>
                    case val.outputData.sendCommand.kind is
                        WHEN send_PRESENT =>
                            case val.outputData.sendCommand.send.data_value.body_choice.kind is
                                WHEN Demo.TelecommandTypeT_body_choice_mode_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val.outputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.reset)) OR ((val.outputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.doALittleBitOfStuff)))) OR ((val.outputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.doLotsOfStuff)))) OR ((val.outputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.doTonnesOfStuffBadly)))) OR ((val.outputData.sendCommand.send.data_value.body_choice.mode.mode = Demo.revealABugAndMalfunction))), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_MODE_MODE);
                                WHEN Demo.userData_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Length) AND (val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Length <= 255)), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_USERDATA_USERDATA);
                                    i1 := val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Data'First;
                                    while ret.Success and i1 <= val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Length loop
                                        pragma Loop_Invariant (i1 >= val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Data'First and i1 <= val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Length);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.sendCommand.send.data_value.body_choice.userData.userData.Data(i1) <= 255), ErrorCode => ERR_PSINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_SEND_DATA_VALUE_BODY_CHOICE_USERDATA_USERDATA_ELM);
                                        i1 := i1+1;
                                    end loop;

                            end case;
                    end case;
            end case;
        end if;

    end if;

    RETURN ret;
END PSInterfaceTypeClientType_IsConstraintValid;



function MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype)
    return Boolean 
is
begin
	return True;

end MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype_Equal;

function MASInterfaceTypeDownType_sendCommand_readStatustype_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_readStatustype)
    return Boolean 
is
begin
	return True;

end MASInterfaceTypeDownType_sendCommand_readStatustype_Equal;

function MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID)
    return Boolean 
is
begin
	return val1 = val2;

end MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Equal;

function MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress)
    return Boolean 
is
begin
	return val1 = val2;

end MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Equal;

function MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Equal(val1.memoryID, val2.memoryID);

    if ret then
        ret := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Equal(val1.memoryAddress, val2.memoryAddress);

        if ret then
            ret := (val1.data_value = val2.data_value);

        end if;
    end if;
	return ret;

end MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_Equal;

function MASInterfaceTypeDownType_sendCommand_write_memoryID_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_write_memoryID)
    return Boolean 
is
begin
	return val1 = val2;

end MASInterfaceTypeDownType_sendCommand_write_memoryID_Equal;

function MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_write_memoryAddress)
    return Boolean 
is
begin
	return val1 = val2;

end MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Equal;

function MASInterfaceTypeDownType_sendCommand_write_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand_write)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MASInterfaceTypeDownType_sendCommand_write_memoryID_Equal(val1.memoryID, val2.memoryID);

    if ret then
        ret := MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Equal(val1.memoryAddress, val2.memoryAddress);

        if ret then
            ret := (val1.data_value = val2.data_value);

        end if;
    end if;
	return ret;

end MASInterfaceTypeDownType_sendCommand_write_Equal;

function MASInterfaceTypeDownType_sendCommand_Equal(val1, val2: in MASInterfaceTypeDownType_sendCommand)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when sendCommand_readExtendedstatusormodetype_PRESENT =>
                ret := TRUE;
            when sendCommand_readStatustype_PRESENT =>
                ret := TRUE;
            when unacknowledgedWrite_PRESENT =>
                ret := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Equal(val1.unacknowledgedWrite.memoryID, val2.unacknowledgedWrite.memoryID);

                if ret then
                    ret := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Equal(val1.unacknowledgedWrite.memoryAddress, val2.unacknowledgedWrite.memoryAddress);

                    if ret then
                        ret := (val1.unacknowledgedWrite.data_value = val2.unacknowledgedWrite.data_value);

                    end if;
                end if;
            when sendCommand_write_PRESENT =>
                ret := MASInterfaceTypeDownType_sendCommand_write_memoryID_Equal(val1.write.memoryID, val2.write.memoryID);

                if ret then
                    ret := MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Equal(val1.write.memoryAddress, val2.write.memoryAddress);

                    if ret then
                        ret := (val1.write.data_value = val2.write.data_value);

                    end if;
                end if;
        end case;
    end if;
	return ret;

end MASInterfaceTypeDownType_sendCommand_Equal;

function MASInterfaceTypeDownType_Equal(val1, val2: in MASInterfaceTypeDownType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when MASInterfaceTypeDownType_sendCommand_PRESENT =>
                ret := val1.sendCommand.kind = val2.sendCommand.kind;
                if ret then
                    case val1.sendCommand.kind is
                        when sendCommand_readExtendedstatusormodetype_PRESENT =>
                            ret := TRUE;
                        when sendCommand_readStatustype_PRESENT =>
                            ret := TRUE;
                        when unacknowledgedWrite_PRESENT =>
                            ret := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Equal(val1.sendCommand.unacknowledgedWrite.memoryID, val2.sendCommand.unacknowledgedWrite.memoryID);

                            if ret then
                                ret := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Equal(val1.sendCommand.unacknowledgedWrite.memoryAddress, val2.sendCommand.unacknowledgedWrite.memoryAddress);

                                if ret then
                                    ret := (val1.sendCommand.unacknowledgedWrite.data_value = val2.sendCommand.unacknowledgedWrite.data_value);

                                end if;
                            end if;
                        when sendCommand_write_PRESENT =>
                            ret := MASInterfaceTypeDownType_sendCommand_write_memoryID_Equal(val1.sendCommand.write.memoryID, val2.sendCommand.write.memoryID);

                            if ret then
                                ret := MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Equal(val1.sendCommand.write.memoryAddress, val2.sendCommand.write.memoryAddress);

                                if ret then
                                    ret := (val1.sendCommand.write.data_value = val2.sendCommand.write.data_value);

                                end if;
                            end if;
                    end case;
                end if;
        end case;
    end if;
	return ret;

end MASInterfaceTypeDownType_Equal;

function MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype_Init return MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype
is
    val: MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype;
begin
    val := (null record);
    return val;
end MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype_Init;
function MASInterfaceTypeDownType_sendCommand_readStatustype_Init return MASInterfaceTypeDownType_sendCommand_readStatustype
is
    val: MASInterfaceTypeDownType_sendCommand_readStatustype;
begin
    val := (null record);
    return val;
end MASInterfaceTypeDownType_sendCommand_readStatustype_Init;
function MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Init return MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID
is
    val: MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID;
begin
    val := 0;
    return val;
end MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Init;
function MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Init return MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress
is
    val: MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress;
begin
    val := 100;
    return val;
end MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Init;
function MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_Init return MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite
is
    val: MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite;
begin

    --set memoryID 
    val.memoryID := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryID_Init;
    --set memoryAddress 
    val.memoryAddress := MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_memoryAddress_Init;
    --set data_value 
    val.data_value := Demo.ReadStatusModeCommandTypeT_Init;
    return val;
end MASInterfaceTypeDownType_sendCommand_unacknowledgedWrite_Init;
function MASInterfaceTypeDownType_sendCommand_write_memoryID_Init return MASInterfaceTypeDownType_sendCommand_write_memoryID
is
    val: MASInterfaceTypeDownType_sendCommand_write_memoryID;
begin
    val := 0;
    return val;
end MASInterfaceTypeDownType_sendCommand_write_memoryID_Init;
function MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Init return MASInterfaceTypeDownType_sendCommand_write_memoryAddress
is
    val: MASInterfaceTypeDownType_sendCommand_write_memoryAddress;
begin
    val := 100;
    return val;
end MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Init;
function MASInterfaceTypeDownType_sendCommand_write_Init return MASInterfaceTypeDownType_sendCommand_write
is
    val: MASInterfaceTypeDownType_sendCommand_write;
begin

    --set memoryID 
    val.memoryID := MASInterfaceTypeDownType_sendCommand_write_memoryID_Init;
    --set memoryAddress 
    val.memoryAddress := MASInterfaceTypeDownType_sendCommand_write_memoryAddress_Init;
    --set data_value 
    val.data_value := Demo.ReadStatusModeCommandTypeT_Init;
    return val;
end MASInterfaceTypeDownType_sendCommand_write_Init;
function MASInterfaceTypeDownType_sendCommand_Init return MASInterfaceTypeDownType_sendCommand
is
    val: MASInterfaceTypeDownType_sendCommand;
begin
    --set readExtendedstatusormodetype 
    declare
        readExtendedstatusormodetype_tmp:MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype;
    begin
        val.readExtendedstatusormodetype := MASInterfaceTypeDownType_sendCommand_readExtendedstatusormodetype_Init;
        val := MASInterfaceTypeDownType_sendCommand'(kind => sendCommand_readExtendedstatusormodetype_PRESENT, readExtendedstatusormodetype => readExtendedstatusormodetype_tmp);
    end;
    return val;
end MASInterfaceTypeDownType_sendCommand_Init;
function MASInterfaceTypeDownType_Init return MASInterfaceTypeDownType
is
    val: MASInterfaceTypeDownType;
begin
    --set sendCommand 
    declare
        sendCommand_tmp:MASInterfaceTypeDownType_sendCommand;
    begin
        val.sendCommand := MASInterfaceTypeDownType_sendCommand_Init;
        val := MASInterfaceTypeDownType'(kind => MASInterfaceTypeDownType_sendCommand_PRESENT, sendCommand => sendCommand_tmp);
    end;
    return val;
end MASInterfaceTypeDownType_Init;

FUNCTION MASInterfaceTypeDownType_IsConstraintValid(val : in MASInterfaceTypeDownType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN MASInterfaceTypeDownType_sendCommand_PRESENT =>
            case val.sendCommand.kind is
                WHEN sendCommand_readExtendedstatusormodetype_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                WHEN sendCommand_readStatustype_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                WHEN unacknowledgedWrite_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.sendCommand.unacknowledgedWrite.memoryID <= 65535) AND (val.sendCommand.unacknowledgedWrite.memoryID <= 0), ErrorCode => ERR_MASINTERFACETYPEDOWNTYPE_SENDCOMMAND_UNACKNOWLEDGEDWRITE_MEMORYID);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.sendCommand.unacknowledgedWrite.memoryAddress <= 4294967296) AND ((100 <= val.sendCommand.unacknowledgedWrite.memoryAddress) AND (val.sendCommand.unacknowledgedWrite.memoryAddress <= 100)), ErrorCode => ERR_MASINTERFACETYPEDOWNTYPE_SENDCOMMAND_UNACKNOWLEDGEDWRITE_MEMORYADDRESS);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.sendCommand.unacknowledgedWrite.data_value = Demo.readStatus)) OR ((val.sendCommand.unacknowledgedWrite.data_value = Demo.readMode))), ErrorCode => ERR_MASINTERFACETYPEDOWNTYPE_SENDCOMMAND_UNACKNOWLEDGEDWRITE_DATA_VALUE);
                        end if;

                    end if;

                WHEN sendCommand_write_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.sendCommand.write.memoryID <= 65535) AND (val.sendCommand.write.memoryID <= 0), ErrorCode => ERR_MASINTERFACETYPEDOWNTYPE_SENDCOMMAND_WRITE_MEMORYID);
                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.sendCommand.write.memoryAddress <= 4294967296) AND ((100 <= val.sendCommand.write.memoryAddress) AND (val.sendCommand.write.memoryAddress <= 100)), ErrorCode => ERR_MASINTERFACETYPEDOWNTYPE_SENDCOMMAND_WRITE_MEMORYADDRESS);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.sendCommand.write.data_value = Demo.readStatus)) OR ((val.sendCommand.write.data_value = Demo.readMode))), ErrorCode => ERR_MASINTERFACETYPEDOWNTYPE_SENDCOMMAND_WRITE_DATA_VALUE);
                        end if;

                    end if;

            end case;
    end case;
    RETURN ret;
END MASInterfaceTypeDownType_IsConstraintValid;



function MASInterfaceTypeProviderType_Equal(val1, val2: in MASInterfaceTypeProviderType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.inputReady = val2.inputReady);

    if ret then
        ret := MASInterfaceTypeDownType_Equal(val1.inputData, val2.inputData);

        if ret then
            ret := MASInterfaceTypeUpType_Equal(val1.outputData, val2.outputData);

        end if;
    end if;
	return ret;

end MASInterfaceTypeProviderType_Equal;

function MASInterfaceTypeProviderType_Init return MASInterfaceTypeProviderType
is
    val: MASInterfaceTypeProviderType;
begin

    --set inputReady 
    val.inputReady := FALSE;
    --set inputData 
    val.inputData := MASInterfaceTypeDownType_Init;
    --set outputData 
    val.outputData := MASInterfaceTypeUpType_Init;
    return val;
end MASInterfaceTypeProviderType_Init;

FUNCTION MASInterfaceTypeProviderType_IsConstraintValid(val : in MASInterfaceTypeProviderType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTREADY);
    if ret.Success then
        case val.inputData.kind is
            WHEN MASInterfaceTypeDownType_sendCommand_PRESENT =>
                case val.inputData.sendCommand.kind is
                    WHEN sendCommand_readExtendedstatusormodetype_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                    WHEN sendCommand_readStatustype_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                    WHEN unacknowledgedWrite_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.sendCommand.unacknowledgedWrite.memoryID <= 65535) AND (val.inputData.sendCommand.unacknowledgedWrite.memoryID <= 0), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_UNACKNOWLEDGEDWRITE_MEMORYID);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.sendCommand.unacknowledgedWrite.memoryAddress <= 4294967296) AND ((100 <= val.inputData.sendCommand.unacknowledgedWrite.memoryAddress) AND (val.inputData.sendCommand.unacknowledgedWrite.memoryAddress <= 100)), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_UNACKNOWLEDGEDWRITE_MEMORYADDRESS);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.inputData.sendCommand.unacknowledgedWrite.data_value = Demo.readStatus)) OR ((val.inputData.sendCommand.unacknowledgedWrite.data_value = Demo.readMode))), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_UNACKNOWLEDGEDWRITE_DATA_VALUE);
                            end if;

                        end if;

                    WHEN sendCommand_write_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.sendCommand.write.memoryID <= 65535) AND (val.inputData.sendCommand.write.memoryID <= 0), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_WRITE_MEMORYID);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.sendCommand.write.memoryAddress <= 4294967296) AND ((100 <= val.inputData.sendCommand.write.memoryAddress) AND (val.inputData.sendCommand.write.memoryAddress <= 100)), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_WRITE_MEMORYADDRESS);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.inputData.sendCommand.write.data_value = Demo.readStatus)) OR ((val.inputData.sendCommand.write.data_value = Demo.readMode))), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_INPUTDATA_SENDCOMMAND_WRITE_DATA_VALUE);
                            end if;

                        end if;

                end case;
        end case;
        if ret.Success then
            case val.outputData.kind is
                WHEN MASInterfaceTypeUpType_replyToCommand_PRESENT =>
                    case val.outputData.replyToCommand.kind is
                        WHEN replyToCommand_readExtendedstatusormodetype_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.readExtendedstatusormodetype.data_value.queryCount <= 255), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_QUERYCOUNT);
                            if ret.Success then
                                case val.outputData.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.kind is
                                    WHEN Demo.ExtendedStatusOrModeTypeT_body_choice_mode_PRESENT =>
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.mode.mode <= 255), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_BODY_CHOICE_MODE_MODE);
                                    WHEN Demo.body_choice_status_PRESENT =>
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.status.status <= 255), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_BODY_CHOICE_STATUS_STATUS);
                                end case;
                            end if;

                        WHEN replyToCommand_readStatustype_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_STATUSFLAG1);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_STATUSFLAG2);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.replyToCommand.readStatustype.data_value.opCount <= 39), ErrorCode => ERR_MASINTERFACETYPEPROVIDERTYPE_OUTPUTDATA_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_OPCOUNT);
                                end if;

                            end if;

                        WHEN replyToCommand_write_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                    end case;
            end case;
        end if;

    end if;

    RETURN ret;
END MASInterfaceTypeProviderType_IsConstraintValid;



function MASInterfaceTypeClientType_Equal(val1, val2: in MASInterfaceTypeClientType)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.inputReady = val2.inputReady);

    if ret then
        ret := MASInterfaceTypeUpType_Equal(val1.inputData, val2.inputData);

        if ret then
            ret := MASInterfaceTypeDownType_Equal(val1.outputData, val2.outputData);

        end if;
    end if;
	return ret;

end MASInterfaceTypeClientType_Equal;

function MASInterfaceTypeClientType_Init return MASInterfaceTypeClientType
is
    val: MASInterfaceTypeClientType;
begin

    --set inputReady 
    val.inputReady := FALSE;
    --set inputData 
    val.inputData := MASInterfaceTypeUpType_Init;
    --set outputData 
    val.outputData := MASInterfaceTypeDownType_Init;
    return val;
end MASInterfaceTypeClientType_Init;

FUNCTION MASInterfaceTypeClientType_IsConstraintValid(val : in MASInterfaceTypeClientType) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTREADY);
    if ret.Success then
        case val.inputData.kind is
            WHEN MASInterfaceTypeUpType_replyToCommand_PRESENT =>
                case val.inputData.replyToCommand.kind is
                    WHEN replyToCommand_readExtendedstatusormodetype_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.readExtendedstatusormodetype.data_value.queryCount <= 255), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_QUERYCOUNT);
                        if ret.Success then
                            case val.inputData.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.kind is
                                WHEN Demo.ExtendedStatusOrModeTypeT_body_choice_mode_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.mode.mode <= 255), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_BODY_CHOICE_MODE_MODE);
                                WHEN Demo.body_choice_status_PRESENT =>
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.readExtendedstatusormodetype.data_value.body_choice.status.status <= 255), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_READEXTENDEDSTATUSORMODETYPE_DATA_VALUE_BODY_CHOICE_STATUS_STATUS);
                            end case;
                        end if;

                    WHEN replyToCommand_readStatustype_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_STATUSFLAG1);
                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_STATUSFLAG2);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.inputData.replyToCommand.readStatustype.data_value.opCount <= 39), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_INPUTDATA_REPLYTOCOMMAND_READSTATUSTYPE_DATA_VALUE_OPCOUNT);
                            end if;

                        end if;

                    WHEN replyToCommand_write_PRESENT =>
                        ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                end case;
        end case;
        if ret.Success then
            case val.outputData.kind is
                WHEN MASInterfaceTypeDownType_sendCommand_PRESENT =>
                    case val.outputData.sendCommand.kind is
                        WHEN sendCommand_readExtendedstatusormodetype_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                        WHEN sendCommand_readStatustype_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
                        WHEN unacknowledgedWrite_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.sendCommand.unacknowledgedWrite.memoryID <= 65535) AND (val.outputData.sendCommand.unacknowledgedWrite.memoryID <= 0), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_UNACKNOWLEDGEDWRITE_MEMORYID);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.sendCommand.unacknowledgedWrite.memoryAddress <= 4294967296) AND ((100 <= val.outputData.sendCommand.unacknowledgedWrite.memoryAddress) AND (val.outputData.sendCommand.unacknowledgedWrite.memoryAddress <= 100)), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_UNACKNOWLEDGEDWRITE_MEMORYADDRESS);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.outputData.sendCommand.unacknowledgedWrite.data_value = Demo.readStatus)) OR ((val.outputData.sendCommand.unacknowledgedWrite.data_value = Demo.readMode))), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_UNACKNOWLEDGEDWRITE_DATA_VALUE);
                                end if;

                            end if;

                        WHEN sendCommand_write_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.sendCommand.write.memoryID <= 65535) AND (val.outputData.sendCommand.write.memoryID <= 0), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_WRITE_MEMORYID);
                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => (val.outputData.sendCommand.write.memoryAddress <= 4294967296) AND ((100 <= val.outputData.sendCommand.write.memoryAddress) AND (val.outputData.sendCommand.write.memoryAddress <= 100)), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_WRITE_MEMORYADDRESS);
                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.outputData.sendCommand.write.data_value = Demo.readStatus)) OR ((val.outputData.sendCommand.write.data_value = Demo.readMode))), ErrorCode => ERR_MASINTERFACETYPECLIENTTYPE_OUTPUTDATA_SENDCOMMAND_WRITE_DATA_VALUE);
                                end if;

                            end if;

                    end case;
            end case;
        end if;

    end if;

    RETURN ret;
END MASInterfaceTypeClientType_IsConstraintValid;


 

END CcsdsSoisSubnetworkInterfaces;