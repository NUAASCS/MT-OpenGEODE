-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
USE adaasn1rtl;
use type adaasn1rtl.OctetBuffer;
use type adaasn1rtl.BitArray;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;
--# inherit ;


PACKAGE TASTE_BasicTypes with SPARK_Mode
IS


SUBTYPE Boolean is adaasn1rtl.Asn1Boolean;


function Boolean_Equal(val1, val2: in Boolean) return Boolean;

function Boolean_Init return Boolean;

ERR_BOOLEAN:CONSTANT INTEGER := 1; -- 
FUNCTION Boolean_IsConstraintValid(val : in Boolean) return adaasn1rtl.ASN1_RESULT;
SUBTYPE TASTE_Peek_id is adaasn1rtl.Asn1UInt range 0 .. 4294967295;


function TASTE_Peek_id_Equal(val1, val2: in TASTE_Peek_id) return Boolean;

function TASTE_Peek_id_Init return TASTE_Peek_id;

ERR_TASTE_PEEK_ID:CONSTANT INTEGER := 8; -- 
FUNCTION TASTE_Peek_id_IsConstraintValid(val : in TASTE_Peek_id) return adaasn1rtl.ASN1_RESULT;
-- TASTE_Peek_id_list --------------------------------------------
SUBTYPE TASTE_Peek_id_list_index is integer range 1..10;
TYPE TASTE_Peek_id_list_array IS ARRAY (TASTE_Peek_id_list_index) OF TASTE_Peek_id;
SUBTYPE TASTE_Peek_id_list_length_index is integer range 1..10;
TYPE TASTE_Peek_id_list IS  RECORD
    Length : TASTE_Peek_id_list_length_index;
    Data  : TASTE_Peek_id_list_array;
END RECORD;

function TASTE_Peek_id_list_Equal(val1, val2: in TASTE_Peek_id_list) return Boolean;

function TASTE_Peek_id_list_Init return TASTE_Peek_id_list;

ERR_TASTE_PEEK_ID_LIST_ELM:CONSTANT INTEGER := 15; 
ERR_TASTE_PEEK_ID_LIST:CONSTANT INTEGER := 26; 
FUNCTION TASTE_Peek_id_list_IsConstraintValid(val : in TASTE_Peek_id_list) return adaasn1rtl.ASN1_RESULT;
SUBTYPE VariableString_index is integer range 1..10;
SUBTYPE VariableString_array IS adaasn1rtl.OctetBuffer(VariableString_index);
SUBTYPE VariableString_length_index is integer range 1..10;
TYPE VariableString IS  RECORD
    Length : VariableString_length_index;
    Data  : VariableString_array;
END RECORD;

function VariableString_Equal(val1, val2: in VariableString) return Boolean;

function VariableString_Init return VariableString;

ERR_VARIABLESTRING:CONSTANT INTEGER := 33; -- 
FUNCTION VariableString_IsConstraintValid(val : in VariableString) return adaasn1rtl.ASN1_RESULT;
SUBTYPE FixedString_index is integer range 1..5;
SUBTYPE FixedString_array IS adaasn1rtl.OctetBuffer(FixedString_index);
TYPE FixedString IS  RECORD
    Data  : FixedString_array;
END RECORD;

function FixedString_Equal(val1, val2: in FixedString) return Boolean;

function FixedString_Init return FixedString;
-- SeqBool --------------------------------------------
SUBTYPE SeqBool_index is integer range 1..5;
TYPE SeqBool_array IS ARRAY (SeqBool_index) OF adaasn1rtl.Asn1Boolean;
SUBTYPE SeqBool_length_index is integer range 1..5;
TYPE SeqBool IS  RECORD
    Length : SeqBool_length_index;
    Data  : SeqBool_array;
END RECORD;

function SeqBool_Equal(val1, val2: in SeqBool) return Boolean;

function SeqBool_Init return SeqBool;

ERR_SEQBOOL_ELM:CONSTANT INTEGER := 46; 
ERR_SEQBOOL:CONSTANT INTEGER := 53; 
FUNCTION SeqBool_IsConstraintValid(val : in SeqBool) return adaasn1rtl.ASN1_RESULT;
-- SeqBoolFix --------------------------------------------
SUBTYPE SeqBoolFix_index is integer range 1..2;
TYPE SeqBoolFix_array IS ARRAY (SeqBoolFix_index) OF adaasn1rtl.Asn1Boolean;
TYPE SeqBoolFix IS  RECORD
    Data  : SeqBoolFix_array;
END RECORD;

function SeqBoolFix_Equal(val1, val2: in SeqBoolFix) return Boolean;

function SeqBoolFix_Init return SeqBoolFix;

ERR_SEQBOOLFIX_ELM:CONSTANT INTEGER := 60; 
FUNCTION SeqBoolFix_IsConstraintValid(val : in SeqBoolFix) return adaasn1rtl.ASN1_RESULT;
-- SeqEnum --------------------------------------------
SUBTYPE SeqEnum_elem_index_range is integer range 0..1;
TYPE SeqEnum_elem IS (hello2, world2) with Convention => C;
for SeqEnum_elem use
    (hello2 => 0, world2 => 1);
SUBTYPE SeqEnum_index is integer range 1..5;
TYPE SeqEnum_array IS ARRAY (SeqEnum_index) OF SeqEnum_elem;
SUBTYPE SeqEnum_length_index is integer range 1..5;
TYPE SeqEnum IS  RECORD
    Length : SeqEnum_length_index;
    Data  : SeqEnum_array;
END RECORD;

function SeqEnum_elem_Equal(val1, val2: in SeqEnum_elem) return Boolean;

function SeqEnum_Equal(val1, val2: in SeqEnum) return Boolean;

function SeqEnum_elem_Init return SeqEnum_elem;
function SeqEnum_Init return SeqEnum;

ERR_SEQENUM_ELM:CONSTANT INTEGER := 73; 
ERR_SEQENUM:CONSTANT INTEGER := 80; 
FUNCTION SeqEnum_IsConstraintValid(val : in SeqEnum) return adaasn1rtl.ASN1_RESULT;
-- SeqEnumFix --------------------------------------------
SUBTYPE SeqEnumFix_elem_index_range is integer range 0..1;
TYPE SeqEnumFix_elem IS (hello, world) with Convention => C;
for SeqEnumFix_elem use
    (hello => 0, world => 1);
SUBTYPE SeqEnumFix_index is integer range 1..2;
TYPE SeqEnumFix_array IS ARRAY (SeqEnumFix_index) OF SeqEnumFix_elem;
TYPE SeqEnumFix IS  RECORD
    Data  : SeqEnumFix_array;
END RECORD;

function SeqEnumFix_elem_Equal(val1, val2: in SeqEnumFix_elem) return Boolean;

function SeqEnumFix_Equal(val1, val2: in SeqEnumFix) return Boolean;

function SeqEnumFix_elem_Init return SeqEnumFix_elem;
function SeqEnumFix_Init return SeqEnumFix;

ERR_SEQENUMFIX_ELM:CONSTANT INTEGER := 87; 
FUNCTION SeqEnumFix_IsConstraintValid(val : in SeqEnumFix) return adaasn1rtl.ASN1_RESULT;
SUBTYPE MyEnum_index_range is integer range 0..4;
TYPE MyEnum IS (a, b, c, d, eE) with Convention => C;
for MyEnum use
    (a => 0, b => 1, c => 2, d => 3, eE => 4);

function MyEnum_Equal(val1, val2: in MyEnum) return Boolean;

function MyEnum_Init return MyEnum;

ERR_MYENUM:CONSTANT INTEGER := 100; -- 
FUNCTION MyEnum_IsConstraintValid(val : in MyEnum) return adaasn1rtl.ASN1_RESULT;
-- MyChoice --------------------------------------------

SUBTYPE MyChoice_index_range is integer range 0..1;

TYPE MyChoice_selection IS (c1_PRESENT, cDe2_PRESENT);
for MyChoice_selection use
    (c1_PRESENT => 1, cDe2_PRESENT => 2);
for MyChoice_selection'Size use 32;

TYPE MyChoice(kind : MyChoice_selection:= c1_PRESENT) IS 
RECORD
    case kind is
    when c1_PRESENT =>
            c1: adaasn1rtl.Asn1Boolean;
    when cDe2_PRESENT =>
            cDe2: adaasn1rtl.Asn1Boolean;
    end case;
END RECORD;

FOR MyChoice USE 
RECORD
    kind AT 0 RANGE 0..31;
END RECORD;

function MyChoice_Equal(val1, val2: in MyChoice) return Boolean;

function MyChoice_Init return MyChoice;

ERR_MYCHOICE:CONSTANT INTEGER := 121; 
ERR_MYCHOICE_C1:CONSTANT INTEGER := 107; 
ERR_MYCHOICE_CDE2:CONSTANT INTEGER := 114; 
FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT;
-- SeqOpt --------------------------------------------
-- SeqOpt_c --------------------------------------------

TYPE SeqOpt_c IS RECORD 
    a : adaasn1rtl.Asn1Boolean;
END RECORD;
SUBTYPE SeqOpt_d_index is integer range 1..10;
SUBTYPE SeqOpt_d_array IS adaasn1rtl.OctetBuffer(SeqOpt_d_index);
SUBTYPE SeqOpt_d_length_index is integer range 0..10;
TYPE SeqOpt_d IS  RECORD
    Length : SeqOpt_d_length_index;
    Data  : SeqOpt_d_array;
END RECORD;

TYPE SeqOpt_EXIST IS RECORD
    a:adaasn1rtl.BIT;
    c:adaasn1rtl.BIT;
    d:adaasn1rtl.BIT;
END RECORD;
TYPE SeqOpt IS RECORD 
    a : adaasn1rtl.Asn1Boolean;
    b : adaasn1rtl.Asn1Boolean;
    c : SeqOpt_c;
    d : SeqOpt_d;
    
    Exist : SeqOpt_EXIST;

END RECORD;

function SeqOpt_c_Equal(val1, val2: in SeqOpt_c) return Boolean;

function SeqOpt_d_Equal(val1, val2: in SeqOpt_d) return Boolean;

function SeqOpt_Equal(val1, val2: in SeqOpt) return Boolean;

function SeqOpt_c_Init return SeqOpt_c;
function SeqOpt_d_Init return SeqOpt_d;
function SeqOpt_Init return SeqOpt;

ERR_SEQOPT_A:CONSTANT INTEGER := 128; 
ERR_SEQOPT_B:CONSTANT INTEGER := 135; 
ERR_SEQOPT_C_A:CONSTANT INTEGER := 142; 
ERR_SEQOPT_D:CONSTANT INTEGER := 155; 
FUNCTION SeqOpt_IsConstraintValid(val : in SeqOpt) return adaasn1rtl.ASN1_RESULT;
-- SeqNonOpt --------------------------------------------

TYPE SeqNonOpt IS RECORD 
    a : adaasn1rtl.Asn1Boolean;
END RECORD;

function SeqNonOpt_Equal(val1, val2: in SeqNonOpt) return Boolean;

function SeqNonOpt_Init return SeqNonOpt;

ERR_SEQNONOPT_A:CONSTANT INTEGER := 168; 
FUNCTION SeqNonOpt_IsConstraintValid(val : in SeqNonOpt) return adaasn1rtl.ASN1_RESULT;

 

private
   --# hide TASTE_BasicTypes;


END TASTE_BasicTypes;