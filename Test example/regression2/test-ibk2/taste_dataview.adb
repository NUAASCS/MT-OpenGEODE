-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function MyBoolean_Equal(val1, val2: in MyBoolean)
    return Boolean 
is
begin
	return val1 = val2;

end MyBoolean_Equal;

function MyBoolean_Init return MyBoolean
is
    val: MyBoolean;
begin
    val := FALSE;
    return val;
end MyBoolean_Init;

FUNCTION MyBoolean_IsConstraintValid(val : in MyBoolean) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYBOOLEAN);
    RETURN ret;
END MyBoolean_IsConstraintValid;



function My4BitArray_Equal(val1, val2: in My4BitArray)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end My4BitArray_Equal;

function My4BitArray_Init return My4BitArray
is
    val: My4BitArray;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end My4BitArray_Init;

FUNCTION My4BitArray_IsConstraintValid(val : in My4BitArray) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MY4BITARRAY_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END My4BitArray_IsConstraintValid;



function MySrcAddr_Equal(val1, val2: in MySrcAddr) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My4BitArray_Equal(val1, val2);
    return ret;
end MySrcAddr_Equal;

function MySrcAddr_Init return MySrcAddr
is
    val: MySrcAddr;
begin
    val := My4BitArray_Init;
    return val;
end MySrcAddr_Init;

FUNCTION MySrcAddr_IsConstraintValid(val : in MySrcAddr) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYSRCADDR_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MySrcAddr_IsConstraintValid;



function MyDstAddr_Equal(val1, val2: in MyDstAddr) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My4BitArray_Equal(val1, val2);
    return ret;
end MyDstAddr_Equal;

function MyDstAddr_Init return MyDstAddr
is
    val: MyDstAddr;
begin
    val := My4BitArray_Init;
    return val;
end MyDstAddr_Init;

FUNCTION MyDstAddr_IsConstraintValid(val : in MyDstAddr) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYDSTADDR_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyDstAddr_IsConstraintValid;



function MyBa_Equal(val1, val2: in MyBa)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := My4BitArray_Equal(val1.srcAddr, val2.srcAddr);

    if ret then
        ret := My4BitArray_Equal(val1.dstAddr, val2.dstAddr);

    end if;
	return ret;

end MyBa_Equal;

function MyBa_Init return MyBa
is
    val: MyBa;
begin

    --set srcAddr 
    val.srcAddr := MySrcAddr_Init;
    --set dstAddr 
    val.dstAddr := MyDstAddr_Init;
    return val;
end MyBa_Init;

FUNCTION MyBa_IsConstraintValid(val : in MyBa) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.srcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.srcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYBA_SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.dstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.dstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYBA_DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END MyBa_IsConstraintValid;



function MyL3SrcAddr_Equal(val1, val2: in MyL3SrcAddr) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My4BitArray_Equal(val1, val2);
    return ret;
end MyL3SrcAddr_Equal;

function MyL3SrcAddr_Init return MyL3SrcAddr
is
    val: MyL3SrcAddr;
begin
    val := My4BitArray_Init;
    return val;
end MyL3SrcAddr_Init;

FUNCTION MyL3SrcAddr_IsConstraintValid(val : in MyL3SrcAddr) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3SrcAddr_IsConstraintValid;



function MyL3DstAddr_Equal(val1, val2: in MyL3DstAddr) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My4BitArray_Equal(val1, val2);
    return ret;
end MyL3DstAddr_Equal;

function MyL3DstAddr_Init return MyL3DstAddr
is
    val: MyL3DstAddr;
begin
    val := My4BitArray_Init;
    return val;
end MyL3DstAddr_Init;

FUNCTION MyL3DstAddr_IsConstraintValid(val : in MyL3DstAddr) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3DSTADDR_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3DstAddr_IsConstraintValid;



function MyL3Ba_Equal(val1, val2: in MyL3Ba)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := My4BitArray_Equal(val1.l3SrcAddr, val2.l3SrcAddr);

    if ret then
        ret := My4BitArray_Equal(val1.l3DstAddr, val2.l3DstAddr);

    end if;
	return ret;

end MyL3Ba_Equal;

function MyL3Ba_Init return MyL3Ba
is
    val: MyL3Ba;
begin

    --set l3SrcAddr 
    val.l3SrcAddr := MyL3SrcAddr_Init;
    --set l3DstAddr 
    val.l3DstAddr := MyL3DstAddr_Init;
    return val;
end MyL3Ba_Init;

FUNCTION MyL3Ba_IsConstraintValid(val : in MyL3Ba) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.l3SrcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.l3SrcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3BA_L3SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.l3DstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.l3DstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3BA_L3DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END MyL3Ba_IsConstraintValid;



function My8BitArray_Equal(val1, val2: in My8BitArray)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end My8BitArray_Equal;

function My8BitArray_Init return My8BitArray
is
    val: My8BitArray;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 8 loop
        pragma Loop_Invariant (i1 >=1 and i1<=8);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end My8BitArray_Init;

FUNCTION My8BitArray_IsConstraintValid(val : in My8BitArray) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MY8BITARRAY_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END My8BitArray_IsConstraintValid;



function MyFlag_Equal(val1, val2: in MyFlag) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyFlag_Equal;

function MyFlag_Init return MyFlag
is
    val: MyFlag;
begin
    val := My8BitArray_Init;
    return val;
end MyFlag_Init;

FUNCTION MyFlag_IsConstraintValid(val : in MyFlag) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFLAG_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyFlag_IsConstraintValid;



function MyDestinationAddress_Equal(val1, val2: in MyDestinationAddress)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MyDestinationAddress_Equal;

function MyDestinationAddress_Init return MyDestinationAddress
is
    val: MyDestinationAddress;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end MyDestinationAddress_Init;

FUNCTION MyDestinationAddress_IsConstraintValid(val : in MyDestinationAddress) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 7);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYDESTINATIONADDRESS_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyDestinationAddress_IsConstraintValid;



function MySourceAddress_Equal(val1, val2: in MySourceAddress)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MySourceAddress_Equal;

function MySourceAddress_Init return MySourceAddress
is
    val: MySourceAddress;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 7 loop
        pragma Loop_Invariant (i1 >=1 and i1<=7);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end MySourceAddress_Init;

FUNCTION MySourceAddress_IsConstraintValid(val : in MySourceAddress) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 7);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYSOURCEADDRESS_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MySourceAddress_IsConstraintValid;



function MyAddr_Equal(val1, val2: in MyAddr)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MyDestinationAddress_Equal(val1.destinationAddress, val2.destinationAddress);

    if ret then
        ret := MySourceAddress_Equal(val1.sourceAddress, val2.sourceAddress);

    end if;
	return ret;

end MyAddr_Equal;

function MyAddr_Init return MyAddr
is
    val: MyAddr;
begin

    --set destinationAddress 
    val.destinationAddress := MyDestinationAddress_Init;
    --set sourceAddress 
    val.sourceAddress := MySourceAddress_Init;
    return val;
end MyAddr_Init;

FUNCTION MyAddr_IsConstraintValid(val : in MyAddr) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.destinationAddress.Data'First;
    while ret.Success and i1 <= 7 loop
        pragma Loop_Invariant (i1 >= val.destinationAddress.Data'First and i1 <= 7);
        i2 := val.destinationAddress.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.destinationAddress.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYADDR_DESTINATIONADDRESS_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.sourceAddress.Data'First;
        while ret.Success and i1 <= 7 loop
            pragma Loop_Invariant (i1 >= val.sourceAddress.Data'First and i1 <= 7);
            i2 := val.sourceAddress.Data(i1).Data'First;
            while ret.Success and i2 <= 8 loop
                pragma Loop_Invariant (i2 >= val.sourceAddress.Data(i1).Data'First and i2 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYADDR_SOURCEADDRESS_ELM_ELM);
                i2 := i2+1;
            end loop;

            i1 := i1+1;
        end loop;

    end if;

    RETURN ret;
END MyAddr_IsConstraintValid;



function MyControl_Equal(val1, val2: in MyControl) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyControl_Equal;

function MyControl_Init return MyControl
is
    val: MyControl;
begin
    val := My8BitArray_Init;
    return val;
end MyControl_Init;

FUNCTION MyControl_IsConstraintValid(val : in MyControl) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCONTROL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyControl_IsConstraintValid;



function MyPid_Equal(val1, val2: in MyPid) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyPid_Equal;

function MyPid_Init return MyPid
is
    val: MyPid;
begin
    val := My8BitArray_Init;
    return val;
end MyPid_Init;

FUNCTION MyPid_IsConstraintValid(val : in MyPid) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPID_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyPid_IsConstraintValid;



function MyCntrl_Equal(val1, val2: in MyCntrl) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyCntrl_Equal;

function MyCntrl_Init return MyCntrl
is
    val: MyCntrl;
begin
    val := My8BitArray_Init;
    return val;
end MyCntrl_Init;

FUNCTION MyCntrl_IsConstraintValid(val : in MyCntrl) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCNTRL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyCntrl_IsConstraintValid;



function MyCode_Equal(val1, val2: in MyCode) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyCode_Equal;

function MyCode_Init return MyCode
is
    val: MyCode;
begin
    val := My8BitArray_Init;
    return val;
end MyCode_Init;

FUNCTION MyCode_IsConstraintValid(val : in MyCode) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCODE_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyCode_IsConstraintValid;



function MyOperationData_Equal(val1, val2: in MyOperationData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyOperationData_Equal;

function MyOperationData_Init return MyOperationData
is
    val: MyOperationData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 250 loop
        pragma Loop_Invariant (i1 >=1 and i1<=250);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyOperationData_Init;

FUNCTION MyOperationData_IsConstraintValid(val : in MyOperationData) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 250)), ErrorCode => ERR_MYOPERATIONDATA);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYOPERATIONDATA_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyOperationData_IsConstraintValid;



function MyL3MissingStack_Equal(val1, val2: in MyL3MissingStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3MissingStack_Equal;

function MyL3MissingStack_Init return MyL3MissingStack
is
    val: MyL3MissingStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3MissingStack_Init;

FUNCTION MyL3MissingStack_IsConstraintValid(val : in MyL3MissingStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 255)), ErrorCode => ERR_MYL3MISSINGSTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3MISSINGSTACK_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3MissingStack_IsConstraintValid;



function MyL3Cntrl_Equal(val1, val2: in MyL3Cntrl) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyL3Cntrl_Equal;

function MyL3Cntrl_Init return MyL3Cntrl
is
    val: MyL3Cntrl;
begin
    val := My8BitArray_Init;
    return val;
end MyL3Cntrl_Init;

FUNCTION MyL3Cntrl_IsConstraintValid(val : in MyL3Cntrl) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3CNTRL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Cntrl_IsConstraintValid;



function MyL3Code_Equal(val1, val2: in MyL3Code) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyL3Code_Equal;

function MyL3Code_Init return MyL3Code
is
    val: MyL3Code;
begin
    val := My8BitArray_Init;
    return val;
end MyL3Code_Init;

FUNCTION MyL3Code_IsConstraintValid(val : in MyL3Code) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3CODE_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Code_IsConstraintValid;



function MyL3Fnum_Equal(val1, val2: in MyL3Fnum) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyL3Fnum_Equal;

function MyL3Fnum_Init return MyL3Fnum
is
    val: MyL3Fnum;
begin
    val := My8BitArray_Init;
    return val;
end MyL3Fnum_Init;

FUNCTION MyL3Fnum_IsConstraintValid(val : in MyL3Fnum) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FNUM_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Fnum_IsConstraintValid;



function MyL3Data_Equal(val1, val2: in MyL3Data)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3Data_Equal;

function MyL3Data_Init return MyL3Data
is
    val: MyL3Data;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 245 loop
        pragma Loop_Invariant (i1 >=1 and i1<=245);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3Data_Init;

FUNCTION MyL3Data_IsConstraintValid(val : in MyL3Data) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 245)), ErrorCode => ERR_MYL3DATA);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3DATA_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Data_IsConstraintValid;



function MyL3Stack_Equal(val1, val2: in MyL3Stack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := MyL3Data_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3Stack_Equal;

function MyL3Stack_Init return MyL3Stack
is
    val: MyL3Stack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := MyL3Data_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3Stack_Init;

FUNCTION MyL3Stack_IsConstraintValid(val : in MyL3Stack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
    i3:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 255)), ErrorCode => ERR_MYL3STACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Data(i1).Length) AND (val.Data(i1).Length <= 245)), ErrorCode => ERR_MYL3STACK_ELM);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= val.Data(i1).Length loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= val.Data(i1).Length);
            i3 := val.Data(i1).Data(i2).Data'First;
            while ret.Success and i3 <= 8 loop
                pragma Loop_Invariant (i3 >= val.Data(i1).Data(i2).Data'First and i3 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3STACK_ELM_ELM_ELM);
                i3 := i3+1;
            end loop;

            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Stack_IsConstraintValid;



function MyL3Lfn_Equal(val1, val2: in MyL3Lfn) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyL3Lfn_Equal;

function MyL3Lfn_Init return MyL3Lfn
is
    val: MyL3Lfn;
begin
    val := My8BitArray_Init;
    return val;
end MyL3Lfn_Init;

FUNCTION MyL3Lfn_IsConstraintValid(val : in MyL3Lfn) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3LFN_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Lfn_IsConstraintValid;



function MyL3Hfn_Equal(val1, val2: in MyL3Hfn) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My8BitArray_Equal(val1, val2);
    return ret;
end MyL3Hfn_Equal;

function MyL3Hfn_Init return MyL3Hfn
is
    val: MyL3Hfn;
begin
    val := My8BitArray_Init;
    return val;
end MyL3Hfn_Init;

FUNCTION MyL3Hfn_IsConstraintValid(val : in MyL3Hfn) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3HFN_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Hfn_IsConstraintValid;



function MyL3Rrq_Equal(val1, val2: in MyL3Rrq)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3Rrq_Equal;

function MyL3Rrq_Init return MyL3Rrq
is
    val: MyL3Rrq;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 244 loop
        pragma Loop_Invariant (i1 >=1 and i1<=244);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3Rrq_Init;

FUNCTION MyL3Rrq_IsConstraintValid(val : in MyL3Rrq) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 244)), ErrorCode => ERR_MYL3RRQ);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3RRQ_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Rrq_IsConstraintValid;



function MyRawData_Equal(val1, val2: in MyRawData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := My8BitArray_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyRawData_Equal;

function MyRawData_Init return MyRawData
is
    val: MyRawData;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 62475 loop
        pragma Loop_Invariant (i1 >=1 and i1<=62475);
        val.Data(i1) := My8BitArray_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyRawData_Init;

FUNCTION MyRawData_IsConstraintValid(val : in MyRawData) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 62475)), ErrorCode => ERR_MYRAWDATA);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        i2 := val.Data(i1).Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYRAWDATA_ELM_ELM);
            i2 := i2+1;
        end loop;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyRawData_IsConstraintValid;



function My8BitArrayInteger_Equal(val1, val2: in My8BitArrayInteger)
    return Boolean 
is
begin
	return val1 = val2;

end My8BitArrayInteger_Equal;

function My8BitArrayInteger_Init return My8BitArrayInteger
is
    val: My8BitArrayInteger;
begin
    val := 0;
    return val;
end My8BitArrayInteger_Init;

FUNCTION My8BitArrayInteger_IsConstraintValid(val : in My8BitArrayInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 7), ErrorCode => ERR_MY8BITARRAYINTEGER);
    RETURN ret;
END My8BitArrayInteger_IsConstraintValid;



function My8BitArrayValueInteger_Equal(val1, val2: in My8BitArrayValueInteger)
    return Boolean 
is
begin
	return val1 = val2;

end My8BitArrayValueInteger_Equal;

function My8BitArrayValueInteger_Init return My8BitArrayValueInteger
is
    val: My8BitArrayValueInteger;
begin
    val := 0;
    return val;
end My8BitArrayValueInteger_Init;

FUNCTION My8BitArrayValueInteger_IsConstraintValid(val : in My8BitArrayValueInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_MY8BITARRAYVALUEINTEGER);
    RETURN ret;
END My8BitArrayValueInteger_IsConstraintValid;



function My16BitArray_Equal(val1, val2: in My16BitArray)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end My16BitArray_Equal;

function My16BitArray_Init return My16BitArray
is
    val: My16BitArray;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 16 loop
        pragma Loop_Invariant (i1 >=1 and i1<=16);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end My16BitArray_Init;

FUNCTION My16BitArray_IsConstraintValid(val : in My16BitArray) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MY16BITARRAY_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END My16BitArray_IsConstraintValid;



function MyIfcs_Equal(val1, val2: in MyIfcs) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My16BitArray_Equal(val1, val2);
    return ret;
end MyIfcs_Equal;

function MyIfcs_Init return MyIfcs
is
    val: MyIfcs;
begin
    val := My16BitArray_Init;
    return val;
end MyIfcs_Init;

FUNCTION MyIfcs_IsConstraintValid(val : in MyIfcs) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYIFCS_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyIfcs_IsConstraintValid;



function MyAuth_Equal(val1, val2: in MyAuth) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My16BitArray_Equal(val1, val2);
    return ret;
end MyAuth_Equal;

function MyAuth_Init return MyAuth
is
    val: MyAuth;
begin
    val := My16BitArray_Init;
    return val;
end MyAuth_Init;

FUNCTION MyAuth_IsConstraintValid(val : in MyAuth) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYAUTH_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyAuth_IsConstraintValid;



function MyInfo_Equal(val1, val2: in MyInfo)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MyBa_Equal(val1.ba, val2.ba);

    if ret then
        ret := My8BitArray_Equal(val1.cntrl, val2.cntrl);

        if ret then
            ret := My8BitArray_Equal(val1.code, val2.code);

            if ret then
                ret := MyOperationData_Equal(val1.operationData, val2.operationData);

                if ret then
                    ret := My16BitArray_Equal(val1.ifcs, val2.ifcs);

                    if ret then
                        ret := val1.Exist.auth = val2.Exist.auth;
                        if ret and then val1.Exist.auth = 1 then
                            ret := My16BitArray_Equal(val1.auth, val2.auth);
                        end if;

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end MyInfo_Equal;

function MyInfo_Init return MyInfo
is
    val: MyInfo;
begin

    --set ba 
    val.ba := MyBa_Init;
    --set cntrl 
    val.cntrl := MyCntrl_Init;
    --set code 
    val.code := MyCode_Init;
    --set operationData 
    val.operationData := MyOperationData_Init;
    --set ifcs 
    val.ifcs := MyIfcs_Init;
    --set auth 
    val.exist.auth := 1;
    val.auth := MyAuth_Init;
    return val;
end MyInfo_Init;

FUNCTION MyInfo_IsConstraintValid(val : in MyInfo) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.ba.srcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.ba.srcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_BA_SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.ba.dstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.ba.dstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_BA_DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    if ret.Success then
        i1 := val.cntrl.Data'First;
        while ret.Success and i1 <= 8 loop
            pragma Loop_Invariant (i1 >= val.cntrl.Data'First and i1 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_CNTRL_ELM);
            i1 := i1+1;
        end loop;

        if ret.Success then
            i1 := val.code.Data'First;
            while ret.Success and i1 <= 8 loop
                pragma Loop_Invariant (i1 >= val.code.Data'First and i1 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_CODE_ELM);
                i1 := i1+1;
            end loop;

            if ret.Success then
                ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.operationData.Length) AND (val.operationData.Length <= 250)), ErrorCode => ERR_MYINFO_OPERATIONDATA);
                i1 := val.operationData.Data'First;
                while ret.Success and i1 <= val.operationData.Length loop
                    pragma Loop_Invariant (i1 >= val.operationData.Data'First and i1 <= val.operationData.Length);
                    i2 := val.operationData.Data(i1).Data'First;
                    while ret.Success and i2 <= 8 loop
                        pragma Loop_Invariant (i2 >= val.operationData.Data(i1).Data'First and i2 <= 8);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_OPERATIONDATA_ELM_ELM);
                        i2 := i2+1;
                    end loop;

                    i1 := i1+1;
                end loop;

                if ret.Success then
                    i1 := val.ifcs.Data'First;
                    while ret.Success and i1 <= 16 loop
                        pragma Loop_Invariant (i1 >= val.ifcs.Data'First and i1 <= 16);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_IFCS_ELM);
                        i1 := i1+1;
                    end loop;

                    if ret.Success then
                        if val.Exist.auth = 1 then
                            i1 := val.auth.Data'First;
                            while ret.Success and i1 <= 16 loop
                                pragma Loop_Invariant (i1 >= val.auth.Data'First and i1 <= 16);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINFO_AUTH_ELM);
                                i1 := i1+1;
                            end loop;

                        end if;
                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END MyInfo_IsConstraintValid;



function MyFcs_Equal(val1, val2: in MyFcs) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My16BitArray_Equal(val1, val2);
    return ret;
end MyFcs_Equal;

function MyFcs_Init return MyFcs
is
    val: MyFcs;
begin
    val := My16BitArray_Init;
    return val;
end MyFcs_Init;

FUNCTION MyFcs_IsConstraintValid(val : in MyFcs) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFCS_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyFcs_IsConstraintValid;



function MyFrame_Equal(val1, val2: in MyFrame)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := My8BitArray_Equal(val1.startFlag, val2.startFlag);

    if ret then
        ret := MyAddr_Equal(val1.addr, val2.addr);

        if ret then
            ret := My8BitArray_Equal(val1.control, val2.control);

            if ret then
                ret := My8BitArray_Equal(val1.pid, val2.pid);

                if ret then
                    ret := MyInfo_Equal(val1.info, val2.info);

                    if ret then
                        ret := My16BitArray_Equal(val1.fcs, val2.fcs);

                        if ret then
                            ret := My8BitArray_Equal(val1.endFlag, val2.endFlag);

                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end MyFrame_Equal;

function MyFrame_Init return MyFrame
is
    val: MyFrame;
begin

    --set startFlag 
    val.startFlag := MyFlag_Init;
    --set addr 
    val.addr := MyAddr_Init;
    --set control 
    val.control := MyControl_Init;
    --set pid 
    val.pid := MyPid_Init;
    --set info 
    val.info := MyInfo_Init;
    --set fcs 
    val.fcs := MyFcs_Init;
    --set endFlag 
    val.endFlag := MyFlag_Init;
    return val;
end MyFrame_Init;

FUNCTION MyFrame_IsConstraintValid(val : in MyFrame) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.startFlag.Data'First;
    while ret.Success and i1 <= 8 loop
        pragma Loop_Invariant (i1 >= val.startFlag.Data'First and i1 <= 8);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_STARTFLAG_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.addr.destinationAddress.Data'First;
        while ret.Success and i1 <= 7 loop
            pragma Loop_Invariant (i1 >= val.addr.destinationAddress.Data'First and i1 <= 7);
            i2 := val.addr.destinationAddress.Data(i1).Data'First;
            while ret.Success and i2 <= 8 loop
                pragma Loop_Invariant (i2 >= val.addr.destinationAddress.Data(i1).Data'First and i2 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_ADDR_DESTINATIONADDRESS_ELM_ELM);
                i2 := i2+1;
            end loop;

            i1 := i1+1;
        end loop;

        if ret.Success then
            i1 := val.addr.sourceAddress.Data'First;
            while ret.Success and i1 <= 7 loop
                pragma Loop_Invariant (i1 >= val.addr.sourceAddress.Data'First and i1 <= 7);
                i2 := val.addr.sourceAddress.Data(i1).Data'First;
                while ret.Success and i2 <= 8 loop
                    pragma Loop_Invariant (i2 >= val.addr.sourceAddress.Data(i1).Data'First and i2 <= 8);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_ADDR_SOURCEADDRESS_ELM_ELM);
                    i2 := i2+1;
                end loop;

                i1 := i1+1;
            end loop;

        end if;

        if ret.Success then
            i1 := val.control.Data'First;
            while ret.Success and i1 <= 8 loop
                pragma Loop_Invariant (i1 >= val.control.Data'First and i1 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_CONTROL_ELM);
                i1 := i1+1;
            end loop;

            if ret.Success then
                i1 := val.pid.Data'First;
                while ret.Success and i1 <= 8 loop
                    pragma Loop_Invariant (i1 >= val.pid.Data'First and i1 <= 8);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_PID_ELM);
                    i1 := i1+1;
                end loop;

                if ret.Success then
                    i1 := val.info.ba.srcAddr.Data'First;
                    while ret.Success and i1 <= 4 loop
                        pragma Loop_Invariant (i1 >= val.info.ba.srcAddr.Data'First and i1 <= 4);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_BA_SRCADDR_ELM);
                        i1 := i1+1;
                    end loop;

                    if ret.Success then
                        i1 := val.info.ba.dstAddr.Data'First;
                        while ret.Success and i1 <= 4 loop
                            pragma Loop_Invariant (i1 >= val.info.ba.dstAddr.Data'First and i1 <= 4);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_BA_DSTADDR_ELM);
                            i1 := i1+1;
                        end loop;

                    end if;

                    if ret.Success then
                        i1 := val.info.cntrl.Data'First;
                        while ret.Success and i1 <= 8 loop
                            pragma Loop_Invariant (i1 >= val.info.cntrl.Data'First and i1 <= 8);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_CNTRL_ELM);
                            i1 := i1+1;
                        end loop;

                        if ret.Success then
                            i1 := val.info.code.Data'First;
                            while ret.Success and i1 <= 8 loop
                                pragma Loop_Invariant (i1 >= val.info.code.Data'First and i1 <= 8);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_CODE_ELM);
                                i1 := i1+1;
                            end loop;

                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.info.operationData.Length) AND (val.info.operationData.Length <= 250)), ErrorCode => ERR_MYFRAME_INFO_OPERATIONDATA);
                                i1 := val.info.operationData.Data'First;
                                while ret.Success and i1 <= val.info.operationData.Length loop
                                    pragma Loop_Invariant (i1 >= val.info.operationData.Data'First and i1 <= val.info.operationData.Length);
                                    i2 := val.info.operationData.Data(i1).Data'First;
                                    while ret.Success and i2 <= 8 loop
                                        pragma Loop_Invariant (i2 >= val.info.operationData.Data(i1).Data'First and i2 <= 8);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_OPERATIONDATA_ELM_ELM);
                                        i2 := i2+1;
                                    end loop;

                                    i1 := i1+1;
                                end loop;

                                if ret.Success then
                                    i1 := val.info.ifcs.Data'First;
                                    while ret.Success and i1 <= 16 loop
                                        pragma Loop_Invariant (i1 >= val.info.ifcs.Data'First and i1 <= 16);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_IFCS_ELM);
                                        i1 := i1+1;
                                    end loop;

                                    if ret.Success then
                                        if val.info.Exist.auth = 1 then
                                            i1 := val.info.auth.Data'First;
                                            while ret.Success and i1 <= 16 loop
                                                pragma Loop_Invariant (i1 >= val.info.auth.Data'First and i1 <= 16);
                                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_INFO_AUTH_ELM);
                                                i1 := i1+1;
                                            end loop;

                                        end if;
                                    end if;

                                end if;

                            end if;

                        end if;

                    end if;

                    if ret.Success then
                        i1 := val.fcs.Data'First;
                        while ret.Success and i1 <= 16 loop
                            pragma Loop_Invariant (i1 >= val.fcs.Data'First and i1 <= 16);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_FCS_ELM);
                            i1 := i1+1;
                        end loop;

                        if ret.Success then
                            i1 := val.endFlag.Data'First;
                            while ret.Success and i1 <= 8 loop
                                pragma Loop_Invariant (i1 >= val.endFlag.Data'First and i1 <= 8);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFRAME_ENDFLAG_ELM);
                                i1 := i1+1;
                            end loop;

                        end if;

                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END MyFrame_IsConstraintValid;



function MyPacket_Equal(val1, val2: in MyPacket)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := MyFrame_Equal(val1.Data(i1), val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyPacket_Equal;

function MyPacket_Init return MyPacket
is
    val: MyPacket;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := MyFrame_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyPacket_Init;

FUNCTION MyPacket_IsConstraintValid(val : in MyPacket) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
    i3:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 255)), ErrorCode => ERR_MYPACKET);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        i2 := val.Data(i1).startFlag.Data'First;
        while ret.Success and i2 <= 8 loop
            pragma Loop_Invariant (i2 >= val.Data(i1).startFlag.Data'First and i2 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_STARTFLAG_ELM);
            i2 := i2+1;
        end loop;

        if ret.Success then
            i2 := val.Data(i1).addr.destinationAddress.Data'First;
            while ret.Success and i2 <= 7 loop
                pragma Loop_Invariant (i2 >= val.Data(i1).addr.destinationAddress.Data'First and i2 <= 7);
                i3 := val.Data(i1).addr.destinationAddress.Data(i2).Data'First;
                while ret.Success and i3 <= 8 loop
                    pragma Loop_Invariant (i3 >= val.Data(i1).addr.destinationAddress.Data(i2).Data'First and i3 <= 8);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_ADDR_DESTINATIONADDRESS_ELM_ELM);
                    i3 := i3+1;
                end loop;

                i2 := i2+1;
            end loop;

            if ret.Success then
                i2 := val.Data(i1).addr.sourceAddress.Data'First;
                while ret.Success and i2 <= 7 loop
                    pragma Loop_Invariant (i2 >= val.Data(i1).addr.sourceAddress.Data'First and i2 <= 7);
                    i3 := val.Data(i1).addr.sourceAddress.Data(i2).Data'First;
                    while ret.Success and i3 <= 8 loop
                        pragma Loop_Invariant (i3 >= val.Data(i1).addr.sourceAddress.Data(i2).Data'First and i3 <= 8);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_ADDR_SOURCEADDRESS_ELM_ELM);
                        i3 := i3+1;
                    end loop;

                    i2 := i2+1;
                end loop;

            end if;

            if ret.Success then
                i2 := val.Data(i1).control.Data'First;
                while ret.Success and i2 <= 8 loop
                    pragma Loop_Invariant (i2 >= val.Data(i1).control.Data'First and i2 <= 8);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_CONTROL_ELM);
                    i2 := i2+1;
                end loop;

                if ret.Success then
                    i2 := val.Data(i1).pid.Data'First;
                    while ret.Success and i2 <= 8 loop
                        pragma Loop_Invariant (i2 >= val.Data(i1).pid.Data'First and i2 <= 8);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_PID_ELM);
                        i2 := i2+1;
                    end loop;

                    if ret.Success then
                        i2 := val.Data(i1).info.ba.srcAddr.Data'First;
                        while ret.Success and i2 <= 4 loop
                            pragma Loop_Invariant (i2 >= val.Data(i1).info.ba.srcAddr.Data'First and i2 <= 4);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_BA_SRCADDR_ELM);
                            i2 := i2+1;
                        end loop;

                        if ret.Success then
                            i2 := val.Data(i1).info.ba.dstAddr.Data'First;
                            while ret.Success and i2 <= 4 loop
                                pragma Loop_Invariant (i2 >= val.Data(i1).info.ba.dstAddr.Data'First and i2 <= 4);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_BA_DSTADDR_ELM);
                                i2 := i2+1;
                            end loop;

                        end if;

                        if ret.Success then
                            i2 := val.Data(i1).info.cntrl.Data'First;
                            while ret.Success and i2 <= 8 loop
                                pragma Loop_Invariant (i2 >= val.Data(i1).info.cntrl.Data'First and i2 <= 8);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_CNTRL_ELM);
                                i2 := i2+1;
                            end loop;

                            if ret.Success then
                                i2 := val.Data(i1).info.code.Data'First;
                                while ret.Success and i2 <= 8 loop
                                    pragma Loop_Invariant (i2 >= val.Data(i1).info.code.Data'First and i2 <= 8);
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_CODE_ELM);
                                    i2 := i2+1;
                                end loop;

                                if ret.Success then
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Data(i1).info.operationData.Length) AND (val.Data(i1).info.operationData.Length <= 250)), ErrorCode => ERR_MYPACKET_ELM_INFO_OPERATIONDATA);
                                    i2 := val.Data(i1).info.operationData.Data'First;
                                    while ret.Success and i2 <= val.Data(i1).info.operationData.Length loop
                                        pragma Loop_Invariant (i2 >= val.Data(i1).info.operationData.Data'First and i2 <= val.Data(i1).info.operationData.Length);
                                        i3 := val.Data(i1).info.operationData.Data(i2).Data'First;
                                        while ret.Success and i3 <= 8 loop
                                            pragma Loop_Invariant (i3 >= val.Data(i1).info.operationData.Data(i2).Data'First and i3 <= 8);
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_OPERATIONDATA_ELM_ELM);
                                            i3 := i3+1;
                                        end loop;

                                        i2 := i2+1;
                                    end loop;

                                    if ret.Success then
                                        i2 := val.Data(i1).info.ifcs.Data'First;
                                        while ret.Success and i2 <= 16 loop
                                            pragma Loop_Invariant (i2 >= val.Data(i1).info.ifcs.Data'First and i2 <= 16);
                                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_IFCS_ELM);
                                            i2 := i2+1;
                                        end loop;

                                        if ret.Success then
                                            if val.Data(i1).info.Exist.auth = 1 then
                                                i2 := val.Data(i1).info.auth.Data'First;
                                                while ret.Success and i2 <= 16 loop
                                                    pragma Loop_Invariant (i2 >= val.Data(i1).info.auth.Data'First and i2 <= 16);
                                                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_INFO_AUTH_ELM);
                                                    i2 := i2+1;
                                                end loop;

                                            end if;
                                        end if;

                                    end if;

                                end if;

                            end if;

                        end if;

                        if ret.Success then
                            i2 := val.Data(i1).fcs.Data'First;
                            while ret.Success and i2 <= 16 loop
                                pragma Loop_Invariant (i2 >= val.Data(i1).fcs.Data'First and i2 <= 16);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_FCS_ELM);
                                i2 := i2+1;
                            end loop;

                            if ret.Success then
                                i2 := val.Data(i1).endFlag.Data'First;
                                while ret.Success and i2 <= 8 loop
                                    pragma Loop_Invariant (i2 >= val.Data(i1).endFlag.Data'First and i2 <= 8);
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYPACKET_ELM_ENDFLAG_ELM);
                                    i2 := i2+1;
                                end loop;

                            end if;

                        end if;

                    end if;

                end if;

            end if;

        end if;

        i1 := i1+1;
    end loop;

    RETURN ret;
END MyPacket_IsConstraintValid;



function MyL3Tte_Equal(val1, val2: in MyL3Tte) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My16BitArray_Equal(val1, val2);
    return ret;
end MyL3Tte_Equal;

function MyL3Tte_Init return MyL3Tte
is
    val: MyL3Tte;
begin
    val := My16BitArray_Init;
    return val;
end MyL3Tte_Init;

FUNCTION MyL3Tte_IsConstraintValid(val : in MyL3Tte) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3TTE_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Tte_IsConstraintValid;



function MyL3Mrt_Equal(val1, val2: in MyL3Mrt) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My16BitArray_Equal(val1, val2);
    return ret;
end MyL3Mrt_Equal;

function MyL3Mrt_Init return MyL3Mrt
is
    val: MyL3Mrt;
begin
    val := My16BitArray_Init;
    return val;
end MyL3Mrt_Init;

FUNCTION MyL3Mrt_IsConstraintValid(val : in MyL3Mrt) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3MRT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Mrt_IsConstraintValid;



function MyAckData_Equal(val1, val2: in MyAckData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MyBa_Equal(val1.ba, val2.ba);

    if ret then
        ret := My8BitArray_Equal(val1.code, val2.code);

        if ret then
            ret := My16BitArray_Equal(val1.l3Mrt, val2.l3Mrt);

            if ret then
                ret := My8BitArray_Equal(val1.l3Lfn, val2.l3Lfn);

                if ret then
                    ret := My8BitArray_Equal(val1.l3Hfn, val2.l3Hfn);

                    if ret then
                        ret := MyL3MissingStack_Equal(val1.l3MissingData, val2.l3MissingData);

                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end MyAckData_Equal;

function MyAckData_Init return MyAckData
is
    val: MyAckData;
begin

    --set ba 
    val.ba := MyBa_Init;
    --set code 
    val.code := MyCode_Init;
    --set l3Mrt 
    val.l3Mrt := MyL3Mrt_Init;
    --set l3Lfn 
    val.l3Lfn := MyL3Lfn_Init;
    --set l3Hfn 
    val.l3Hfn := MyL3Hfn_Init;
    --set l3MissingData 
    val.l3MissingData := MyL3MissingStack_Init;
    return val;
end MyAckData_Init;

FUNCTION MyAckData_IsConstraintValid(val : in MyAckData) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.ba.srcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.ba.srcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_BA_SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.ba.dstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.ba.dstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_BA_DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    if ret.Success then
        i1 := val.code.Data'First;
        while ret.Success and i1 <= 8 loop
            pragma Loop_Invariant (i1 >= val.code.Data'First and i1 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_CODE_ELM);
            i1 := i1+1;
        end loop;

        if ret.Success then
            i1 := val.l3Mrt.Data'First;
            while ret.Success and i1 <= 16 loop
                pragma Loop_Invariant (i1 >= val.l3Mrt.Data'First and i1 <= 16);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_L3MRT_ELM);
                i1 := i1+1;
            end loop;

            if ret.Success then
                i1 := val.l3Lfn.Data'First;
                while ret.Success and i1 <= 8 loop
                    pragma Loop_Invariant (i1 >= val.l3Lfn.Data'First and i1 <= 8);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_L3LFN_ELM);
                    i1 := i1+1;
                end loop;

                if ret.Success then
                    i1 := val.l3Hfn.Data'First;
                    while ret.Success and i1 <= 8 loop
                        pragma Loop_Invariant (i1 >= val.l3Hfn.Data'First and i1 <= 8);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_L3HFN_ELM);
                        i1 := i1+1;
                    end loop;

                    if ret.Success then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.l3MissingData.Length) AND (val.l3MissingData.Length <= 255)), ErrorCode => ERR_MYACKDATA_L3MISSINGDATA);
                        i1 := val.l3MissingData.Data'First;
                        while ret.Success and i1 <= val.l3MissingData.Length loop
                            pragma Loop_Invariant (i1 >= val.l3MissingData.Data'First and i1 <= val.l3MissingData.Length);
                            i2 := val.l3MissingData.Data(i1).Data'First;
                            while ret.Success and i2 <= 8 loop
                                pragma Loop_Invariant (i2 >= val.l3MissingData.Data(i1).Data'First and i2 <= 8);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYACKDATA_L3MISSINGDATA_ELM_ELM);
                                i2 := i2+1;
                            end loop;

                            i1 := i1+1;
                        end loop;

                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END MyAckData_IsConstraintValid;



function MyL3Fcs_Equal(val1, val2: in MyL3Fcs) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := My16BitArray_Equal(val1, val2);
    return ret;
end MyL3Fcs_Equal;

function MyL3Fcs_Init return MyL3Fcs
is
    val: MyL3Fcs;
begin
    val := My16BitArray_Init;
    return val;
end MyL3Fcs_Init;

FUNCTION MyL3Fcs_IsConstraintValid(val : in MyL3Fcs) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 16 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 16);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FCS_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3Fcs_IsConstraintValid;



function MyL3Frame_Equal(val1, val2: in MyL3Frame)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MyL3Ba_Equal(val1.l3Ba, val2.l3Ba);

    if ret then
        ret := My8BitArray_Equal(val1.l3Cntrl, val2.l3Cntrl);

        if ret then
            ret := My8BitArray_Equal(val1.l3Code, val2.l3Code);

            if ret then
                ret := My16BitArray_Equal(val1.l3Tte, val2.l3Tte);

                if ret then
                    ret := My16BitArray_Equal(val1.l3Mrt, val2.l3Mrt);

                    if ret then
                        ret := My8BitArray_Equal(val1.l3Fnum, val2.l3Fnum);

                        if ret then
                            ret := MyL3Data_Equal(val1.l3Data, val2.l3Data);

                            if ret then
                                ret := My16BitArray_Equal(val1.l3Fcs, val2.l3Fcs);

                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end MyL3Frame_Equal;

function MyL3Frame_Init return MyL3Frame
is
    val: MyL3Frame;
begin

    --set l3Ba 
    val.l3Ba := MyL3Ba_Init;
    --set l3Cntrl 
    val.l3Cntrl := MyL3Cntrl_Init;
    --set l3Code 
    val.l3Code := MyL3Code_Init;
    --set l3Tte 
    val.l3Tte := MyL3Tte_Init;
    --set l3Mrt 
    val.l3Mrt := MyL3Mrt_Init;
    --set l3Fnum 
    val.l3Fnum := MyL3Fnum_Init;
    --set l3Data 
    val.l3Data := MyL3Data_Init;
    --set l3Fcs 
    val.l3Fcs := MyL3Fcs_Init;
    return val;
end MyL3Frame_Init;

FUNCTION MyL3Frame_IsConstraintValid(val : in MyL3Frame) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.l3Ba.l3SrcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.l3Ba.l3SrcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3BA_L3SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.l3Ba.l3DstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.l3Ba.l3DstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3BA_L3DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    if ret.Success then
        i1 := val.l3Cntrl.Data'First;
        while ret.Success and i1 <= 8 loop
            pragma Loop_Invariant (i1 >= val.l3Cntrl.Data'First and i1 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3CNTRL_ELM);
            i1 := i1+1;
        end loop;

        if ret.Success then
            i1 := val.l3Code.Data'First;
            while ret.Success and i1 <= 8 loop
                pragma Loop_Invariant (i1 >= val.l3Code.Data'First and i1 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3CODE_ELM);
                i1 := i1+1;
            end loop;

            if ret.Success then
                i1 := val.l3Tte.Data'First;
                while ret.Success and i1 <= 16 loop
                    pragma Loop_Invariant (i1 >= val.l3Tte.Data'First and i1 <= 16);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3TTE_ELM);
                    i1 := i1+1;
                end loop;

                if ret.Success then
                    i1 := val.l3Mrt.Data'First;
                    while ret.Success and i1 <= 16 loop
                        pragma Loop_Invariant (i1 >= val.l3Mrt.Data'First and i1 <= 16);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3MRT_ELM);
                        i1 := i1+1;
                    end loop;

                    if ret.Success then
                        i1 := val.l3Fnum.Data'First;
                        while ret.Success and i1 <= 8 loop
                            pragma Loop_Invariant (i1 >= val.l3Fnum.Data'First and i1 <= 8);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3FNUM_ELM);
                            i1 := i1+1;
                        end loop;

                        if ret.Success then
                            ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.l3Data.Length) AND (val.l3Data.Length <= 245)), ErrorCode => ERR_MYL3FRAME_L3DATA);
                            i1 := val.l3Data.Data'First;
                            while ret.Success and i1 <= val.l3Data.Length loop
                                pragma Loop_Invariant (i1 >= val.l3Data.Data'First and i1 <= val.l3Data.Length);
                                i2 := val.l3Data.Data(i1).Data'First;
                                while ret.Success and i2 <= 8 loop
                                    pragma Loop_Invariant (i2 >= val.l3Data.Data(i1).Data'First and i2 <= 8);
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3DATA_ELM_ELM);
                                    i2 := i2+1;
                                end loop;

                                i1 := i1+1;
                            end loop;

                            if ret.Success then
                                i1 := val.l3Fcs.Data'First;
                                while ret.Success and i1 <= 16 loop
                                    pragma Loop_Invariant (i1 >= val.l3Fcs.Data'First and i1 <= 16);
                                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FRAME_L3FCS_ELM);
                                    i1 := i1+1;
                                end loop;

                            end if;

                        end if;

                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END MyL3Frame_IsConstraintValid;



function MyL3AckFrame_Equal(val1, val2: in MyL3AckFrame)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MyL3Ba_Equal(val1.l3Ba, val2.l3Ba);

    if ret then
        ret := My8BitArray_Equal(val1.l3Cntrl, val2.l3Cntrl);

        if ret then
            ret := My8BitArray_Equal(val1.l3Code, val2.l3Code);

            if ret then
                ret := My16BitArray_Equal(val1.l3Tte, val2.l3Tte);

                if ret then
                    ret := My16BitArray_Equal(val1.l3Mrt, val2.l3Mrt);

                    if ret then
                        ret := My8BitArray_Equal(val1.l3Lfn, val2.l3Lfn);

                        if ret then
                            ret := My8BitArray_Equal(val1.l3Hfn, val2.l3Hfn);

                            if ret then
                                ret := MyL3Rrq_Equal(val1.l3Rrq, val2.l3Rrq);

                                if ret then
                                    ret := My16BitArray_Equal(val1.l3Fcs, val2.l3Fcs);

                                end if;
                            end if;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end if;
	return ret;

end MyL3AckFrame_Equal;

function MyL3AckFrame_Init return MyL3AckFrame
is
    val: MyL3AckFrame;
begin

    --set l3Ba 
    val.l3Ba := MyL3Ba_Init;
    --set l3Cntrl 
    val.l3Cntrl := MyL3Cntrl_Init;
    --set l3Code 
    val.l3Code := MyL3Code_Init;
    --set l3Tte 
    val.l3Tte := MyL3Tte_Init;
    --set l3Mrt 
    val.l3Mrt := MyL3Mrt_Init;
    --set l3Lfn 
    val.l3Lfn := MyL3Lfn_Init;
    --set l3Hfn 
    val.l3Hfn := MyL3Hfn_Init;
    --set l3Rrq 
    val.l3Rrq := MyL3Rrq_Init;
    --set l3Fcs 
    val.l3Fcs := MyL3Fcs_Init;
    return val;
end MyL3AckFrame_Init;

FUNCTION MyL3AckFrame_IsConstraintValid(val : in MyL3AckFrame) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.l3Ba.l3SrcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.l3Ba.l3SrcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3BA_L3SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.l3Ba.l3DstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.l3Ba.l3DstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3BA_L3DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    if ret.Success then
        i1 := val.l3Cntrl.Data'First;
        while ret.Success and i1 <= 8 loop
            pragma Loop_Invariant (i1 >= val.l3Cntrl.Data'First and i1 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3CNTRL_ELM);
            i1 := i1+1;
        end loop;

        if ret.Success then
            i1 := val.l3Code.Data'First;
            while ret.Success and i1 <= 8 loop
                pragma Loop_Invariant (i1 >= val.l3Code.Data'First and i1 <= 8);
                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3CODE_ELM);
                i1 := i1+1;
            end loop;

            if ret.Success then
                i1 := val.l3Tte.Data'First;
                while ret.Success and i1 <= 16 loop
                    pragma Loop_Invariant (i1 >= val.l3Tte.Data'First and i1 <= 16);
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3TTE_ELM);
                    i1 := i1+1;
                end loop;

                if ret.Success then
                    i1 := val.l3Mrt.Data'First;
                    while ret.Success and i1 <= 16 loop
                        pragma Loop_Invariant (i1 >= val.l3Mrt.Data'First and i1 <= 16);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3MRT_ELM);
                        i1 := i1+1;
                    end loop;

                    if ret.Success then
                        i1 := val.l3Lfn.Data'First;
                        while ret.Success and i1 <= 8 loop
                            pragma Loop_Invariant (i1 >= val.l3Lfn.Data'First and i1 <= 8);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3LFN_ELM);
                            i1 := i1+1;
                        end loop;

                        if ret.Success then
                            i1 := val.l3Hfn.Data'First;
                            while ret.Success and i1 <= 8 loop
                                pragma Loop_Invariant (i1 >= val.l3Hfn.Data'First and i1 <= 8);
                                ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3HFN_ELM);
                                i1 := i1+1;
                            end loop;

                            if ret.Success then
                                ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.l3Rrq.Length) AND (val.l3Rrq.Length <= 244)), ErrorCode => ERR_MYL3ACKFRAME_L3RRQ);
                                i1 := val.l3Rrq.Data'First;
                                while ret.Success and i1 <= val.l3Rrq.Length loop
                                    pragma Loop_Invariant (i1 >= val.l3Rrq.Data'First and i1 <= val.l3Rrq.Length);
                                    i2 := val.l3Rrq.Data(i1).Data'First;
                                    while ret.Success and i2 <= 8 loop
                                        pragma Loop_Invariant (i2 >= val.l3Rrq.Data(i1).Data'First and i2 <= 8);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3RRQ_ELM_ELM);
                                        i2 := i2+1;
                                    end loop;

                                    i1 := i1+1;
                                end loop;

                                if ret.Success then
                                    i1 := val.l3Fcs.Data'First;
                                    while ret.Success and i1 <= 16 loop
                                        pragma Loop_Invariant (i1 >= val.l3Fcs.Data'First and i1 <= 16);
                                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFRAME_L3FCS_ELM);
                                        i1 := i1+1;
                                    end loop;

                                end if;

                            end if;

                        end if;

                    end if;

                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END MyL3AckFrame_IsConstraintValid;



function My16BitArrayInteger_Equal(val1, val2: in My16BitArrayInteger)
    return Boolean 
is
begin
	return val1 = val2;

end My16BitArrayInteger_Equal;

function My16BitArrayInteger_Init return My16BitArrayInteger
is
    val: My16BitArrayInteger;
begin
    val := 0;
    return val;
end My16BitArrayInteger_Init;

FUNCTION My16BitArrayInteger_IsConstraintValid(val : in My16BitArrayInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 15), ErrorCode => ERR_MY16BITARRAYINTEGER);
    RETURN ret;
END My16BitArrayInteger_IsConstraintValid;



function My16BitArrayValueInteger_Equal(val1, val2: in My16BitArrayValueInteger)
    return Boolean 
is
begin
	return val1 = val2;

end My16BitArrayValueInteger_Equal;

function My16BitArrayValueInteger_Init return My16BitArrayValueInteger
is
    val: My16BitArrayValueInteger;
begin
    val := 0;
    return val;
end My16BitArrayValueInteger_Init;

FUNCTION My16BitArrayValueInteger_IsConstraintValid(val : in My16BitArrayValueInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 65535), ErrorCode => ERR_MY16BITARRAYVALUEINTEGER);
    RETURN ret;
END My16BitArrayValueInteger_IsConstraintValid;



function MyDataStack_Equal(val1, val2: in MyDataStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyDataStack_Equal;

function MyDataStack_Init return MyDataStack
is
    val: MyDataStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2000 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2000);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 40;
    return val;
end MyDataStack_Init;

FUNCTION MyDataStack_IsConstraintValid(val : in MyDataStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((40 <= val.Length) AND (val.Length <= 2000)), ErrorCode => ERR_MYDATASTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYDATASTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyDataStack_IsConstraintValid;



function MyFcsStack_Equal(val1, val2: in MyFcsStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyFcsStack_Equal;

function MyFcsStack_Init return MyFcsStack
is
    val: MyFcsStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2192 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2192);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 224;
    return val;
end MyFcsStack_Init;

FUNCTION MyFcsStack_IsConstraintValid(val : in MyFcsStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((224 <= val.Length) AND (val.Length <= 2192)), ErrorCode => ERR_MYFCSSTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFCSSTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyFcsStack_IsConstraintValid;



function MyFcsStackInteger_Equal(val1, val2: in MyFcsStackInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyFcsStackInteger_Equal;

function MyFcsStackInteger_Init return MyFcsStackInteger
is
    val: MyFcsStackInteger;
begin
    val := 0;
    return val;
end MyFcsStackInteger_Init;

FUNCTION MyFcsStackInteger_IsConstraintValid(val : in MyFcsStackInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 2175), ErrorCode => ERR_MYFCSSTACKINTEGER);
    RETURN ret;
END MyFcsStackInteger_IsConstraintValid;



function MyFcsPolynomial_Equal(val1, val2: in MyFcsPolynomial)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 17 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MyFcsPolynomial_Equal;

function MyFcsPolynomial_Init return MyFcsPolynomial
is
    val: MyFcsPolynomial;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 17 loop
        pragma Loop_Invariant (i1 >=1 and i1<=17);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end MyFcsPolynomial_Init;

FUNCTION MyFcsPolynomial_IsConstraintValid(val : in MyFcsPolynomial) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 17 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 17);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYFCSPOLYNOMIAL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyFcsPolynomial_IsConstraintValid;



function MyFcsPolynomialInteger_Equal(val1, val2: in MyFcsPolynomialInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyFcsPolynomialInteger_Equal;

function MyFcsPolynomialInteger_Init return MyFcsPolynomialInteger
is
    val: MyFcsPolynomialInteger;
begin
    val := 0;
    return val;
end MyFcsPolynomialInteger_Init;

FUNCTION MyFcsPolynomialInteger_IsConstraintValid(val : in MyFcsPolynomialInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 16), ErrorCode => ERR_MYFCSPOLYNOMIALINTEGER);
    RETURN ret;
END MyFcsPolynomialInteger_IsConstraintValid;



function MyL3StackNumbers_Equal(val1, val2: in MyL3StackNumbers)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3StackNumbers_Equal;

function MyL3StackNumbers_Init return MyL3StackNumbers
is
    val: MyL3StackNumbers;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 255 loop
        pragma Loop_Invariant (i1 >=1 and i1<=255);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3StackNumbers_Init;

FUNCTION MyL3StackNumbers_IsConstraintValid(val : in MyL3StackNumbers) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 255)), ErrorCode => ERR_MYL3STACKNUMBERS);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3STACKNUMBERS_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3StackNumbers_IsConstraintValid;



function MyL3StackInteger_Equal(val1, val2: in MyL3StackInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyL3StackInteger_Equal;

function MyL3StackInteger_Init return MyL3StackInteger
is
    val: MyL3StackInteger;
begin
    val := 0;
    return val;
end MyL3StackInteger_Init;

FUNCTION MyL3StackInteger_IsConstraintValid(val : in MyL3StackInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 254), ErrorCode => ERR_MYL3STACKINTEGER);
    RETURN ret;
END MyL3StackInteger_IsConstraintValid;



function MyL3DataStack_Equal(val1, val2: in MyL3DataStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3DataStack_Equal;

function MyL3DataStack_Init return MyL3DataStack
is
    val: MyL3DataStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 1960 loop
        pragma Loop_Invariant (i1 >=1 and i1<=1960);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3DataStack_Init;

FUNCTION MyL3DataStack_IsConstraintValid(val : in MyL3DataStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 1960)), ErrorCode => ERR_MYL3DATASTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3DATASTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3DataStack_IsConstraintValid;



function MyL3FcsStack_Equal(val1, val2: in MyL3FcsStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3FcsStack_Equal;

function MyL3FcsStack_Init return MyL3FcsStack
is
    val: MyL3FcsStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2040 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2040);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 80;
    return val;
end MyL3FcsStack_Init;

FUNCTION MyL3FcsStack_IsConstraintValid(val : in MyL3FcsStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((80 <= val.Length) AND (val.Length <= 2040)), ErrorCode => ERR_MYL3FCSSTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FCSSTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3FcsStack_IsConstraintValid;



function MyL3FcsStackInteger_Equal(val1, val2: in MyL3FcsStackInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyL3FcsStackInteger_Equal;

function MyL3FcsStackInteger_Init return MyL3FcsStackInteger
is
    val: MyL3FcsStackInteger;
begin
    val := 0;
    return val;
end MyL3FcsStackInteger_Init;

FUNCTION MyL3FcsStackInteger_IsConstraintValid(val : in MyL3FcsStackInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 2023), ErrorCode => ERR_MYL3FCSSTACKINTEGER);
    RETURN ret;
END MyL3FcsStackInteger_IsConstraintValid;



function MyL3FcsPolynomial_Equal(val1, val2: in MyL3FcsPolynomial)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 17 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end MyL3FcsPolynomial_Equal;

function MyL3FcsPolynomial_Init return MyL3FcsPolynomial
is
    val: MyL3FcsPolynomial;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 17 loop
        pragma Loop_Invariant (i1 >=1 and i1<=17);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end MyL3FcsPolynomial_Init;

FUNCTION MyL3FcsPolynomial_IsConstraintValid(val : in MyL3FcsPolynomial) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 17 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 17);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3FCSPOLYNOMIAL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3FcsPolynomial_IsConstraintValid;



function MyL3DataInteger_Equal(val1, val2: in MyL3DataInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyL3DataInteger_Equal;

function MyL3DataInteger_Init return MyL3DataInteger
is
    val: MyL3DataInteger;
begin
    val := 0;
    return val;
end MyL3DataInteger_Init;

FUNCTION MyL3DataInteger_IsConstraintValid(val : in MyL3DataInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 244), ErrorCode => ERR_MYL3DATAINTEGER);
    RETURN ret;
END MyL3DataInteger_IsConstraintValid;



function MyL3AckDataStack_Equal(val1, val2: in MyL3AckDataStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3AckDataStack_Equal;

function MyL3AckDataStack_Init return MyL3AckDataStack
is
    val: MyL3AckDataStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 1952 loop
        pragma Loop_Invariant (i1 >=1 and i1<=1952);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3AckDataStack_Init;

FUNCTION MyL3AckDataStack_IsConstraintValid(val : in MyL3AckDataStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 1952)), ErrorCode => ERR_MYL3ACKDATASTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKDATASTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3AckDataStack_IsConstraintValid;



function MyL3AckFcsStack_Equal(val1, val2: in MyL3AckFcsStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3AckFcsStack_Equal;

function MyL3AckFcsStack_Init return MyL3AckFcsStack
is
    val: MyL3AckFcsStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2040 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2040);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 88;
    return val;
end MyL3AckFcsStack_Init;

FUNCTION MyL3AckFcsStack_IsConstraintValid(val : in MyL3AckFcsStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((88 <= val.Length) AND (val.Length <= 2040)), ErrorCode => ERR_MYL3ACKFCSSTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYL3ACKFCSSTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3AckFcsStack_IsConstraintValid;



function MyL3AckMissingStack_elem_Equal(val1, val2: in MyL3AckMissingStack_elem)
    return Boolean 
is
begin
	return val1 = val2;

end MyL3AckMissingStack_elem_Equal;

function MyL3AckMissingStack_Equal(val1, val2: in MyL3AckMissingStack)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end MyL3AckMissingStack_Equal;

function MyL3AckMissingStack_elem_Init return MyL3AckMissingStack_elem
is
    val: MyL3AckMissingStack_elem;
begin
    val := 0;
    return val;
end MyL3AckMissingStack_elem_Init;
function MyL3AckMissingStack_Init return MyL3AckMissingStack
is
    val: MyL3AckMissingStack;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 244 loop
        pragma Loop_Invariant (i1 >=1 and i1<=244);
        val.Data(i1) := MyL3AckMissingStack_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end MyL3AckMissingStack_Init;

FUNCTION MyL3AckMissingStack_IsConstraintValid(val : in MyL3AckMissingStack) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 244)), ErrorCode => ERR_MYL3ACKMISSINGSTACK);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_MYL3ACKMISSINGSTACK_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END MyL3AckMissingStack_IsConstraintValid;



function MyInputData_Equal(val1, val2: in MyInputData)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := MyBa_Equal(val1.ba, val2.ba);

    if ret then
        ret := My8BitArray_Equal(val1.code, val2.code);

        if ret then
            ret := val1.Exist.rawData = val2.Exist.rawData;
            if ret and then val1.Exist.rawData = 1 then
                ret := MyRawData_Equal(val1.rawData, val2.rawData);
            end if;

            if ret then
                ret := val1.Exist.l3Mrt = val2.Exist.l3Mrt;
                if ret and then val1.Exist.l3Mrt = 1 then
                    ret := My16BitArray_Equal(val1.l3Mrt, val2.l3Mrt);
                end if;

                if ret then
                    ret := val1.Exist.l3AckMissingStack = val2.Exist.l3AckMissingStack;
                    if ret and then val1.Exist.l3AckMissingStack = 1 then
                        ret := MyL3AckMissingStack_Equal(val1.l3AckMissingStack, val2.l3AckMissingStack);
                    end if;

                end if;
            end if;
        end if;
    end if;
	return ret;

end MyInputData_Equal;

function MyInputData_Init return MyInputData
is
    val: MyInputData;
begin

    --set ba 
    val.ba := MyBa_Init;
    --set code 
    val.code := MyCode_Init;
    --set rawData 
    val.exist.rawData := 1;
    val.rawData := MyRawData_Init;
    --set l3Mrt 
    val.exist.l3Mrt := 1;
    val.l3Mrt := MyL3Mrt_Init;
    --set l3AckMissingStack 
    val.exist.l3AckMissingStack := 1;
    val.l3AckMissingStack := MyL3AckMissingStack_Init;
    return val;
end MyInputData_Init;

FUNCTION MyInputData_IsConstraintValid(val : in MyInputData) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
    i2:Integer;
BEGIN
    i1 := val.ba.srcAddr.Data'First;
    while ret.Success and i1 <= 4 loop
        pragma Loop_Invariant (i1 >= val.ba.srcAddr.Data'First and i1 <= 4);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINPUTDATA_BA_SRCADDR_ELM);
        i1 := i1+1;
    end loop;

    if ret.Success then
        i1 := val.ba.dstAddr.Data'First;
        while ret.Success and i1 <= 4 loop
            pragma Loop_Invariant (i1 >= val.ba.dstAddr.Data'First and i1 <= 4);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINPUTDATA_BA_DSTADDR_ELM);
            i1 := i1+1;
        end loop;

    end if;

    if ret.Success then
        i1 := val.code.Data'First;
        while ret.Success and i1 <= 8 loop
            pragma Loop_Invariant (i1 >= val.code.Data'First and i1 <= 8);
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINPUTDATA_CODE_ELM);
            i1 := i1+1;
        end loop;

        if ret.Success then
            if val.Exist.rawData = 1 then
                ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.rawData.Length) AND (val.rawData.Length <= 62475)), ErrorCode => ERR_MYINPUTDATA_RAWDATA);
                i1 := val.rawData.Data'First;
                while ret.Success and i1 <= val.rawData.Length loop
                    pragma Loop_Invariant (i1 >= val.rawData.Data'First and i1 <= val.rawData.Length);
                    i2 := val.rawData.Data(i1).Data'First;
                    while ret.Success and i2 <= 8 loop
                        pragma Loop_Invariant (i2 >= val.rawData.Data(i1).Data'First and i2 <= 8);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINPUTDATA_RAWDATA_ELM_ELM);
                        i2 := i2+1;
                    end loop;

                    i1 := i1+1;
                end loop;

            end if;
            if ret.Success then
                if val.Exist.l3Mrt = 1 then
                    i1 := val.l3Mrt.Data'First;
                    while ret.Success and i1 <= 16 loop
                        pragma Loop_Invariant (i1 >= val.l3Mrt.Data'First and i1 <= 16);
                        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYINPUTDATA_L3MRT_ELM);
                        i1 := i1+1;
                    end loop;

                end if;
                if ret.Success then
                    if val.Exist.l3AckMissingStack = 1 then
                        ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.l3AckMissingStack.Length) AND (val.l3AckMissingStack.Length <= 244)), ErrorCode => ERR_MYINPUTDATA_L3ACKMISSINGSTACK);
                        i1 := val.l3AckMissingStack.Data'First;
                        while ret.Success and i1 <= val.l3AckMissingStack.Length loop
                            pragma Loop_Invariant (i1 >= val.l3AckMissingStack.Data'First and i1 <= val.l3AckMissingStack.Length);
                            ret := adaasn1rtl.ASN1_RESULT'(Success => (val.l3AckMissingStack.Data(i1) <= 255), ErrorCode => ERR_MYINPUTDATA_L3ACKMISSINGSTACK_ELM);
                            i1 := i1+1;
                        end loop;

                    end if;
                end if;

            end if;

        end if;

    end if;

    RETURN ret;
END MyInputData_IsConstraintValid;



function MyL3AckMissingStackInteger_Equal(val1, val2: in MyL3AckMissingStackInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyL3AckMissingStackInteger_Equal;

function MyL3AckMissingStackInteger_Init return MyL3AckMissingStackInteger
is
    val: MyL3AckMissingStackInteger;
begin
    val := 0;
    return val;
end MyL3AckMissingStackInteger_Init;

FUNCTION MyL3AckMissingStackInteger_IsConstraintValid(val : in MyL3AckMissingStackInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 243), ErrorCode => ERR_MYL3ACKMISSINGSTACKINTEGER);
    RETURN ret;
END MyL3AckMissingStackInteger_IsConstraintValid;



function MyL3RrqInteger_Equal(val1, val2: in MyL3RrqInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyL3RrqInteger_Equal;

function MyL3RrqInteger_Init return MyL3RrqInteger
is
    val: MyL3RrqInteger;
begin
    val := 0;
    return val;
end MyL3RrqInteger_Init;

FUNCTION MyL3RrqInteger_IsConstraintValid(val : in MyL3RrqInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 243), ErrorCode => ERR_MYL3RRQINTEGER);
    RETURN ret;
END MyL3RrqInteger_IsConstraintValid;



function MyRawDataInteger_Equal(val1, val2: in MyRawDataInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyRawDataInteger_Equal;

function MyRawDataInteger_Init return MyRawDataInteger
is
    val: MyRawDataInteger;
begin
    val := 0;
    return val;
end MyRawDataInteger_Init;

FUNCTION MyRawDataInteger_IsConstraintValid(val : in MyRawDataInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 62475), ErrorCode => ERR_MYRAWDATAINTEGER);
    RETURN ret;
END MyRawDataInteger_IsConstraintValid;


 

END TASTE_Dataview;