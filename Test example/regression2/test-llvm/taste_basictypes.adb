-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_BasicTypes with SPARK_Mode IS




function TASTE_Peek_id_Equal(val1, val2: in TASTE_Peek_id)
    return Boolean 
is
begin
	return val1 = val2;

end TASTE_Peek_id_Equal;

function TASTE_Peek_id_Init return TASTE_Peek_id
is
    val: TASTE_Peek_id;
begin
    val := 0;
    return val;
end TASTE_Peek_id_Init;

FUNCTION TASTE_Peek_id_IsConstraintValid(val : in TASTE_Peek_id) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 4294967295), ErrorCode => ERR_TASTE_PEEK_ID);
    RETURN ret;
END TASTE_Peek_id_IsConstraintValid;



function TASTE_Peek_id_list_Equal(val1, val2: in TASTE_Peek_id_list)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end TASTE_Peek_id_list_Equal;

function TASTE_Peek_id_list_Init return TASTE_Peek_id_list
is
    val: TASTE_Peek_id_list;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := TASTE_Peek_id_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end TASTE_Peek_id_list_Init;

FUNCTION TASTE_Peek_id_list_IsConstraintValid(val : in TASTE_Peek_id_list) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 10)), ErrorCode => ERR_TASTE_PEEK_ID_LIST);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 4294967295), ErrorCode => ERR_TASTE_PEEK_ID_LIST_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END TASTE_Peek_id_list_IsConstraintValid;



function VariableString_Equal(val1, val2: in VariableString)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end VariableString_Equal;

function VariableString_Init return VariableString
is
    val: VariableString;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 10 loop
        pragma Loop_Invariant (i1 >=1 and i1<=10);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 10;
    return val;
end VariableString_Init;

FUNCTION VariableString_IsConstraintValid(val : in VariableString) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 10)), ErrorCode => ERR_VARIABLESTRING);
    RETURN ret;
END VariableString_IsConstraintValid;



function FixedString_Equal(val1, val2: in FixedString)
    return Boolean 
is
begin
	return val1.Data = val2.Data;

end FixedString_Equal;

function FixedString_Init return FixedString
is
    val: FixedString;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 4 loop
        pragma Loop_Invariant (i1 >=1 and i1<=4);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;

    return val;
end FixedString_Init;



function SeqBool_Equal(val1, val2: in SeqBool)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqBool_Equal;

function SeqBool_Init return SeqBool
is
    val: SeqBool;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqBool_Init;

FUNCTION SeqBool_IsConstraintValid(val : in SeqBool) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 5)), ErrorCode => ERR_SEQBOOL);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBOOL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBool_IsConstraintValid;



function SeqBoolFix_Equal(val1, val2: in SeqBoolFix)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end SeqBoolFix_Equal;

function SeqBoolFix_Init return SeqBoolFix
is
    val: SeqBoolFix;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;

    return val;
end SeqBoolFix_Init;

FUNCTION SeqBoolFix_IsConstraintValid(val : in SeqBoolFix) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBOOLFIX_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBoolFix_IsConstraintValid;



function SeqEnum_elem_Equal(val1, val2: in SeqEnum_elem)
    return Boolean 
is
begin
	return val1 = val2;

end SeqEnum_elem_Equal;

function SeqEnum_Equal(val1, val2: in SeqEnum)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqEnum_Equal;

function SeqEnum_elem_Init return SeqEnum_elem
is
    val: SeqEnum_elem;
begin
    val := SeqEnum_elm_hello;
    return val;
end SeqEnum_elem_Init;
function SeqEnum_Init return SeqEnum
is
    val: SeqEnum;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := SeqEnum_elem_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqEnum_Init;

FUNCTION SeqEnum_IsConstraintValid(val : in SeqEnum) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 5)), ErrorCode => ERR_SEQENUM);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.Data(i1) = SeqEnum_elm_hello)) OR ((val.Data(i1) = SeqEnum_elm_world))), ErrorCode => ERR_SEQENUM_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqEnum_IsConstraintValid;



function SeqEnumFix_elem_Equal(val1, val2: in SeqEnumFix_elem)
    return Boolean 
is
begin
	return val1 = val2;

end SeqEnumFix_elem_Equal;

function SeqEnumFix_Equal(val1, val2: in SeqEnumFix)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    i1 := val1.Data'First;
    while ret and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;
	return ret;

end SeqEnumFix_Equal;

function SeqEnumFix_elem_Init return SeqEnumFix_elem
is
    val: SeqEnumFix_elem;
begin
    val := SeqEnumFix_elm_hello;
    return val;
end SeqEnumFix_elem_Init;
function SeqEnumFix_Init return SeqEnumFix
is
    val: SeqEnumFix;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 2 loop
        pragma Loop_Invariant (i1 >=1 and i1<=2);
        val.Data(i1) := SeqEnumFix_elem_Init;
        i1 := i1 + 1;
    end loop;

    return val;
end SeqEnumFix_Init;

FUNCTION SeqEnumFix_IsConstraintValid(val : in SeqEnumFix) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    i1 := val.Data'First;
    while ret.Success and i1 <= 2 loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= 2);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (((val.Data(i1) = SeqEnumFix_elm_hello)) OR ((val.Data(i1) = SeqEnumFix_elm_world))), ErrorCode => ERR_SEQENUMFIX_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqEnumFix_IsConstraintValid;



function Enum_T_Equal(val1, val2: in Enum_T)
    return Boolean 
is
begin
	return val1 = val2;

end Enum_T_Equal;

function Enum_T_Init return Enum_T
is
    val: Enum_T;
begin
    val := a;
    return val;
end Enum_T_Init;

FUNCTION Enum_T_IsConstraintValid(val : in Enum_T) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (((((((((val = a)) OR ((val = b)))) OR ((val = c)))) OR ((val = d)))) OR ((val = eE))), ErrorCode => ERR_ENUM_T);
    RETURN ret;
END Enum_T_IsConstraintValid;



function Choice_Equal(val1, val2: in Choice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when c1_PRESENT =>
                ret := (val1.c1 = val2.c1);
            when cDe2_PRESENT =>
                ret := (val1.cDe2 = val2.cDe2);
        end case;
    end if;
	return ret;

end Choice_Equal;

function Choice_Init return Choice
is
    val: Choice;
begin
    --set c1 
    declare
        c1_tmp:adaasn1rtl.Asn1Boolean;
    begin
        c1_tmp := FALSE;
        val := Choice'(kind => c1_PRESENT, c1 => c1_tmp);
    end;
    return val;
end Choice_Init;

FUNCTION Choice_IsConstraintValid(val : in Choice) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN c1_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_CHOICE_C1);
        WHEN cDe2_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_CHOICE_CDE2);
    end case;
    RETURN ret;
END Choice_IsConstraintValid;


 

END TASTE_BasicTypes;