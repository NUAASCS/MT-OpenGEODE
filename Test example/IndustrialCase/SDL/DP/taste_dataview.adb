-- Code automatically generated by asn1scc tool
WITH adaasn1rtl;
use type adaasn1rtl.Asn1UInt;
use type adaasn1rtl.Asn1Int;
use type adaasn1rtl.BIT;


PACKAGE BODY TASTE_Dataview with SPARK_Mode IS




function Bit_Equal(val1, val2: in Bit)
    return Boolean 
is
begin
	return val1 = val2;

end Bit_Equal;

function Bit_Init return Bit
is
    val: Bit;
begin
    val := 0;
    return val;
end Bit_Init;

FUNCTION Bit_IsConstraintValid(val : in Bit) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 1), ErrorCode => ERR_BIT);
    RETURN ret;
END Bit_IsConstraintValid;



function Message_Equal(val1, val2: in Message)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end Message_Equal;

function Message_Init return Message
is
    val: Message;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 127 loop
        pragma Loop_Invariant (i1 >=1 and i1<=127);
        val.Data(i1) := Bit_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end Message_Init;

FUNCTION Message_IsConstraintValid(val : in Message) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 127)), ErrorCode => ERR_MESSAGE);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 1), ErrorCode => ERR_MESSAGE_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Message_IsConstraintValid;



function Device_Current_StateInfo_Equal(val1, val2: in Device_Current_StateInfo)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Device_Current_StateInfo_Equal;

function Device_Current_StateInfo_Init return Device_Current_StateInfo
is
    val: Device_Current_StateInfo;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Device_Current_StateInfo_Init;

FUNCTION Device_Current_StateInfo_IsConstraintValid(val : in Device_Current_StateInfo) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_DEVICE_CURRENT_STATEINFO_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_DEVICE_CURRENT_STATEINFO_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_Current_StateInfo_IsConstraintValid;



function Device_PowerOn_Command_Equal(val1, val2: in Device_PowerOn_Command)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Device_PowerOn_Command_Equal;

function Device_PowerOn_Command_Init return Device_PowerOn_Command
is
    val: Device_PowerOn_Command;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Device_PowerOn_Command_Init;

FUNCTION Device_PowerOn_Command_IsConstraintValid(val : in Device_PowerOn_Command) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_DEVICE_POWERON_COMMAND_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_DEVICE_POWERON_COMMAND_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_PowerOn_Command_IsConstraintValid;



function Device_SelfCheck_Result_Equal(val1, val2: in Device_SelfCheck_Result)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Device_SelfCheck_Result_Equal;

function Device_SelfCheck_Result_Init return Device_SelfCheck_Result
is
    val: Device_SelfCheck_Result;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Device_SelfCheck_Result_Init;

FUNCTION Device_SelfCheck_Result_IsConstraintValid(val : in Device_SelfCheck_Result) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_DEVICE_SELFCHECK_RESULT_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_DEVICE_SELFCHECK_RESULT_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_SelfCheck_Result_IsConstraintValid;



function Control_Computer_SelfCheck_Result_Equal(val1, val2: in Control_Computer_SelfCheck_Result)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Control_Computer_SelfCheck_Result_Equal;

function Control_Computer_SelfCheck_Result_Init return Control_Computer_SelfCheck_Result
is
    val: Control_Computer_SelfCheck_Result;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Control_Computer_SelfCheck_Result_Init;

FUNCTION Control_Computer_SelfCheck_Result_IsConstraintValid(val : in Control_Computer_SelfCheck_Result) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_CONTROL_COMPUTER_SELFCHECK_RESULT_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_CONTROL_COMPUTER_SELFCHECK_RESULT_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Control_Computer_SelfCheck_Result_IsConstraintValid;



function Device_PowerOn_Result_Equal(val1, val2: in Device_PowerOn_Result) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Message_Equal(val1, val2);
    return ret;
end Device_PowerOn_Result_Equal;

function Device_PowerOn_Result_Init return Device_PowerOn_Result
is
    val: Device_PowerOn_Result;
begin
    val := Message_Init;
    return val;
end Device_PowerOn_Result_Init;

FUNCTION Device_PowerOn_Result_IsConstraintValid(val : in Device_PowerOn_Result) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 127)), ErrorCode => ERR_DEVICE_POWERON_RESULT);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 1), ErrorCode => ERR_DEVICE_POWERON_RESULT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_PowerOn_Result_IsConstraintValid;



function Device_PowerOn1_Result_Equal(val1, val2: in Device_PowerOn1_Result) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Message_Equal(val1, val2);
    return ret;
end Device_PowerOn1_Result_Equal;

function Device_PowerOn1_Result_Init return Device_PowerOn1_Result
is
    val: Device_PowerOn1_Result;
begin
    val := Message_Init;
    return val;
end Device_PowerOn1_Result_Init;

FUNCTION Device_PowerOn1_Result_IsConstraintValid(val : in Device_PowerOn1_Result) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 127)), ErrorCode => ERR_DEVICE_POWERON1_RESULT);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 1), ErrorCode => ERR_DEVICE_POWERON1_RESULT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_PowerOn1_Result_IsConstraintValid;



function Device_PowerOn2_Result_Equal(val1, val2: in Device_PowerOn2_Result) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Message_Equal(val1, val2);
    return ret;
end Device_PowerOn2_Result_Equal;

function Device_PowerOn2_Result_Init return Device_PowerOn2_Result
is
    val: Device_PowerOn2_Result;
begin
    val := Message_Init;
    return val;
end Device_PowerOn2_Result_Init;

FUNCTION Device_PowerOn2_Result_IsConstraintValid(val : in Device_PowerOn2_Result) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 127)), ErrorCode => ERR_DEVICE_POWERON2_RESULT);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 1), ErrorCode => ERR_DEVICE_POWERON2_RESULT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_PowerOn2_Result_IsConstraintValid;



function Device_PowerOn3_Result_Equal(val1, val2: in Device_PowerOn3_Result) 
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
begin
    ret := Message_Equal(val1, val2);
    return ret;
end Device_PowerOn3_Result_Equal;

function Device_PowerOn3_Result_Init return Device_PowerOn3_Result
is
    val: Device_PowerOn3_Result;
begin
    val := Message_Init;
    return val;
end Device_PowerOn3_Result_Init;

FUNCTION Device_PowerOn3_Result_IsConstraintValid(val : in Device_PowerOn3_Result) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 127)), ErrorCode => ERR_DEVICE_POWERON3_RESULT);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 1), ErrorCode => ERR_DEVICE_POWERON3_RESULT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Device_PowerOn3_Result_IsConstraintValid;



function Trigger_Equal(val1, val2: in Trigger)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Trigger_Equal;

function Trigger_Init return Trigger
is
    val: Trigger;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Trigger_Init;

FUNCTION Trigger_IsConstraintValid(val : in Trigger) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_TRIGGER_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_TRIGGER_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Trigger_IsConstraintValid;



function Trigger_1_Equal(val1, val2: in Trigger_1)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Trigger_1_Equal;

function Trigger_1_Init return Trigger_1
is
    val: Trigger_1;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Trigger_1_Init;

FUNCTION Trigger_1_IsConstraintValid(val : in Trigger_1) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_TRIGGER_1_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_TRIGGER_1_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Trigger_1_IsConstraintValid;



function Trigger_2_Equal(val1, val2: in Trigger_2)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Trigger_2_Equal;

function Trigger_2_Init return Trigger_2
is
    val: Trigger_2;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Trigger_2_Init;

FUNCTION Trigger_2_IsConstraintValid(val : in Trigger_2) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_TRIGGER_2_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_TRIGGER_2_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Trigger_2_IsConstraintValid;



function Error_Equal(val1, val2: in Error)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := Message_Equal(val1.content, val2.content);

	return ret;

end Error_Equal;

function Error_Init return Error
is
    val: Error;
begin

    --set content 
    val.content := Message_Init;
    return val;
end Error_Init;

FUNCTION Error_IsConstraintValid(val : in Error) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.content.Length) AND (val.content.Length <= 127)), ErrorCode => ERR_ERROR_CONTENT);
    i1 := val.content.Data'First;
    while ret.Success and i1 <= val.content.Length loop
        pragma Loop_Invariant (i1 >= val.content.Data'First and i1 <= val.content.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.content.Data(i1) <= 1), ErrorCode => ERR_ERROR_CONTENT_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END Error_IsConstraintValid;



function MyChoice_a_b_Equal(val1, val2: in MyChoice_a_b)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when c_PRESENT =>
                ret := (val1.c = val2.c);
            when d_PRESENT =>
                ret := (val1.d = val2.d);
        end case;
    end if;
	return ret;

end MyChoice_a_b_Equal;

function MyChoice_a_Equal(val1, val2: in MyChoice_a)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when b_PRESENT =>
                ret := val1.b.kind = val2.b.kind;
                if ret then
                    case val1.b.kind is
                        when c_PRESENT =>
                            ret := (val1.b.c = val2.b.c);
                        when d_PRESENT =>
                            ret := (val1.b.d = val2.b.d);
                    end case;
                end if;
            when e_PRESENT =>
                ret := (val1.e = val2.e);
        end case;
    end if;
	return ret;

end MyChoice_a_Equal;

function MyChoice_Equal(val1, val2: in MyChoice)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := val1.kind = val2.kind;
    if ret then
        case val1.kind is
            when a_PRESENT =>
                ret := val1.a.kind = val2.a.kind;
                if ret then
                    case val1.a.kind is
                        when b_PRESENT =>
                            ret := val1.a.b.kind = val2.a.b.kind;
                            if ret then
                                case val1.a.b.kind is
                                    when c_PRESENT =>
                                        ret := (val1.a.b.c = val2.a.b.c);
                                    when d_PRESENT =>
                                        ret := (val1.a.b.d = val2.a.b.d);
                                end case;
                            end if;
                        when e_PRESENT =>
                            ret := (val1.a.e = val2.a.e);
                    end case;
                end if;
            when f_PRESENT =>
                ret := (val1.f = val2.f);
        end case;
    end if;
	return ret;

end MyChoice_Equal;

function MyChoice_a_b_Init return MyChoice_a_b
is
    val: MyChoice_a_b;
begin
    --set c 
    declare
        c_tmp:adaasn1rtl.Asn1Boolean;
    begin
        c_tmp := FALSE;
        val := MyChoice_a_b'(kind => c_PRESENT, c => c_tmp);
    end;
    return val;
end MyChoice_a_b_Init;
function MyChoice_a_Init return MyChoice_a
is
    val: MyChoice_a;
begin
    --set b 
    declare
        b_tmp:MyChoice_a_b;
    begin
        val.b := MyChoice_a_b_Init;
        val := MyChoice_a'(kind => b_PRESENT, b => b_tmp);
    end;
    return val;
end MyChoice_a_Init;
function MyChoice_Init return MyChoice
is
    val: MyChoice;
begin
    --set a 
    declare
        a_tmp:MyChoice_a;
    begin
        val.a := MyChoice_a_Init;
        val := MyChoice'(kind => a_PRESENT, a => a_tmp);
    end;
    return val;
end MyChoice_Init;

FUNCTION MyChoice_IsConstraintValid(val : in MyChoice) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    case val.kind is
        WHEN a_PRESENT =>
            case val.a.kind is
                WHEN b_PRESENT =>
                    case val.a.b.kind is
                        WHEN c_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A_B_C);
                        WHEN d_PRESENT =>
                            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A_B_D);
                    end case;
                WHEN e_PRESENT =>
                    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_A_E);
            end case;
        WHEN f_PRESENT =>
            ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_MYCHOICE_F);
    end case;
    RETURN ret;
END MyChoice_IsConstraintValid;



function MyInteger_Equal(val1, val2: in MyInteger)
    return Boolean 
is
begin
	return val1 = val2;

end MyInteger_Equal;

function MyInteger_Init return MyInteger
is
    val: MyInteger;
begin
    val := 0;
    return val;
end MyInteger_Init;

FUNCTION MyInteger_IsConstraintValid(val : in MyInteger) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_MYINTEGER);
    RETURN ret;
END MyInteger_IsConstraintValid;



function Some_Thing_Equal(val1, val2: in Some_Thing)
    return Boolean 
is
begin
	return val1 = val2;

end Some_Thing_Equal;

function Some_Thing_Init return Some_Thing
is
    val: Some_Thing;
begin
    val := MyInteger_Init;
    return val;
end Some_Thing_Init;

FUNCTION Some_Thing_IsConstraintValid(val : in Some_Thing) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 255), ErrorCode => ERR_SOME_THING);
    RETURN ret;
END Some_Thing_IsConstraintValid;



function SeqOf_Equal(val1, val2: in SeqOf)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqOf_Equal;

function SeqOf_Init return SeqOf
is
    val: SeqOf;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 100 loop
        pragma Loop_Invariant (i1 >=1 and i1<=100);
        val.Data(i1) := MyInteger_Init;
        i1 := i1 + 1;
    end loop;
    val.Length := 0;
    return val;
end SeqOf_Init;

FUNCTION SeqOf_IsConstraintValid(val : in SeqOf) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 100)), ErrorCode => ERR_SEQOF);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => (val.Data(i1) <= 255), ErrorCode => ERR_SEQOF_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqOf_IsConstraintValid;



function My_OctStr_Equal(val1, val2: in My_OctStr)
    return Boolean 
is
begin
	return val1.Length = val2.Length and then val1.Data(1 .. val1.Length) = val2.Data(1 .. val2.Length);

end My_OctStr_Equal;

function My_OctStr_Init return My_OctStr
is
    val: My_OctStr;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 20 loop
        pragma Loop_Invariant (i1 >=1 and i1<=20);
        val.Data(i1) := adaasn1rtl.Asn1Byte(0);
        i1 := i1 + 1;
    end loop;
    val.Length := 20;
    return val;
end My_OctStr_Init;

FUNCTION My_OctStr_IsConstraintValid(val : in My_OctStr) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((0 <= val.Length) AND (val.Length <= 20)), ErrorCode => ERR_MY_OCTSTR);
    RETURN ret;
END My_OctStr_IsConstraintValid;



function Type1_Equal(val1, val2: in Type1)
    return Boolean 
is
begin
	return val1 = val2;

end Type1_Equal;

function Type1_Init return Type1
is
    val: Type1;
begin
    val := 0;
    return val;
end Type1_Init;

FUNCTION Type1_IsConstraintValid(val : in Type1) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val <= 1), ErrorCode => ERR_TYPE1);
    RETURN ret;
END Type1_IsConstraintValid;



function Type2_Equal(val1, val2: in Type2)
    return Boolean 
is
begin
	return val1 = val2;

end Type2_Equal;

function Type2_Init return Type2
is
    val: Type2;
begin
    val := FALSE;
    return val;
end Type2_Init;

FUNCTION Type2_IsConstraintValid(val : in Type2) return adaasn1rtl.ASN1_RESULT
IS
    ret : adaasn1rtl.ASN1_RESULT;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TYPE2);
    RETURN ret;
END Type2_IsConstraintValid;



function Toto_Equal(val1, val2: in Toto)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        

begin
    ret := (val1.elem_1 = val2.elem_1);

    if ret then
        ret := (val1.elem_2 = val2.elem_2);

    end if;
	return ret;

end Toto_Equal;

function Toto_Init return Toto
is
    val: Toto;
begin

    --set elem_1 
    val.elem_1 := Type1_Init;
    --set elem_2 
    val.elem_2 := Type2_Init;
    return val;
end Toto_Init;

FUNCTION Toto_IsConstraintValid(val : in Toto) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => (val.elem_1 <= 1), ErrorCode => ERR_TOTO_ELEM_1);
    if ret.Success then
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_TOTO_ELEM_2);
    end if;

    RETURN ret;
END Toto_IsConstraintValid;



function SeqBool_Equal(val1, val2: in SeqBool)
    return Boolean 
is
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : Boolean := TRUE;
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;

begin
    ret := (val1.Length = val2.Length);
    i1 := val1.Data'First;
    while ret and i1 <= val1.Length loop
        pragma Loop_Invariant (i1 >= val1.Data'First and i1 >= val2.Data'First and i1 <= val1.Length  and val1.Length = val2.Length);
        ret := (val1.Data(i1) = val2.Data(i1));
        i1 := i1+1;
    end loop;

	return ret;

end SeqBool_Equal;

function SeqBool_Init return SeqBool
is
    val: SeqBool;
    i1:Integer;
begin
    i1 := 1;
    while i1<= 5 loop
        pragma Loop_Invariant (i1 >=1 and i1<=5);
        val.Data(i1) := FALSE;
        i1 := i1 + 1;
    end loop;
    val.Length := 1;
    return val;
end SeqBool_Init;

FUNCTION SeqBool_IsConstraintValid(val : in SeqBool) return adaasn1rtl.ASN1_RESULT
IS
    pragma Warnings (Off, "initialization of ret has no effect");        
    ret : adaasn1rtl.ASN1_RESULT := adaasn1rtl.ASN1_RESULT'(Success => true, ErrorCode => 0);
    pragma Warnings (On, "initialization of ret has no effect");        
    i1:Integer;
BEGIN
    ret := adaasn1rtl.ASN1_RESULT'(Success => ((1 <= val.Length) AND (val.Length <= 5)), ErrorCode => ERR_SEQBOOL);
    i1 := val.Data'First;
    while ret.Success and i1 <= val.Length loop
        pragma Loop_Invariant (i1 >= val.Data'First and i1 <= val.Length);
        ret := adaasn1rtl.ASN1_RESULT'(Success => TRUE, ErrorCode => ERR_SEQBOOL_ELM);
        i1 := i1+1;
    end loop;

    RETURN ret;
END SeqBool_IsConstraintValid;


 

END TASTE_Dataview;